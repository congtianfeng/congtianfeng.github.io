{"meta":{"title":"hasCat","subtitle":"","description":"记录前端知识学习，经验积累，记录生活","author":"congtianfeng","url":"https://congtf.top","root":"/"},"pages":[{"title":"about","date":"2023-03-27T08:21:32.101Z","updated":"2023-03-27T08:21:32.101Z","comments":true,"path":"about/index.html","permalink":"https://congtf.top/about/index.html","excerpt":"","text":"前端技术小白一枚，想要在此记录学习的过程。想要一起学习的小伙伴可以加 QQ：1311783259"},{"title":"categories","date":"2023-03-25T07:06:38.732Z","updated":"2021-09-06T03:42:32.000Z","comments":true,"path":"categories/index.html","permalink":"https://congtf.top/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-03-25T07:06:38.732Z","updated":"2021-09-06T03:42:32.000Z","comments":true,"path":"friends/index.html","permalink":"https://congtf.top/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-25T07:06:38.748Z","updated":"2021-09-06T03:42:32.000Z","comments":true,"path":"tags/index.html","permalink":"https://congtf.top/tags/index.html","excerpt":"","text":""},{"title":"影音播放","date":"2023-03-25T07:06:38.740Z","updated":"2021-09-06T03:42:32.000Z","comments":true,"path":"player/index.html","permalink":"https://congtf.top/player/index.html","excerpt":"","text":"aplayer演示： dplayer演示：(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"video\":{\"url\":\"https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/mp4/mp4_demo.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() bilibili： acfun："}],"posts":[{"title":"实现图片上传预览和裁切功能","slug":"实现图片上传预览和裁切功能","date":"2024-03-14T08:33:12.000Z","updated":"2024-03-14T08:36:35.387Z","comments":true,"path":"2024/03/14/实现图片上传预览和裁切功能/","link":"","permalink":"https://congtf.top/2024/03/14/%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%A2%84%E8%A7%88%E5%92%8C%E8%A3%81%E5%88%87%E5%8A%9F%E8%83%BD/","excerpt":"","text":"一、纯客户端实现上传图片预览12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;客户端图片上传预览示例&lt;/title&gt; &lt;style&gt; .img-wrap &#123; width: 200px; height: 200px; border: 1px solid #ccc; &#125; img &#123; max-width: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;客户端图片上传预览示例&lt;/h1&gt; &lt;div class=&quot;img-wrap&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;&quot; id=&quot;img&quot; /&gt; &lt;/div&gt; &lt;br /&gt; &lt;!-- &lt;button&gt;头像&lt;/button&gt; --&gt; &lt;input hidden type=&quot;file&quot; id=&quot;file&quot; onchange=&quot;onFileChange()&quot; /&gt; &lt;script&gt; const img = document.querySelector(&quot;#img&quot;); const file = document.querySelector(&quot;#file&quot;); // const btn = document.querySelector(&quot;button&quot;); // const ipt = document.querySelector(&quot;input&quot;); function onFileChange() &#123; // 得到 file-input 的文件对象 const fileObj = file.files[0]; const data = window.URL.createObjectURL(fileObj); img.src = data; &#125; // btn.addEventListener(&quot;click&quot;, () =&gt; ipt.click()); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 而在实际的项目中，file 类型的 input 框基本上都是隐藏的，通过另外一个显示的元素的某些事件（比如点击事件）以代码的方式手动触发 input 的点击事件。也就是注释部分。 二、图片裁切1、安装 cropperjs 插件1npm install cropperjs 2、创建图片裁剪组件update-photo.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;template&gt; &lt;div class=&quot;update-photo&quot;&gt; &lt;img class=&quot;img&quot; :src=&quot;img&quot; ref=&quot;img&quot; /&gt; &lt;div class=&quot;toolbar&quot;&gt; &lt;div class=&quot;cancel&quot; @click=&quot;$emit(&#x27;close&#x27;)&quot;&gt;取消&lt;/div&gt; &lt;div class=&quot;confirm&quot; @click=&quot;onConfirm&quot;&gt;完成&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &quot;cropperjs/dist/cropper.css&quot;;import Cropper from &quot;cropperjs&quot;;import &#123; updateUserPhoto &#125; from &quot;@/api/user&quot;;export default &#123; name: &quot;UpdatePhoto&quot;, components: &#123;&#125;, props: &#123; img: &#123; type: [String, Object], required: true, &#125;, &#125;, data() &#123; return &#123; cropper: null, &#125;; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, created() &#123;&#125;, mounted() &#123; const image = this.$refs.img; this.cropper = new Cropper(image, &#123; viewMode: 1, dragMode: &quot;move&quot;, aspectRatio: 1, // autoCropArea: 1, cropBoxMovable: false, cropBoxResizable: false, background: false, &#125;); &#125;, methods: &#123; onConfirm() &#123; // 基于服务端的裁切使用 getData 方法获取裁切参数 // console.log(this.cropper.getData()) // 纯客户端的裁切使用 getCroppedCanvas 获取裁切的文件对象 this.cropper.getCroppedCanvas().toBlob((blob) =&gt; &#123; this.updateUserPhoto(blob); &#125;); &#125;, async updateUserPhoto(blob) &#123; this.$toast.loading(&#123; message: &quot;保存中...&quot;, forbidClick: true, // 禁止背景点击 duration: 0, // 持续展示 &#125;); try &#123; // 错误的用法 // 如果接口要求 Content-Type 是 application/json // 则传递普通 JavaScript 对象 // updateUserPhoto(&#123; // photo: blob // &#125;) // 如果接口要求 Content-Type 是 multipart/form-data // 则你必须传递 FormData 对象 const formData = new FormData(); formData.append(&quot;photo&quot;, blob); const &#123; data &#125; = await updateUserPhoto(formData); // 关闭弹出层 this.$emit(&quot;close&quot;); // 更新视图 this.$emit(&quot;update-photo&quot;, data.data.photo); // 提示成功 this.$toast.success(&quot;更新成功&quot;); &#125; catch (err) &#123; this.$toast.fail(&quot;更新失败&quot;); &#125; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.update-photo &#123; background-color: #000; height: 100%; .toolbar &#123; position: fixed; left: 0; right: 0; bottom: 0; display: flex; justify-content: space-between; .cancel, .confirm &#123; width: 90px; height: 90px; font-size: 30px; display: flex; justify-content: center; align-items: center; color: #fff; &#125; &#125;&#125;.img &#123; display: block; max-width: 100%;&#125;&lt;/style&gt; 可以看到，图片裁剪组件从父组件接收传递过来的图片地址。在 mounted 根据图片 dom 创建一个 cropper 对象，里面的配置参数我们可以根据需要填写。当点击完成时，使用 getCroppedCanvas 获取裁切的文件对象，并将该对象传递给后端。 3、父组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;van-cell class=&quot;photo-cell&quot; title=&quot;头像&quot; is-link center @click=&quot;$refs.file.click()&quot; &gt; &lt;van-image class=&quot;avatar&quot; fit=&quot;cover&quot; round :src=&quot;user.photo&quot; /&gt; &lt;/van-cell&gt; &lt;van-popup v-model=&quot;isUpdatePhotoShow&quot; position=&quot;bottom&quot; style=&quot;height: 100%;&quot; &gt; &lt;update-photo v-if=&quot;isUpdatePhotoShow&quot; :img=&quot;img&quot; @close=&quot;isUpdatePhotoShow = false&quot; @update-photo=&quot;user.photo = $event&quot; /&gt; &lt;/van-popup&gt;&lt;/template&gt;&lt;script&gt;import &#123; getUserProfile &#125; from &quot;@/api/user&quot;;import UpdatePhoto from &quot;./components/update-photo&quot;;export default &#123; name: &quot;UserProfile&quot;, components: &#123; UpdatePhoto, &#125;, props: &#123;&#125;, data() &#123; return &#123; user: &#123;&#125;, // 个人信息 isUpdatePhotoShow: false, img: null, // 预览的图片 &#125;; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, created() &#123; this.loadUserProfile(); &#125;, mounted() &#123;&#125;, methods: &#123; async loadUserProfile() &#123; try &#123; const &#123; data &#125; = await getUserProfile(); this.user = data.data; &#125; catch (err) &#123; this.$toast(&quot;数据获取失败&quot;); &#125; &#125;, onFileChange() &#123; // 获取文件对象 const file = this.$refs.file.files[0]; // 基于文章对象获取 blob 数据 this.img = window.URL.createObjectURL(file); // 展示预览图片弹出层 this.isUpdatePhotoShow = true; // file-input 如果选了同一个文件不会触发 change 事件 // 解决办法就是每次使用完毕，把它的 value 清空 this.$refs.file.value = &quot;&quot;; &#125;, &#125;,&#125;;&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"当后端返回数据中有大数字时的解决方案","slug":"当后端返回数据中有大数字时的解决方案","date":"2024-03-14T08:32:21.000Z","updated":"2024-03-14T08:35:44.712Z","comments":true,"path":"2024/03/14/当后端返回数据中有大数字时的解决方案/","link":"","permalink":"https://congtf.top/2024/03/14/%E5%BD%93%E5%90%8E%E7%AB%AF%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%9C%89%E5%A4%A7%E6%95%B0%E5%AD%97%E6%97%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值，这使得 JavaScript 不适合进行科学和金融方面的精确计算。因此如果后端返回的数据中有大数字，前端不加以处理就会导致数据不能正常处理。 1234567Math.pow(2, 53); // 90071992547409929007199254740992; // 90071992547409929007199254740993; // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1;// true 上面代码中，超出 2 的 53 次方之后，一个数就不精确了。ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1;// trueNumber.MAX_SAFE_INTEGER === 9007199254740991;// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER;// trueNumber.MIN_SAFE_INTEGER === -9007199254740991;// true 上面代码中，可以看到 JavaScript 能够精确表示的极限。 后端返回的数据一般都是 JSON 格式的字符串。 1&quot;&#123; \\&quot;id\\&quot;: 9007199254740995, \\&quot;name\\&quot;: \\&quot;Jack\\&quot;, \\&quot;age\\&quot;: 18 &#125;&quot; 如果这个字符不做任何处理，你能方便的获取到字符串中的指定数据吗？非常麻烦。所以我们要把它转换为 JavaScript 对象来使用就很方便了。 幸运的是 axios 为了方便我们使用数据，它会在内部使用 JSON.parse() 把后端返回的数据转为 JavaScript 对象。 12// &#123; id: 9007199254740996, name: &#x27;Jack&#x27;, age: 18 &#125;JSON.parse(&#x27;&#123; &quot;id&quot;: 9007199254740995, &quot;name&quot;: &quot;Jack&quot;, &quot;age&quot;: 18 &#125;&#x27;); 可以看到，超出安全整数范围的 id 无法精确表示，这个问题并不是 axios 的错。 了解了什么是大整数的概念，接下来的问题是如何解决？ json-bigint 是一个第三方包，它可以帮我们很好的处理这个问题。 使用它的第一步就是把它安装到你的项目中。 1npm i json-bigint 下面是使用它的一个简单示例。 1234567891011121314const jsonStr = &#x27;&#123; &quot;art_id&quot;: 1245953273786007552 &#125;&#x27;;console.log(JSON.parse(jsonStr)); // 1245953273786007600// JSON.stringify()// JSONBig 可以处理数据中超出 JavaScript 安全整数范围的问题console.log(JSONBig.parse(jsonStr)); // 把 JSON 格式的字符串转为 JavaScript 对象// 使用的时候需要把 BigNumber 类型的数据转为字符串来使用console.log(JSONBig.parse(jsonStr).art_id.toString()); // 1245953273786007552console.log(JSON.stringify(JSONBig.parse(jsonStr)));console.log(JSONBig.stringify(JSONBig.parse(jsonStr))); // 把 JavaScript 对象 转为 JSON 格式的字符串转 json-bigint 会把超出 JS 安全整数范围的数字转为一个 BigNumber 类型的对象，对象数据是它内部的一个算法处理之后的，我们要做的就是在使用的时候转为字符串来使用。 通过 Axios 请求得到的数据都是 Axios 处理（JSON.parse）之后的，我们应该在 Axios 执行处理之前手动使用 json-bigint 来解析处理。Axios 提供了自定义处理原始后端返回数据的 API：transformResponse 。 12345678910111213141516171819202122232425262728import axios from &quot;axios&quot;;import jsonBig from &quot;json-bigint&quot;;var json = &#x27;&#123; &quot;value&quot; : 9223372036854775807, &quot;v2&quot;: 123 &#125;&#x27;;console.log(jsonBig.parse(json));const request = axios.create(&#123; baseURL: &quot;http://ttapi.research.itcast.cn/&quot;, // 接口基础路径 // transformResponse 允许自定义原始的响应数据（字符串） transformResponse: [ function (data) &#123; try &#123; // 如果转换成功则返回转换的数据结果 return jsonBig.parse(data); &#125; catch (err) &#123; // 如果转换失败，则包装为统一数据格式并返回 return &#123; data, &#125;; &#125; &#125;, ],&#125;);export default request; 扩展：ES2020 BigInt ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。 参考链接： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects&#x2F;BigInt http://es6.ruanyifeng.com/#docs/number#BigInt-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"移动端图片预览实现","slug":"移动端图片预览实现","date":"2024-03-14T08:31:30.000Z","updated":"2024-03-14T08:36:15.605Z","comments":true,"path":"2024/03/14/移动端图片预览实现/","link":"","permalink":"https://congtf.top/2024/03/14/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9B%BE%E7%89%87%E9%A2%84%E8%A7%88%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"思路： 1、从文章内容中获取到所有的 img DOM 节点 2、获取文章内容中所有的图片地址 3、遍历所有 img 节点，给每个节点注册点击事件 4、在 img 点击事件处理函数中，调用 vant 提供的 ImagePreview 预览 实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div class=&quot;article-content markdown-body&quot; v-html=&quot;article.content&quot; ref=&quot;article-content&quot; &gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; article: &#123;&#125; &#125; &#125; methods: &#123; async loadArticle () &#123; try &#123; const &#123; data &#125; = await getArticleById(this.articleId) // 数据驱动视图这件事儿不是立即的 this.article = data.data // 初始化图片点击预览。因为vue更新dom是异步的，所以这里获取文章数据后，马上通过ref这种方式 // 是获取不到最新的dom的，除了下面这种方式，也可以通过$nextTick setTimeout(() =&gt; &#123; this.previewImage() &#125;, 0) &#125; catch (err) &#123; if (err.response &amp;&amp; err.response.status === 404) &#123; this.errStatus = 404 &#125; &#125; &#125;, previewImage () &#123; // 得到所有的 img 节点 const articleContent = this.$refs[&#x27;article-content&#x27;] const imgs = articleContent.querySelectorAll(&#x27;img&#x27;) // 获取所有 img 地址 const images = [] imgs.forEach((img, index) =&gt; &#123; images.push(img.src) // 给每个 img 注册点击事件，在处理函数中调用预览 img.onclick = () =&gt; &#123; ImagePreview(&#123; // 预览的图片地址数组 images, // 起始位置，从 0 开始 startPosition: index &#125;) &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"移动端搜索栏实现","slug":"移动端搜索栏实现","date":"2024-03-14T08:30:58.000Z","updated":"2024-03-14T08:35:09.642Z","comments":true,"path":"2024/03/14/移动端搜索栏实现/","link":"","permalink":"https://congtf.top/2024/03/14/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%90%9C%E7%B4%A2%E6%A0%8F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"一、搜索栏常用功能一般搜索栏会有搜索联想提示功能、搜索历史和搜索结果功能。因此我们可以将整个组件拆分成搜索联想建议、搜索结果、搜索历史记录三个组件 二、创建父组件并配置路由1、创建 src/views/search/index.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;div class=&quot;search-container&quot;&gt; &lt;!-- 搜索栏 --&gt; &lt;!-- Tips: 在 van-search 外层增加 form 标签，且 action 不为空，即可在 iOS 输入法中显示搜索按钮 --&gt; &lt;form action=&quot;/&quot;&gt; &lt;van-search v-model=&quot;searchText&quot; show-action placeholder=&quot;请输入搜索关键词&quot; background=&quot;#3296fa&quot; @search=&quot;onSearch&quot; @cancel=&quot;onCancel&quot; /&gt; &lt;/form&gt; &lt;!-- /搜索栏 --&gt; &lt;!-- 搜索历史记录 --&gt; &lt;search-history /&gt; &lt;!-- /搜索历史记录 --&gt; &lt;!-- 联想建议 --&gt; &lt;search-suggestion /&gt; &lt;!-- /联想建议 --&gt; &lt;!-- 历史记录 --&gt; &lt;search-result /&gt; &lt;!-- /历史记录 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import SearchHistory from &quot;./components/search-history&quot;;import SearchSuggestion from &quot;./components/search-suggestion&quot;;import SearchResult from &quot;./components/search-result&quot;;export default &#123; name: &quot;SearchIndex&quot;, components: &#123; SearchHistory, SearchSuggestion, SearchResult, &#125;, props: &#123;&#125;, data() &#123; return &#123; searchText: &quot;&quot;, &#125;; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, created() &#123;&#125;, mounted() &#123;&#125;, methods: &#123; onSearch(val) &#123; console.log(val); &#125;, onCancel() &#123; this.$router.back(); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.search-container &#123; .van-search__action &#123; color: #fff; &#125;&#125;&lt;/style&gt; 2、然后把搜索页面的路由配置到根组件路由（一级路由） 1234&#123; path: &#x27;/search&#x27;, omponent: Search&#125; 三、搜索历史记录子组件创建 src/views/search/components/search-history.vue 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class=&quot;search-history&quot;&gt; &lt;van-cell title=&quot;搜索历史&quot;&gt; &lt;span&gt;全部删除&lt;/span&gt; &lt;span&gt;完成&lt;/span&gt; &lt;van-icon name=&quot;delete&quot; /&gt; &lt;/van-cell&gt; &lt;van-cell title=&quot;hello&quot;&gt; &lt;van-icon name=&quot;close&quot; /&gt; &lt;/van-cell&gt; &lt;van-cell title=&quot;hello&quot;&gt; &lt;van-icon name=&quot;close&quot; /&gt; &lt;/van-cell&gt; &lt;van-cell title=&quot;hello&quot;&gt; &lt;van-icon name=&quot;close&quot; /&gt; &lt;/van-cell&gt; &lt;van-cell title=&quot;hello&quot;&gt; &lt;van-icon name=&quot;close&quot; /&gt; &lt;/van-cell&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;SearchHistory&quot;, components: &#123;&#125;, props: &#123;&#125;, data() &#123; return &#123;&#125;; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, created() &#123;&#125;, mounted() &#123;&#125;, methods: &#123;&#125;, &#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt; 四、搜索联想建议子组件创建 src/views/search/components/search-suggestion.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;search-suggestion&quot;&gt; &lt;van-cell title=&quot;黑马程序员...&quot; icon=&quot;search&quot;&gt;&lt;/van-cell&gt; &lt;van-cell title=&quot;黑马程序员...&quot; icon=&quot;search&quot;&gt;&lt;/van-cell&gt; &lt;van-cell title=&quot;黑马程序员...&quot; icon=&quot;search&quot;&gt;&lt;/van-cell&gt; &lt;van-cell title=&quot;黑马程序员...&quot; icon=&quot;search&quot;&gt;&lt;/van-cell&gt; &lt;van-cell title=&quot;黑马程序员...&quot; icon=&quot;search&quot;&gt;&lt;/van-cell&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;SearchSuggestion&quot;, components: &#123;&#125;, props: &#123;&#125;, data() &#123; return &#123;&#125;; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, created() &#123;&#125;, mounted() &#123;&#125;, methods: &#123;&#125;, &#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt; 五、搜索结果子组件 创建 src/views/search/components/search-result.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;template&gt; &lt;div class=&quot;search-result&quot;&gt; &lt;van-list v-model=&quot;loading&quot; :finished=&quot;finished&quot; finished-text=&quot;没有更多了&quot; @load=&quot;onLoad&quot; &gt; &lt;van-cell v-for=&quot;item in list&quot; :key=&quot;item&quot; :title=&quot;item&quot; /&gt; &lt;/van-list&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;SearchResult&quot;, components: &#123;&#125;, props: &#123;&#125;, data() &#123; return &#123; list: [], loading: false, finished: false, &#125;; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, created() &#123;&#125;, mounted() &#123;&#125;, methods: &#123; onLoad() &#123; // 异步更新数据 // setTimeout 仅做示例，真实场景中一般为 ajax 请求 setTimeout(() =&gt; &#123; for (let i = 0; i &lt; 10; i++) &#123; this.list.push(this.list.length + 1); &#125; // 加载状态结束 this.loading = false; // 数据全部加载完成 if (this.list.length &gt;= 40) &#123; this.finished = true; &#125; &#125;, 1000); &#125;, &#125;, &#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt; 六、处理页面显示状态我们可以定义一个 isResultShow 变量来控制搜索结果的显示与否。当用户点击确定或者选中某条搜索历史记录时展示搜索结果。而联想建议和搜索历史记录则可以通过搜索栏是否有值来互斥的显示。 1、在 data 中添加数据用来控制搜索结果的显示状态 1234data () &#123; ... isResultShow: false&#125; 2、在模板中绑定条件渲染 1234567891011&lt;!-- 搜索结果 --&gt;&lt;search-result v-if=&quot;isResultShow&quot; /&gt;&lt;!-- /搜索结果 --&gt;&lt;!-- 联想建议 --&gt;&lt;search-suggestion v-else-if=&quot;searchText&quot; /&gt;&lt;!-- /联想建议 --&gt;&lt;!-- 搜索历史记录 --&gt;&lt;search-history v-else /&gt;&lt;!-- /搜索历史记录 --&gt; 七、搜索联想建议基本思路： 当搜索框输入内容的时候，请求加载联想建议的数据 将请求得到的结果绑定到模板中 基本功能一、将父组件中搜索框输入的内容传给联想建议子组件 二、在子组件中监视搜索框输入内容的变化，如果变化则请求获取联想建议数据 三、将获取到的联想建议数据展示到列表中 防抖优化1、安装 lodash 12# yarn add lodashnpm i lodash 2、防抖处理 12// lodash 支持按需加载，有利于打包结果优化import &#123; debounce &#125; from &quot;lodash&quot;; 不建议下面这样使用，因为这样会加载整个模块。 12import _ from &quot;lodash&quot;;_.debounce(); 123456789101112131415161718// debounce 函数// 参数1：函数// 参数2：防抖时间// 返回值：防抖之后的函数，和参数1功能是一样的onSearchInput: debounce(async function () &#123; const searchContent = this.searchContent if (!searchContent) &#123; return &#125; // 1. 请求获取数据 const &#123; data &#125; = await getSuggestions(searchContent) // 2. 将数据添加到组件实例中 this.suggestions = data.data.options // 3. 模板绑定&#125;, 200), PC 端的联想搜索则可以借助 elementPlus 的 Autocomplete 自动补全输入框组件轻易实现 八、搜索关键字高亮如何将字符串中的指定字符在网页中高亮展示？ 1&quot;Hello World&quot;; 将需要高亮的字符包裹 HTML 标签，为其单独设置颜色。 1&quot;Hello &lt;span style=&quot;color: red&quot;&gt;World&lt;/span&gt;&quot; 在 Vue 中如何渲染带有 HTML 标签的字符串？ 12345data () &#123; return &#123; htmlStr: &#x27;Hello &lt;span style=&quot;color: red&quot;&gt;World&lt;/span&gt;&#x27; &#125;&#125; 12&lt;div&gt;&#123;&#123; htmlStr &#125;&#125;&lt;/div&gt;&lt;div v-html=&quot;htmlStr&quot;&gt;&lt;/div&gt; ![image-20200112154732044](E:\\web 前端开发\\02-配套课件\\005- Vue.js 基础到高级项目实战\\阶段五：社交媒体-头条项目资料\\前端 vue 移动端项目资料\\vue 移动端项目第一天\\讲义\\讲义\\assets\\image-20200112154732044.png) 如何把字符串中指定字符统一替换为高亮（包裹了 HTML）的字符？ 1234567891011121314151617181920const str = &quot;Hello World&quot;;// 结果：&lt;span style=&quot;color: red&quot;&gt;Hello&lt;/span&gt; World&quot;Hello World&quot;.replace(&quot;Hello&quot;, &#x27;&lt;span style=&quot;color: red&quot;&gt;Hello&lt;/span&gt;&#x27;);// 需要注意的是，replace 方法的字符串匹配只能替换第1个满足的字符// &lt;span style=&quot;color: red&quot;&gt;Hello&lt;/span&gt; World Hello abc&quot;Hello World Hello abc&quot;.replace( &quot;Hello&quot;, &#x27;&lt;span style=&quot;color: red&quot;&gt;Hello&lt;/span&gt;&#x27;);// 如果想要全文替换，使用正则表达式// g 全局// i 忽略大小写// &lt;span style=&quot;color: red&quot;&gt;Hello&lt;/span&gt; World &lt;span style=&quot;color: red&quot;&gt;Hello&lt;/span&gt; abc&quot;Hello World Hello abc&quot;.replace( /Hello/gi, &#x27;&lt;span style=&quot;color: red&quot;&gt;Hello&lt;/span&gt;&#x27;); 一个小扩展：使用字符串的 split 结合数组的 join 方法实现高亮 1234567var str = &quot;hello world 你好 hello&quot;;// [&quot;&quot;, &quot; world 你好 &quot;, &quot;&quot;]const arr = str.split(&quot;hello&quot;);// &quot;&lt;span&gt;hello&lt;/span&gt; world 你好 &lt;span&gt;hello&lt;/span&gt;&quot;arr.join(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;); 下面是具体的处理。 1、在 methods 中添加一个方法处理高亮 123456789101112// 参数 source: 原始字符串// 参数 keyword: 需要高亮的关键词// 返回值：替换之后的高亮字符串highlight (source, keyword) &#123; // /searchContent/ 正则表达式中的一切内容都会当做字符串使用 // 这里可以 new RegExp 方式根据字符串创建一个正则表达式 // RegExp 是原生 JavaScript 的内置构造函数 // 参数1：字符串，注意，这里不要加 // // 参数2：匹配模式，g 全局，i 忽略大小写 const reg = new RegExp(keyword, &#x27;gi&#x27;) return source.replace(reg, `&lt;span style=&quot;color: #3296fa&quot;&gt;$&#123;keyword&#125;&lt;/span&gt;`)&#125;, 2、然后在联想建议列表项中绑定调用 123456789101112&lt;!-- 联想建议 --&gt;&lt;van-cell-group v-else-if=&quot;searchContent&quot;&gt; &lt;van-cell icon=&quot;search&quot; v-for=&quot;(item, index) in suggestions&quot; :key=&quot;index&quot; @click=&quot;onSearch(item)&quot; &gt; &lt;div slot=&quot;title&quot; v-html=&quot;highlight(item, searchContent)&quot;&gt;&lt;/div&gt; &lt;/van-cell&gt;&lt;/van-cell-group&gt;&lt;!-- /联想建议 --&gt; 九、搜索结果思路： 找到数据接口 请求获取数据 将数据展示到模板中 一、获取搜索关键字 1、声明接收父组件中的搜索框输入的内容 123456props: &#123; q: &#123; type: String, require: true &#125;&#125;, 2、在父组件给子组件传递数据 123&lt;!-- 搜索结果 --&gt;&lt;search-result v-if=&quot;isResultShow&quot; :q=&quot;searchText&quot; /&gt;&lt;!-- /搜索结果 --&gt; 最后在调试工具中查看确认是否接收到 props 数据。 ![image-20200112162223915](E:\\web 前端开发\\02-配套课件\\005- Vue.js 基础到高级项目实战\\阶段五：社交媒体-头条项目资料\\前端 vue 移动端项目资料\\vue 移动端项目第一天\\讲义\\讲义\\assets\\image-20200112162223915.png) 二、请求获取数据 1、在 api/serach.js 添加封装获取搜索结果的请求方法 12345678910/** * 获取搜索结果 */export function getSearch(params) &#123; return request(&#123; method: &quot;GET&quot;, url: &quot;/app/v1_0/search&quot;, params, &#125;);&#125; 2、请求获取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849+ import &#123; getSearch &#125; from &#x27;@/api/search&#x27;export default &#123; name: &#x27;SearchResult&#x27;, components: &#123;&#125;, props: &#123; q: &#123; type: String, require: true &#125; &#125;, data () &#123; return &#123; list: [], loading: false, finished: false,+ page: 1,+ perPage: 20 &#125; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, created () &#123;&#125;, mounted () &#123;&#125;, methods: &#123;+++ async onLoad () &#123; // 1. 请求获取数据 const &#123; data &#125; = await getSearch(&#123; page: this.page, // 页码 per_page: this.perPage, // 每页大小 q: this.q // 搜索关键字 &#125;) // 2. 将数据添加到列表中 const &#123; results &#125; = data.data this.list.push(...results) // 3. 设置加载状态结束 this.loading = false // 4. 判断数据是否加载完毕 if (results.length) &#123; this.page++ // 更新获取下一页数据的页码 &#125; else &#123; this.finished = true // 没有数据了，将加载状态设置结束，不再 onLoad &#125; &#125; &#125;&#125; 三、最后，模板绑定 123456789101112131415&lt;van-list v-model=&quot;loading&quot; :finished=&quot;finished&quot; finished-text=&quot;没有更多了&quot; @load=&quot;onLoad&quot;&gt; &lt;van-cell + v-for=&quot;(article, index) in list&quot; + :key=&quot;index&quot; + :title=&quot;article.title&quot; /&gt;&lt;/van-list&gt; 十、搜索历史记录添加历史记录当发生搜索的时候我们才需要记录历史记录。 1、在 data 中添加一个数据用来存储历史记录 123456data () &#123; return &#123; ... searchHistories: [] &#125;&#125; 2、在触发搜索的时候，记录历史记录 123456789101112131415onSearch (val) &#123; // 更新文本框内容 this.searchText = val // 存储搜索历史记录 // 要求：不要有重复历史记录、最新的排在最前面 const index = this.searchHistories.indexOf(val) if (index !== -1) &#123; this.searchHistories.splice(index, 1) &#125; this.searchHistories.unshift(val) // 渲染搜索结果 this.isResultShow = true&#125;, 展示历史记录12345678910111213&lt;!-- 历史记录 --&gt;&lt;van-cell-group v-else&gt; &lt;van-cell title=&quot;历史记录&quot;&gt; &lt;van-icon name=&quot;delete&quot; /&gt; &lt;span&gt;全部删除&lt;/span&gt; &amp;nbsp;&amp;nbsp; &lt;span&gt;完成&lt;/span&gt; &lt;/van-cell&gt; &lt;van-cell :title=&quot;item&quot; v-for=&quot;(item, index) in searchHistories&quot; :key=&quot;index&quot;&gt; &lt;van-icon name=&quot;close&quot;&gt;&lt;/van-icon&gt; &lt;/van-cell&gt;&lt;/van-cell-group&gt;&lt;!-- /历史记录 --&gt; 删除历史记录基本思路： 给历史记录中的每一项注册点击事件 在处理函数中判断 如果是删除状态，则执行删除操作 如果是非删除状态，则执行搜索操作 一、处理删除相关元素的展示状态 1、在 data 中添加一个数据用来控制删除相关元素的显示状态 123456data () &#123; return &#123; ... isDeleteShow: false &#125;&#125; 2、绑定使用 123456789101112131415161718192021222324&lt;!-- 历史记录 --&gt;&lt;van-cell-group v-else&gt; &lt;van-cell title=&quot;历史记录&quot;&gt; &lt;template v-if=&quot;isDeleteShow&quot;&gt; &lt;span @click=&quot;searchHistories = []&quot;&gt;全部删除&lt;/span&gt; &amp;nbsp;&amp;nbsp; &lt;span @click=&quot;isDeleteShow = false&quot;&gt;完成&lt;/span&gt; &lt;/template&gt; &lt;van-icon v-else name=&quot;delete&quot; @click=&quot;isDeleteShow = true&quot;&gt;&lt;/van-icon&gt; &lt;/van-cell&gt; &lt;van-cell :title=&quot;item&quot; v-for=&quot;(item, index) in searchHistories&quot; :key=&quot;index&quot; @click=&quot;onSearch(item)&quot; &gt; &lt;van-icon v-show=&quot;isDeleteShow&quot; name=&quot;close&quot; @click=&quot;searchHistories.splice(index, 1)&quot; &gt;&lt;/van-icon&gt; &lt;/van-cell&gt;&lt;/van-cell-group&gt;&lt;!-- /历史记录 --&gt; 二、处理删除操作 123456789101112131415161718192021&lt;!-- 历史记录 --&gt;&lt;van-cell-group v-else&gt; &lt;van-cell title=&quot;历史记录&quot;&gt; &lt;template v-if=&quot;isDeleteShow&quot;&gt; + &lt;span @click=&quot;searchHistories = []&quot;&gt;全部删除&lt;/span&gt; &amp;nbsp;&amp;nbsp; &lt;span @click=&quot;isDeleteShow = false&quot;&gt;完成&lt;/span&gt; &lt;/template&gt; &lt;van-icon v-else name=&quot;delete&quot; @click=&quot;isDeleteShow = true&quot; /&gt; &lt;/van-cell&gt; &lt;van-cell :title=&quot;item&quot; v-for=&quot;(item, index) in searchHistories&quot; :key=&quot;index&quot; + @click=&quot;onHistoryClick(item, index)&quot; &gt; &lt;van-icon v-show=&quot;isDeleteShow&quot; name=&quot;close&quot;&gt;&lt;/van-icon&gt; &lt;/van-cell&gt;&lt;/van-cell-group&gt;&lt;!-- /历史记录 --&gt; 123456789onHistoryClick (item, index) &#123; // 如果是删除状态，则执行删除操作 if (this.isDeleteShow) &#123; this.searchHistories.splice(index, 1) &#125; else &#123; // 否则执行搜索操作 this.onSearch(item) &#125;&#125; 数据持久化1、利用 watch 监视统一存储数据 123456watch: &#123; searchHistories (val) &#123; // 同步到本地存储 setItem(&#x27;serach-histories&#x27;, val) &#125;&#125;, 2、初始化的时候从本地存储获取数据 123456data () &#123; return &#123; ... searchHistories: getItem(&#x27;serach-histories&#x27;) || [], &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"第三方图片资源403问题的一种解决方案","slug":"第三方图片资源403问题的一种解决方案","date":"2024-03-14T08:30:32.000Z","updated":"2024-03-14T08:34:52.115Z","comments":true,"path":"2024/03/14/第三方图片资源403问题的一种解决方案/","link":"","permalink":"https://congtf.top/2024/03/14/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90403%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"有时候如果我们项目的接口数据是后端通过爬虫抓取的第三方平台内容，而第三方平台对图片资源做了防盗链保护处理。那么好多图片就会资源请求失败返回 403。 第三方平台怎么处理图片资源保护的？ 服务端一般使用 Referer 请求头识别访问来源，然后处理资源访问。 Referer 是什么东西？ 扩展参考：http://www.ruanyifeng.com/blog/2019/06/http-referer.html 1Referer 是 HTTP 请求头的一部分，当浏览器向 Web 服务器发送请求的时候，一般会带上 Referer，它包含了当前请求资源的来源页面的地址。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。 需要注意的是 referer 实际上是 “referrer” 误拼写。参见 HTTP referer on Wikipedia （HTTP referer 在维基百科上的条目）来获取更详细的信息。 怎么解决？ 不要发送 referrer ，对方服务端就不知道你从哪来的了，姑且认为是你是自己人吧。 如何设置不发送 referrer？ 用 &lt;a&gt;、&lt;area&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;script&gt; 或者 &lt;link&gt; 元素上的 referrerpolicy 属性为其设置独立的请求策略，例如： 1&lt;img src=&quot;http://……&quot; referrerpolicy=&quot;no-referrer&quot; /&gt; 或者直接在 HTMl 页面头中通过 meta 属性全局配置： 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"文件预览功能","slug":"文件预览功能","date":"2024-03-13T08:27:46.000Z","updated":"2024-03-13T08:30:30.874Z","comments":true,"path":"2024/03/13/文件预览功能/","link":"","permalink":"https://congtf.top/2024/03/13/%E6%96%87%E4%BB%B6%E9%A2%84%E8%A7%88%E5%8A%9F%E8%83%BD/","excerpt":"","text":"我这里实现了图片、excel、docx、pdf 格式的文件在浏览器中预览 一、插件安装1npm install @vue-office/docx @vue-office/excel @vue-office/pdf 二、路由配置我将预览页做成了一个单独的路由页面（一级），因此需要配置下路由 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;;import Login from &quot;../views/Login.vue&quot;;import Home from &quot;../views/Home.vue&quot;;import Welcome from &quot;../views/Welcome.vue&quot;;const routes = [ &#123; path: &quot;/&quot;, redirect: &quot;/login&quot;, meta: &#123; title: &quot;登录页&quot; &#125;, &#125;, &#123; path: &quot;/login&quot;, name: &quot;login&quot;, component: Login, meta: &#123; title: &quot;登录页&quot; &#125;, &#125;, &#123; path: &quot;/home&quot;, name: &quot;home&quot;, component: Home, redirect: &quot;welcome&quot;, meta: &#123; title: &quot;欢迎页&quot; &#125;, children: [ &#123; path: &quot;/welcome&quot;, name: &quot;welcome&quot;, component: Welcome, meta: &#123; title: &quot;欢迎页&quot; &#125;, &#125;, &#123; path: &quot;/myDoTask&quot;, name: &quot;myDoTask&quot;, component: () =&gt; import(&quot;@/views/workBench/MyDoTask.vue&quot;), meta: &#123; title: &quot;我的待办&quot; &#125;, &#125;, &#123; path: &quot;/myDidTask&quot;, name: &quot;myDidTask&quot;, component: () =&gt; import(&quot;@/views/workBench/MyDidTask.vue&quot;), meta: &#123; title: &quot;我的已办&quot; &#125;, &#125;, &#123; path: &quot;/myApplyTask&quot;, name: &quot;myApplyTask&quot;, component: () =&gt; import(&quot;@/views/workBench/MyApplyTask.vue&quot;), meta: &#123; title: &quot;我的申请&quot; &#125;, &#125;, &#123; path: &quot;/myReadTask&quot;, name: &quot;myReadTask&quot;, component: () =&gt; import(&quot;@/views/workBench/MyReadTask.vue&quot;), meta: &#123; title: &quot;我的阅知&quot; &#125;, &#125;, &#123; path: &quot;/myReadDoneTask&quot;, name: &quot;myReadDoneTask&quot;, component: () =&gt; import(&quot;@/views/workBench/MyReadDoneTask.vue&quot;), meta: &#123; title: &quot;我的已阅&quot; &#125;, &#125;, &#123; path: &quot;/myDraftTask&quot;, name: &quot;myDraftTask&quot;, component: () =&gt; import(&quot;@/views/workBench/MyDraftTask.vue&quot;), meta: &#123; title: &quot;我的草稿箱&quot; &#125;, &#125;, &#123; path: &quot;/marketingGeFix/:WfCode&quot;, name: &quot;marketingGeFix/:WfCode&quot;, component: () =&gt; import(&quot;@/views/marketing/MarketingGeFix.vue&quot;), meta: &#123; title: &quot;营销审批-政企产品类(含高校)-固话&quot; &#125;, &#125;, ], &#125;, &#123; path: &quot;/printDidTask&quot;, name: &quot;printDidTask&quot;, component: () =&gt; import(&quot;@/views/print/PrintDidTask.vue&quot;), meta: &#123; title: &quot;已办打印&quot; &#125;, &#125;, // 附件预览页面 &#123; path: &quot;/preview&quot;, name: &quot;preview&quot;, component: () =&gt; import(&quot;@/views/preview/preview.vue&quot;), meta: &#123; title: &quot;附件预览&quot; &#125;, &#125;, &#123; path: &quot;/403&quot;, name: &quot;403&quot;, meta: &#123; title: &quot;没有权限&quot;, &#125;, component: () =&gt; import(&quot;@/views/403.vue&quot;), &#125;, &#123; path: &quot;/:pathMatch(.*)&quot;, name: &quot;404&quot;, meta: &#123; title: &quot;页面不存在&quot;, &#125;, component: () =&gt; import(&quot;@/views/404.vue&quot;), &#125;,];const router = createRouter(&#123; history: createWebHashHistory(), routes, base: &quot;/approve/&quot;,&#125;);const whiteList = [ &quot;/403&quot;, &quot;/404&quot;, &quot;/home&quot;, &quot;/welcome&quot;, &quot;/myDoTask&quot;, &quot;/myDidTask&quot;, &quot;/myApplyTask&quot;, &quot;/myReadTask&quot;, &quot;/myReadDoneTask&quot;, &quot;/myDraftTask&quot;, &quot;/printDidTask&quot;, &quot;/printDidTaskPrettyNumber&quot;, &quot;/preview&quot;,];// 挂载路由导航守卫router.beforeEach(async (to, from, next) =&gt; &#123; if (to.path === &quot;/login&quot; || to.path === &quot;/403&quot; || to.path === &quot;/404&quot;) &#123; return next(); &#125; // 获取token const tokenStr = window.sessionStorage.getItem(&quot;token&quot;); if (!tokenStr) &#123; return next(&quot;/login&quot;); &#125; else &#123; if (whiteList.includes(to.path)) return next(); // 获取to.path对应的menu_id // const &#123; data &#125; = await getMenuIdByURLAPI(&#123; menu_url: to.path.substring(1) &#125;) // debugger const menuInfoList = JSON.parse(window.sessionStorage.getItem(&quot;menuInfo&quot;)); const result = menuInfoList.filter((item) =&gt; &#123; return item.menu_url === to.path.substring(1); &#125;); const menuIdList = result.map((item) =&gt; item.menu_id + &quot;&quot;); if (result) &#123; // 根据staff_code 和menu_id获取用户页面访问权限 const userMenuAccessList = JSON.parse( window.sessionStorage.getItem(&quot;userMenuAccess&quot;) ); const res = userMenuAccessList.find((item) =&gt; menuIdList.includes(item.menu_id) ); if (res) &#123; next(); &#125; else &#123; next(&quot;/403&quot;); &#125; &#125; else &#123; next(&quot;/404&quot;); &#125; &#125;&#125;);export default router; 三、预览组件创建路由中对应的预览组件 preview.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;template&gt; &lt;div class=&quot;previewContainer&quot;&gt; &lt;el-image v-if=&quot;fileType === &#x27;jpg&#x27; || fileType === &#x27;png&#x27; || fileType === &#x27;bmp&#x27;&quot; :src=&quot;fileURL&quot; @error=&quot;errorHandler&quot; &gt;&lt;/el-image&gt; &lt;vue-office-docx v-if=&quot;fileType === &#x27;docx&#x27;&quot; :src=&quot;fileURL&quot; style=&quot;height: 100vh&quot; @error=&quot;errorHandler&quot; /&gt; &lt;vue-office-excel v-if=&quot;fileType === &#x27;xlsx&#x27;&quot; :src=&quot;fileURL&quot; style=&quot;height: 100vh&quot; @error=&quot;errorHandler&quot; /&gt; &lt;vue-office-pdf v-if=&quot;fileType === &#x27;pdf&#x27;&quot; :src=&quot;fileURL&quot; @error=&quot;errorHandler&quot; /&gt; &lt;el-button type=&quot;success&quot; round class=&quot;returnBtn&quot; @click=&quot;$router.back()&quot; &gt;返回&lt;/el-button &gt; &lt;el-button type=&quot;success&quot; round class=&quot;downloadBtn&quot; @click=&quot;download(appendHandler)&quot; &gt;下载&lt;/el-button &gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useRoute &#125; from &quot;vue-router&quot;;// 引入VueOfficeDocx组件import VueOfficeDocx from &quot;@vue-office/docx&quot;;// 引入相关样式import &quot;@vue-office/docx/lib/index.css&quot;;// 引入VueOfficeExcel组件import VueOfficeExcel from &quot;@vue-office/excel&quot;;// 引入相关样式import &quot;@vue-office/excel/lib/index.css&quot;;// 引入VueOfficePdf组件import VueOfficePdf from &quot;@vue-office/pdf&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;import &#123; gdownloadAPI, getDownloadUrlAPI &#125; from &quot;@/api/TaskDetail&quot;;import &#123; ref, onMounted &#125; from &quot;vue&quot;;const route = useRoute();const fileType = route.params.fileType;const fileURL = ref(null);const getfileURL = async () =&gt; &#123; if (fileType === &quot;jpg&quot; || fileType === &quot;png&quot; || fileType === &quot;bmp&quot;) &#123; getDownloadUrlAPI(&#123; fileNameHandler: route.params.appendHandler &#125;).then( (res) =&gt; &#123; // 通过row.fileName.substring(row.fileName.lastIndexOf(&#x27;.&#x27;) + 1)获取文件的后缀名 fileURL.value = res.data.fileDownloadUrl; &#125; ); &#125; else &#123; const &#123; data &#125; = await gdownloadAPI(&#123; fileNameHandler: route.params.appendHandler, &#125;); const binaryStr = window.atob(data.fileContent); const ab = new ArrayBuffer(binaryStr.length); const ia = new Uint8Array(ab); for (let i = 0; i &lt; binaryStr.length; i++) &#123; ia[i] = binaryStr.charCodeAt(i); &#125; const blob = new Blob([ia]); // new Blob([res])中不加data就会返回下图中[objece objece]内容（少取一层） const fileReader = new FileReader(); fileReader.readAsArrayBuffer(blob); fileReader.onload = () =&gt; &#123; // 将 ArrayBuffer 数据转换为 Base64 字符串 fileURL.value = fileReader.result; &#125;; &#125;&#125;;onMounted(() =&gt; &#123; getfileURL();&#125;);const appendHandler = route.params.appendHandler;const errorHandler = () =&gt; &#123; ElMessage.error(&quot;文件预览失败！&quot;);&#125;;const download = async (item) =&gt; &#123; try &#123; const &#123; data &#125; = await gdownloadAPI(&#123; fileNameHandler: item, &#125;); const binaryStr = window.atob(data.fileContent); const ab = new ArrayBuffer(binaryStr.length); const ia = new Uint8Array(ab); for (let i = 0; i &lt; binaryStr.length; i++) &#123; ia[i] = binaryStr.charCodeAt(i); &#125; const blob = new Blob([ia]); // new Blob([res])中不加data就会返回下图中[objece objece]内容（少取一层） const fileName = route.params.filename; // 下载文件名称 const alink = document.createElement(&quot;a&quot;); alink.download = fileName; alink.style.display = &quot;none&quot;; alink.href = URL.createObjectURL(blob); document.body.appendChild(alink); alink.click(); URL.revokeObjectURL(alink.href); // 释放URL 对象 document.body.removeChild(alink); ElMessage.success(&quot;下载成功&quot;); &#125; catch &#123; ElMessage.error(&quot;下载失败&quot;); &#125;&#125;;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;.previewContainer &#123; margin: 0; padding: 0 100px; background-color: rgb(14, 14, 14); .returnBtn &#123; position: fixed; bottom: 5px; right: 52%; opacity: 0.8; &#125; .downloadBtn &#123; position: fixed; bottom: 5px; right: 47%; opacity: 0.8; &#125;&#125;&lt;/style&gt; 四、使用预览功能当在其他地方需要预览文件时，跳转到预览组件，并通过路由传递参数 12345678910111213141516171819&lt;template&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;preview(scope.$index, scope.row)&quot; &gt;预览&lt;/el-button &gt;&lt;/template&gt;&lt;script setup&gt;const preview = async (index, row) =&gt; &#123; // 跳转之前先通知父组件保存页面的状态数据，这样预览返回的时候可以保持原来的状态 emit(&quot;saveStateData&quot;); router.push(&#123; name: &quot;preview&quot;, params: &#123; fileType: row.filename.substring(row.filename.lastIndexOf(&quot;.&quot;) + 1), appendHandler: row.appendHandler, filename: row.filename, &#125;, &#125;);&#125;;&lt;/script&gt; 顺便一提，由于跳转页面之后，原页面的数据丢失，我还将原页面的数据放在了 store 中方便返回时回显。","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"打印功能","slug":"打印功能","date":"2024-03-13T08:27:23.000Z","updated":"2024-03-13T08:30:06.632Z","comments":true,"path":"2024/03/13/打印功能/","link":"","permalink":"https://congtf.top/2024/03/13/%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD/","excerpt":"","text":"一、安装1npm install vue-print-nb --save-dev 二、注册在 main.js 中引入并注册 12345import &#123; createApp &#125; from &quot;vue&quot;;import print from &quot;vue3-print-nb&quot;;import App from &quot;./App.vue&quot;;const app = createApp(App);app.use(print).mount(&quot;#app&quot;); 三、组件中使用定义一个 printObj 对象，注意局部打印必须在 printObj 对象上配置 id 属性，并将其绑定在需要打印的容器上。打印按钮通过 v-print&#x3D;”printObj”实现打印效果 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div id=&quot;myPrint&quot;&gt; &lt;!-- 流程信息详情 --&gt; &lt;el-table :data=&quot;wfData&quot; style=&quot;margin-top: 70px&quot;&gt; &lt;el-table-column type=&quot;index&quot; width=&quot;auto&quot; /&gt; &lt;el-table-column prop=&quot;node_name&quot; label=&quot;环节名称&quot; width=&quot;auto&quot; /&gt; &lt;el-table-column prop=&quot;proc_type&quot; label=&quot;环节类型&quot; width=&quot;auto&quot; /&gt; &lt;el-table-column prop=&quot;deal_state&quot; label=&quot;环节状态&quot; /&gt; &lt;el-table-column prop=&quot;username&quot; label=&quot;办理人&quot; /&gt; &lt;el-table-column prop=&quot;dept&quot; label=&quot;办理人部门&quot; /&gt; &lt;el-table-column prop=&quot;action_value&quot; label=&quot;办理意见&quot; /&gt; &lt;el-table-column prop=&quot;create_date&quot; label=&quot;创建时间&quot; /&gt; &lt;el-table-column prop=&quot;complete_date&quot; label=&quot;完成时间&quot; /&gt; &lt;el-table-column prop=&quot;deal_content&quot; label=&quot;审批意见&quot; /&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;el-row type=&quot;flex&quot; justify=&quot;center&quot; style=&quot;margin-top: 10px&quot;&gt; &lt;el-button v-print=&quot;printObj&quot; type=&quot;primary&quot;&gt;打印&lt;/el-button&gt; &lt;el-button @click=&quot;$router.back()&quot;&gt;返回&lt;/el-button&gt; &lt;/el-row&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref, onMounted, defineComponent &#125; from &quot;vue&quot;;import &#123; useRoute &#125; from &quot;vue-router&quot;;export default defineComponent(&#123; setup() &#123; const route = useRoute(); const wfData = ref(null); const printObj = ref(&#123; id: &quot;myPrint&quot;, &#125;); onMounted(() =&gt; &#123; wfData.value = JSON.parse(route.params.wfData); &#125;); return &#123; detailPage, applyIdValue, rowData, printObj, wfData &#125;; &#125;,&#125;);&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"路由复用时页面不刷新显示的解决办法","slug":"路由复用时页面不刷新显示的解决办法","date":"2024-03-13T08:27:08.000Z","updated":"2024-03-13T08:29:42.176Z","comments":true,"path":"2024/03/13/路由复用时页面不刷新显示的解决办法/","link":"","permalink":"https://congtf.top/2024/03/13/%E8%B7%AF%E7%94%B1%E5%A4%8D%E7%94%A8%E6%97%B6%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"今天在项目中新增了很多修改功能。需要复用之前的路由 这是路由文件，其中的每个路由地址对应着一个菜单栏 现在修改功能需要复用新发起的路由，在路由的 query 参数携带相应的参数，方便在修改页面中复显数据 但是如果我直接在声明周期函数里获取修改的数据会不生效。原因是当修改和新发起复用同一个路由时，vue 考虑到效率问题，并没有重新销毁再重建组件，它们使用的是同一个组件。这也导致了当我在别的页面点击修改想跳转到修改页面时，我在声明周期函数里写的获取修改数据的代码并不会生效，页面仍是一片空白。这个问题也在小兔鲜项目中遇到过。因此手动 watch 一下","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"文件导入导出功能","slug":"文件导入导出功能","date":"2024-03-13T08:26:04.000Z","updated":"2024-03-13T08:29:20.710Z","comments":true,"path":"2024/03/13/文件导入导出功能/","link":"","permalink":"https://congtf.top/2024/03/13/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD/","excerpt":"","text":"一、安装12npm install file-saver --savenpm install xlsx --save 二、创建工具函数为了使用方便，可以在 src&#x2F;utils 下封装一个工具文件 Export2Excel.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231/* eslint-disable */import &#123; saveAs &#125; from &quot;file-saver&quot;;import * as XLSX from &quot;xlsx&quot;;function generateArray(table) &#123; var out = []; var rows = table.querySelectorAll(&quot;tr&quot;); var ranges = []; for (var R = 0; R &lt; rows.length; ++R) &#123; var outRow = []; var row = rows[R]; var columns = row.querySelectorAll(&quot;td&quot;); for (var C = 0; C &lt; columns.length; ++C) &#123; var cell = columns[C]; var colspan = cell.getAttribute(&quot;colspan&quot;); var rowspan = cell.getAttribute(&quot;rowspan&quot;); var cellValue = cell.innerText; if (cellValue !== &quot;&quot; &amp;&amp; cellValue == +cellValue) cellValue = +cellValue; //Skip ranges ranges.forEach(function (range) &#123; if ( R &gt;= range.s.r &amp;&amp; R &lt;= range.e.r &amp;&amp; outRow.length &gt;= range.s.c &amp;&amp; outRow.length &lt;= range.e.c ) &#123; for (var i = 0; i &lt;= range.e.c - range.s.c; ++i) outRow.push(null); &#125; &#125;); //Handle Row Span if (rowspan || colspan) &#123; rowspan = rowspan || 1; colspan = colspan || 1; ranges.push(&#123; s: &#123; r: R, c: outRow.length, &#125;, e: &#123; r: R + rowspan - 1, c: outRow.length + colspan - 1, &#125;, &#125;); &#125; //Handle Value outRow.push(cellValue !== &quot;&quot; ? cellValue : null); //Handle Colspan if (colspan) for (var k = 0; k &lt; colspan - 1; ++k) outRow.push(null); &#125; out.push(outRow); &#125; return [out, ranges];&#125;function datenum(v, date1904) &#123; if (date1904) v += 1462; var epoch = Date.parse(v); return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);&#125;function sheet_from_array_of_arrays(data, opts) &#123; var ws = &#123;&#125;; var range = &#123; s: &#123; c: 10000000, r: 10000000, &#125;, e: &#123; c: 0, r: 0, &#125;, &#125;; for (var R = 0; R != data.length; ++R) &#123; for (var C = 0; C != data[R].length; ++C) &#123; if (range.s.r &gt; R) range.s.r = R; if (range.s.c &gt; C) range.s.c = C; if (range.e.r &lt; R) range.e.r = R; if (range.e.c &lt; C) range.e.c = C; var cell = &#123; v: data[R][C], &#125;; if (cell.v == null) continue; var cell_ref = XLSX.utils.encode_cell(&#123; c: C, r: R, &#125;); if (typeof cell.v === &quot;number&quot;) cell.t = &quot;n&quot;; else if (typeof cell.v === &quot;boolean&quot;) cell.t = &quot;b&quot;; else if (cell.v instanceof Date) &#123; cell.t = &quot;n&quot;; cell.z = XLSX.SSF._table[14]; cell.v = datenum(cell.v); &#125; else cell.t = &quot;s&quot;; ws[cell_ref] = cell; &#125; &#125; if (range.s.c &lt; 10000000) ws[&quot;!ref&quot;] = XLSX.utils.encode_range(range); return ws;&#125;function Workbook() &#123; if (!(this instanceof Workbook)) return new Workbook(); this.SheetNames = []; this.Sheets = &#123;&#125;;&#125;function s2ab(s) &#123; var buf = new ArrayBuffer(s.length); var view = new Uint8Array(buf); for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff; return buf;&#125;export function export_table_to_excel(id) &#123; var theTable = document.getElementById(id); var oo = generateArray(theTable); var ranges = oo[1]; /* original data */ var data = oo[0]; var ws_name = &quot;SheetJS&quot;; var wb = new Workbook(), ws = sheet_from_array_of_arrays(data); /* add ranges to worksheet */ // ws[&#x27;!cols&#x27;] = [&#x27;apple&#x27;, &#x27;banan&#x27;]; ws[&quot;!merges&quot;] = ranges; /* add worksheet to workbook */ wb.SheetNames.push(ws_name); wb.Sheets[ws_name] = ws; var wbout = XLSX.write(wb, &#123; bookType: &quot;xlsx&quot;, bookSST: false, type: &quot;binary&quot;, &#125;); saveAs( new Blob([s2ab(wbout)], &#123; type: &quot;application/octet-stream&quot;, &#125;), &quot;test.xlsx&quot; );&#125;export function export_json_to_excel(&#123; multiHeader = [], header, data, filename, merges = [], autoWidth = true, bookType = &quot;xlsx&quot;,&#125; = &#123;&#125;) &#123; /* original data */ filename = filename || &quot;excel-list&quot;; data = [...data]; data.unshift(header); for (let i = multiHeader.length - 1; i &gt; -1; i--) &#123; data.unshift(multiHeader[i]); &#125; var ws_name = &quot;SheetJS&quot;; var wb = new Workbook(), ws = sheet_from_array_of_arrays(data); if (merges.length &gt; 0) &#123; if (!ws[&quot;!merges&quot;]) ws[&quot;!merges&quot;] = []; merges.forEach((item) =&gt; &#123; ws[&quot;!merges&quot;].push(XLSX.utils.decode_range(item)); &#125;); &#125; if (autoWidth) &#123; /*设置worksheet每列的最大宽度*/ const colWidth = data.map((row) =&gt; row.map((val) =&gt; &#123; /*先判断是否为null/undefined*/ if (val == null) &#123; return &#123; wch: 10, &#125;; &#125; else if (val.toString().charCodeAt(0) &gt; 255) &#123; /*再判断是否为中文*/ return &#123; wch: val.toString().length * 2, &#125;; &#125; else &#123; return &#123; wch: val.toString().length, &#125;; &#125; &#125;) ); /*以第一行为初始值*/ let result = colWidth[0]; for (let i = 1; i &lt; colWidth.length; i++) &#123; for (let j = 0; j &lt; colWidth[i].length; j++) &#123; if (result[j][&quot;wch&quot;] &lt; colWidth[i][j][&quot;wch&quot;]) &#123; result[j][&quot;wch&quot;] = colWidth[i][j][&quot;wch&quot;]; &#125; &#125; &#125; ws[&quot;!cols&quot;] = result; &#125; /* add worksheet to workbook */ wb.SheetNames.push(ws_name); wb.Sheets[ws_name] = ws; var wbout = XLSX.write(wb, &#123; bookType: bookType, bookSST: false, type: &quot;binary&quot;, &#125;); saveAs( new Blob([s2ab(wbout)], &#123; type: &quot;application/octet-stream&quot;, &#125;), `$&#123;filename&#125;.$&#123;bookType&#125;` );&#125; 三、导出功能123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;exportTable&quot;&gt;导出&lt;/el-button&gt;&lt;/template&gt;&lt;script setup&gt;// 导出功能// 用户菜单表头与数据字段对应关系const userMenuHeader = &#123; 流程模板: &quot;wf_type_name&quot;, 审批编号: &quot;apply_id&quot;, 发起人: &quot;staff_name&quot;, 审批流程标题: &quot;apply_title&quot;, 审批金额: &quot;apply_fee&quot;, 发起时间: &quot;create_date&quot;, 流程状态: &quot;proc_state_name&quot;, 当前环节: &quot;node_name&quot;, 处理人: &quot;username&quot;,&#125;;const exportTable = () =&gt; &#123; // 做操作 const excelData = []; // 这里后端返回的数据不能直接用作excel的data，不然浏览器会卡死，必须先将数据转化为表格需要的[[]]的形式 tableData.value.forEach((item) =&gt; &#123; const arr = []; for (const key in userMenuHeader) &#123; arr.push(item[userMenuHeader[key]]); &#125; excelData.push(arr); &#125;); // 懒加载 try &#123; import(&quot;@/utils/Export2Excel&quot;).then(async (excel) =&gt; &#123; excel.export_json_to_excel(&#123; header: Object.keys(userMenuHeader), data: excelData, filename: &quot;费用冲调审批流程查询清单&quot;, autoWidth: true, bookType: &quot;xlsx&quot;, &#125;); &#125;); &#125; catch &#123; ElMessage.error(&quot;导出失败，请重试！&quot;); &#125;&#125;;&lt;/script&gt; 四、导入功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;template&gt; &lt;el-upload ref=&quot;uploadRef&quot; class=&quot;upload-demo&quot; v-model:file-list=&quot;accList&quot; :on-remove=&quot;handleRemove&quot; :on-change=&quot;handleChangeBusiness&quot; :http-request=&quot;upload&quot; action=&quot;#&quot; :auto-upload=&quot;false&quot; style=&quot;display: flex; margin-bottom: 10px&quot; &gt; &lt;template #trigger&gt; &lt;el-button type=&quot;primary&quot; :icon=&quot;Document&quot; style=&quot;margin-right: 150px&quot; &gt;选择文件&lt;/el-button &gt; &lt;/template&gt; &lt;template #tip v-if=&quot;!accList.length&quot;&gt; &lt;div class=&quot;el-upload__tip&quot; style=&quot;margin: 10px 0 0 -445px&quot;&gt; 未选择任何文件 &lt;/div&gt; &lt;/template&gt; &lt;el-button class=&quot;ml-3&quot; :icon=&quot;Upload&quot; type=&quot;success&quot; @click=&quot;getServByAccNbrImport&quot; style=&quot;margin-top: 2px&quot; &gt; 批量导入费用争议数据 &lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; :icon=&quot;Download&quot; &gt;&lt;el-link href=&quot;/approve/static/费用争议导入模板.xls&quot; &gt;下载附件模板&lt;/el-link &gt;&lt;/el-button &gt; &lt;/el-upload&gt;&lt;/template&gt;&lt;script setup&gt;// 批量上传// 上传的文件const accList = ref([]);const businessFileList = ref([]);const accountDetailList = ref([]); // 这是账期明细// 进出物品对应关系const businessRelation = &#123; 0: &quot;bz&quot;, 1: &quot;phone_number&quot;, 2: &quot;spje&quot;, 3: &quot;serv_id&quot;, 4: &quot;acct_id&quot;, 5: &quot;cust_name&quot;, 6: &quot;acct_name&quot;, 7: &quot;sqr&quot;, 8: &quot;sqrdh&quot;, 9: &quot;sqyy&quot;, 10: &quot;sqyy_name&quot;, 11: &quot;oper_type&quot;, 12: &quot;oper_type_name&quot;, 13: &quot;ctlx_id&quot;, 14: &quot;ctlx&quot;, 15: &quot;phone_local&quot;,&#125;;const accountDetailRelation = &#123; 0: &quot;phone_number&quot;, 1: &quot;fee_month&quot;, 2: &quot;charge&quot;, 3: &quot;fee_acct_type&quot;, 4: &quot;fee_acct_type_name&quot;,&#125;;const handleChangeBusiness = (file) =&gt; &#123; const reader = new FileReader(); reader.onload = async (e) =&gt; &#123; const data = e.target.result; const workbook = XLSX.read(data, &#123; type: &quot;array&quot; &#125;); const sheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[sheetName]; const json = XLSX.utils.sheet_to_json(worksheet, &#123; header: 1 &#125;); json.forEach((item) =&gt; &#123; const obj = &#123;&#125;; for (const key in businessRelation) &#123; obj[businessRelation[key]] = item[key]; &#125; businessFileList.value.push(obj); &#125;); // 对businessFileList去重 businessFileList.value = [...new Set(businessFileList.value)]; // 把这个数据传给后端，获取到后端返回的数据，渲染列表 // 因为表格中可能会有空白的数据，上传上来的数据就会有undefined，所以要过滤掉 businessFileList.value = businessFileList.value.filter((item) =&gt; item); // 因为批量上传的没有acc_nbr，所以要把phone_number赋值给acc_nbr businessFileList.value.forEach((item) =&gt; &#123; item.acc_nbr = item.phone_number; &#125;); const sheetName1 = workbook.SheetNames[1]; const worksheet1 = workbook.Sheets[sheetName1]; const json1 = XLSX.utils.sheet_to_json(worksheet1, &#123; header: 1 &#125;); json1.forEach((item) =&gt; &#123; const obj = &#123;&#125;; for (const key in accountDetailRelation) &#123; obj[accountDetailRelation[key]] = item[key]; &#125; accountDetailList.value.push(obj); &#125;); // 对accountDetailList去重 accountDetailList.value = [...new Set(accountDetailList.value)]; accountDetailList.value = accountDetailList.value.filter((item) =&gt; item); // 将accountDetailList与businessFileList关联 businessFileList.value.forEach((item) =&gt; &#123; item.fee_list_month = accountDetailList.value.filter((item2) =&gt; &#123; return item.phone_number === item2.phone_number; &#125;); &#125;); &#125;; reader.readAsArrayBuffer(file.raw);&#125;;const getServByAccNbrImport = async () =&gt; &#123; if (businessFileList.value.length === 0) &#123; ElMessage.error(&quot;请先选择文件&quot;); return; &#125; if (businessFileList.value.length &gt; 2000) &#123; ElMessage.error( &quot;上传的数据超过2000条，可能会导致查询时间过长，请分批次上传！&quot; ); return; &#125; applyForm.feeListData = businessFileList.value;&#125;;&lt;/script&gt; 最终的效果是这样的：可以看到，每一行数据下面关联了一个子表","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"一个简单的后台管理类项目","slug":"一个简单的后台管理类项目","date":"2023-09-12T09:18:21.000Z","updated":"2024-03-12T08:26:34.492Z","comments":true,"path":"2023/09/12/一个简单的后台管理类项目/","link":"","permalink":"https://congtf.top/2023/09/12/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B1%BB%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"一、项目概述这是一个专门用于运营商后台发起靓号审批申请的项目。技术选型：vue3+elementplus+vite+vue-router+pinia. 用到的插件主要有： axios 请求后台数据 crypto-js 加解密 dayjs 日期处理 nanoid 生成 id vue3-print-nb 打印文件插件 xlsx 处理 excel 文件 pinia-plugin-persistedstate 配合 pinia 实现数据持久化 二、工具文件夹1.crypto-js 加解密因为在实际上线后，本项目主要是从另外一个项目跳转登录，在跳转时携带了用户身份标识的参数。而这个参数不能使用明文传递，因此使用 crypto-js 进行了加密，在跳转到本项目后使用 crypto-js 将加密的参数解密处理进行用户身份认证，继而实现登录。在 src&#x2F;utils 下新建 encipher.js 文件。 123456789101112131415import CryptoJS from &quot;crypto-js&quot;;// 加密export function encrypt(message = &quot;&quot;, key = &quot;&quot;) &#123; const srcs = CryptoJS.enc.Utf8.parse(message); const encrypted = CryptoJS.AES.encrypt(srcs, key); return encrypted.toString();&#125;// 解密export function decrypt(encrypted = &quot;&quot;, key = &quot;&quot;) &#123; const decrypt = CryptoJS.AES.decrypt(encrypted, key); const decrypted = CryptoJS.enc.Utf8.stringify(decrypt).toString(); return decrypted;&#125; 2.request.js 封装 axios在 src&#x2F;utils 下新建 encipher.js 文件。 因为项目的网络请求调用了多个地方的接口，可以看到我这里封装了多个 request 实例 12345678910111213141516171819202122232425262728293031323334353637383940/** * 封装 axios 请求模块 */import axios from &quot;axios&quot;;import &#123; useUserInfoStore &#125; from &quot;@/store/useUserInfoStore&quot;;import &#123; toRefs &#125; from &quot;vue&quot;;export const request = axios.create(&#123; baseURL: &quot;http://133.0.109.121:31455&quot;, // 上云data地址 // baseURL: &#x27;http://192.168.137.63:8081&#x27;, // 后端测试地址 // baseURL: &#x27;http://localhost:8081&#x27;, // 本机测试 timeout: 5000, // 单位毫秒&#125;);export const requestExpress = axios.create(&#123; baseURL: &quot;http://133.0.109.121:31456&quot;, // 上云express地址 timeout: 5000, // 单位毫秒&#125;);export const requestCRM = axios.create(&#123; baseURL: &quot;http://133.0.109.121:31896&quot;, // CRM地址 // baseURL: &#x27;http://localhost:8085&#x27;, timeout: 5000, // 单位毫秒&#125;);// 请求拦截器，统一注入tokenrequest.interceptors.request.use((config) =&gt; &#123; const &#123; userInfo &#125; = toRefs(useUserInfoStore()); if (userInfo.value.staffCode) &#123; config.headers.Authorization = userInfo.value.staffCode; &#125; // 在最后必须 return config return config;&#125;);// 响应拦截器，剥离一层data数据request.interceptors.response.use((res) =&gt; &#123; //统一解决后端返回的错误信息 if (res.data.code !== 200) &#123; return Promise.reject(res.data.message); &#125; return res.data;&#125;); 三、路由配置在 src&#x2F;router 下新建 index.js 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;;import &#123; useUserInfoStore &#125; from &quot;@/store/useUserInfoStore&quot;;import Home from &quot;../views/home.vue&quot;;import &#123; toRefs &#125; from &quot;vue&quot;;import &#123; loginAPI &#125; from &quot;@/api/login&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;import &#123; decrypt &#125; from &quot;@/utils/encipher&quot;;const routes = [ &#123; path: &quot;/&quot;, name: &quot;Home&quot;, component: Home, redirect: &quot;/NumberApplication&quot;, children: [ // &#123; // path: &#x27;&#x27;, // name: &#x27;dashboard&#x27;, // hidden: true, // meta: &#123; // title: &#x27;系统首页&#x27;, // permiss: &#x27;1&#x27; // &#125;, // component: () =&gt; // import(/* webpackChunkName: &quot;dashboard&quot; */ &#x27;../views/dashboard.vue&#x27;) // &#125;, //靓号申请（发起申请页） &#123; path: &quot;NumberApplication&quot;, name: &quot;NumberApplication&quot;, meta: &#123; title: &quot;靓号申请&quot;, permiss: &quot;2&quot;, &#125;, component: () =&gt; import(&quot;@/views/NumberApplication/index.vue&quot;), &#125;, //靓号申请(填写表单页) &#123; path: &quot;NumberApplication2&quot;, name: &quot;NumberApplication2&quot;, meta: &#123; title: &quot;填写申请表单&quot;, permiss: &quot;3&quot;, &#125;, component: () =&gt; import(&quot;@/views/NumberApplication2/index.vue&quot;), &#125;, //靓号申请3(指定号码) &#123; path: &quot;NumberApplication3&quot;, name: &quot;NumberApplication3&quot;, meta: &#123; title: &quot;查询指定号码&quot;, permiss: &quot;4&quot;, &#125;, component: () =&gt; import(&quot;@/views/NumberApplication3/index.vue&quot;), &#125;, //靓号申请4（不指定号码） &#123; path: &quot;NumberApplication4&quot;, name: &quot;NumberApplication4&quot;, meta: &#123; title: &quot;不指定号码查询&quot;, permiss: &quot;5&quot;, &#125;, component: () =&gt; import(&quot;@/views/NumberApplication4/index.vue&quot;), &#125;, //虚拟成本管理 &#123; path: &quot;VirtualCost&quot;, name: &quot;VirtualCost&quot;, meta: &#123; title: &quot;虚拟成本管理&quot;, permiss: &quot;999&quot;, &#125;, component: () =&gt; import(&quot;@/views/VirtualCost.vue&quot;), &#125;, //用户权限管理 &#123; path: &quot;UserAccessConfig&quot;, name: &quot;UserAccessConfig&quot;, meta: &#123; title: &quot;用户访问权限管理&quot;, permiss: &quot;999&quot;, &#125;, component: () =&gt; import(&quot;@/views/UserAccessConfig.vue&quot;), &#125;, //客户类型管理 &#123; path: &quot;CustomerTypeConfig&quot;, name: &quot;CustomerTypeConfig&quot;, meta: &#123; title: &quot;客户类型管理&quot;, permiss: &quot;999&quot;, &#125;, component: () =&gt; import(&quot;@/views/CustomerTypeConfig.vue&quot;), &#125;, //补充号码等级 &#123; path: &quot;AddNumberLevel&quot;, name: &quot;AddNumberLevel&quot;, meta: &#123; title: &quot;补充号码等级&quot;, permiss: &quot;999&quot;, &#125;, component: () =&gt; import(&quot;@/views/AddNumberLevel.vue&quot;), &#125;, ], &#125;, &#123; path: &quot;/login&quot;, name: &quot;Login&quot;, meta: &#123; title: &quot;登录&quot;, &#125;, component: () =&gt; import(/* webpackChunkName: &quot;login&quot; */ &quot;../views/login.vue&quot;), &#125;, &#123; path: &quot;/403&quot;, name: &quot;403&quot;, meta: &#123; title: &quot;没有权限&quot;, &#125;, component: () =&gt; import(/* webpackChunkName: &quot;403&quot; */ &quot;../views/403.vue&quot;), &#125;, &#123; path: &quot;/:pathMatch(.*)&quot;, name: &quot;404&quot;, meta: &#123; title: &quot;页面不存在&quot;, &#125;, component: () =&gt; import(&quot;@/views/404.vue&quot;), &#125;,];const router = createRouter(&#123; history: createWebHashHistory(), routes, // scrollBehavior: () =&gt; (&#123; top: 0 &#125;) 这里配置滚动条位置并不能生效，因为scrollBehavior配置的只对滚动容器是HTML，也就是整个页面才生效。而该项目的滚动容器并不是整个页面，而是home组件中的一个dom！！！&#125;);router.beforeEach(async (to, from, next) =&gt; &#123; document.title = `$&#123;to.meta.title&#125; | 湖北电信靓号管理系统`; const &#123; userInfo, getUserInfo, keys &#125; = toRefs(useUserInfoStore()); const staffCode = decrypt(to.query.staffCode); if (staffCode) &#123; try &#123; const &#123; data &#125; = await loginAPI(&#123; password: &quot;111111&quot;, staff_code: staffCode, &#125;); getUserInfo.value(&#123; staff_code: data.staffCode &#125;); next(&quot;/&quot;); &#125; catch &#123; ElMessage.error(&quot;登录失败&quot;); &#125; &#125; if (!userInfo.value.staffCode &amp;&amp; to.path !== &quot;/login&quot;) &#123; next(&quot;/login&quot;); &#125; else if ( to.meta.permiss &amp;&amp; keys.value &amp;&amp; !keys.value.includes(to.meta.permiss) ) &#123; // 如果没有权限，则进入403 next(&quot;/403&quot;); &#125; else &#123; next(); &#125;&#125;);export default router; 这里值得注意的点有： 1.页面滚动条在路由这里我想通过 scrollBehavior 来控制页面的滚动行为，以达到无论上一个页面滚动条是否在顶部，在切换页面（路由）后，页面始终置顶的效果。 正如我在代码注释中所写，如果我将 scrollBehavior 配置在路由中，那么它针对的将是整个页面即 app.vue（包含 header、菜单栏 sider-bar、以及主体显示部分 home），这样配置的话只有在一级路由切换时滚动条才会生效。而我想要的是只在 home 页切换时生效即可。 因此，在 home.vue 中配合路由后置守卫实现滚动条置顶效果 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;v-header /&gt; &lt;v-sidebar /&gt; &lt;div class=&quot;content-box&quot; :class=&quot;&#123; &#x27;content-collapse&#x27;: sidebar.collapse &#125;&quot;&gt; &lt;v-tags&gt;&lt;/v-tags&gt; &lt;!-- 这个才是真正的滚动容器，需要在这里配合路由守卫去控制滚动条的位置！！！ --&gt; &lt;div class=&quot;content&quot; ref=&quot;scrollContainer&quot;&gt; &lt;router-view v-slot=&quot;&#123; Component &#125;&quot; :key=&quot;key&quot;&gt; &lt;transition name=&quot;move&quot; mode=&quot;out-in&quot;&gt; &lt;!-- &lt;keep-alive :include=&quot;tags.nameList&quot;&gt; --&gt; &lt;component :is=&quot;Component&quot; :key=&quot;route.fullPath&quot;&gt;&lt;/component&gt; &lt;!-- &lt;/keep-alive&gt; --&gt; &lt;/transition&gt; &lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useSidebarStore &#125; from &#x27;../store/sidebar&#x27;// import &#123; useTagsStore &#125; from &#x27;../store/tags&#x27;import vHeader from &#x27;../components/header.vue&#x27;import vSidebar from &#x27;../components/sidebar.vue&#x27;import vTags from &#x27;../components/tags.vue&#x27;import &#123; ref, computed &#125; from &#x27;vue&#x27;import router from &#x27;@/router/index.js&#x27;import &#123; useRoute &#125; from &#x27;vue-router&#x27;const sidebar = useSidebarStore()// const tags = useTagsStore()const scrollContainer = ref()// 控制滚动条的位置router.afterEach((to, from) =&gt; &#123; scrollContainer.value.scrollTop = 0&#125;)const route = useRoute()const key = computed(() =&gt; &#123; return route.path + Math.random()&#125;)&lt;/script&gt; 2.路由前置守卫拦截逻辑这里的拦截逻辑是： 如果是从另一个项目携带用户名跳转而来，则使用该用户名和默认密码’111111’进行登录，登录成功，获取用户信息存储到 store 中。从而实现跨一个平台免登录的效果。 如果 store 中没有存储用户信息，说明用户未登录 每个页面具有对应的权限等级标识，通过 meta 中的 permiss 标识。在 store 中简单的将用户角色分为了管理员和普通用户两种（当然也可以根据需求进行多样化的调整），通过 store 中存储的用户信息判断该用户是普通用户还是管理员。这样就可以在路由中判断用户是否具有要去的页面的权限了。 由此引出 store 中的 useUserInfo.js 四、store 中存放用户信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; ref, computed &#125; from &quot;vue&quot;;import &#123; getUserInfoAPI &#125; from &quot;@/api/login.js&quot;;import &#123; getRegion &#125; from &quot;@/api/NumberApplication.js&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;import router from &quot;@/router/index.js&quot;;import &#123; verifyPageAccessAPI &#125; from &quot;@/api/login.js&quot;;export const useUserInfoStore = defineStore( &quot;userInfo&quot;, () =&gt; &#123; const userInfo = ref(&#123;&#125;); // 获取用户信息 const getUserInfo = async (value) =&gt; &#123; const userRegionInfo = &#123; new_region_id: &quot;&quot;, region_id: &quot;&quot;, region_name: &quot;&quot;, &#125;; const &#123; data &#125; = await getUserInfoAPI(value); const result = await getRegion(&#123; staff_code: value.staff_code &#125;); // 如果工号以hb开头，先用部门去匹配，如果匹配不到，则region_id为1000 if (value.staff_code.startsWith(&quot;HB&quot;)) &#123; const temp = result.data.find((item) =&gt; &#123; return item.region_name === data[0].dept; &#125;); if (!temp) &#123; userRegionInfo.region_id = 1000; userRegionInfo.new_region_id = 0; userRegionInfo.region_name = &quot;其他&quot;; &#125; else &#123; userRegionInfo.new_region_id = temp.new_region_id ? temp.new_region_id : 0; userRegionInfo.region_id = temp.region_id; userRegionInfo.region_name = temp.region_name; &#125; &#125; else &#123; userRegionInfo.new_region_id = result.data[0].new_region_id; userRegionInfo.region_name = result.data[0].region_name; userRegionInfo.region_id = result.data[0].region_id; &#125; //userAccessList就是用户所拥有的权限列表 const userAccessList = await verifyPageAccessAPI(&#123; staff_code: value.staff_code, &#125;); // 目前的逻辑是如果该用户同时拥有菜单配置menu_id为3031和审批人配置menu_id为3032的权限，那么他就是管理员 const hasAccess1 = userAccessList.data.some( (item) =&gt; item.menu_id === &quot;3031&quot; ); const hasAccess2 = userAccessList.data.some( (item) =&gt; item.menu_id === &quot;3032&quot; ); const isAdmin = hasAccess1 &amp;&amp; hasAccess2; userInfo.value = &#123; ...data[0], staffCode: value.staff_code, ...userRegionInfo, isAdmin, &#125;; ElMessage.success(&quot;登录成功&quot;); router.replace(&quot;/&quot;); &#125;; // 更改用户信息 const setUserInfo = (value) =&gt; &#123; userInfo.value = value; &#125;; // 清除用户信息 const clearUserInfo = () =&gt; &#123; userInfo.value = &#123;&#125;; &#125;; const defaultList = ref(&#123; admin: [ &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;999&quot;, //这是虚拟成本的权限标识 ], user: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;], &#125;); //在此表中的人员都是管理员 console.log(userInfo.value.isAdmin, &quot;111&quot;); const keys = computed( () =&gt; defaultList.value[userInfo.value.isAdmin ? &quot;admin&quot; : &quot;user&quot;] ); console.log(keys); const handleSet = (val) =&gt; &#123; keys.value = val; &#125;; return &#123; userInfo, getUserInfo, setUserInfo, clearUserInfo, keys, defaultList, handleSet, &#125;; &#125;, &#123; // persist:true persist: &#123; storage: sessionStorage, //localStorage &#125;, &#125;); 可以看到这里定义了获取用户信息、清除用户信息的方法。可以在登录和退出登录时调用。其中的用户信息可以在项目需要的时候随时随地方便获取，同时还定义了修改用户信息的方法，不过它一般应该只用来将一些信息添加到用户信息身上。 本项目目前只有管理员和普通用户两种角色，他们被定义在 defaultList 中的 admin 和 user 中，通过用户信息的简单判断来对应 defaultList 中的 admin 和 user。再结合路由守卫，这样他们就分别有了管理员和普通用户的页面权限。当然这里的角色定义和角色判断可以结合后端灵活实现和扩展。 由于使用了 pinia-plugin-persistedstate 插件，可以直接通过 persist 配置选项中的 storage 将数据持久化.注意如果直接给 true 默认使用的是 localStorage。 五、自定义指令和组件自定义指令放在 src&#x2F;directives&#x2F;index.js 123456789101112131415import &#123; useUserInfoStore &#125; from &quot;@/store/useUserInfoStore.js&quot;;import &#123; toRefs &#125; from &quot;vue&quot;;// 自定义权限指令export const permissDirective = &#123; install(app) &#123; const &#123; keys &#125; = toRefs(useUserInfoStore()); app.directive(&quot;permiss&quot;, &#123; mounted(el, binding) &#123; if (keys.value &amp;&amp; !keys.value.includes(String(binding.value))) &#123; el[&quot;hidden&quot;] = true; &#125; &#125;, &#125;); &#125;,&#125;; 自定义组件放在 src&#x2F;components 中，并最终通过 index.js 进行统一导出 123456789101112import TaskDeal from &quot;./TaskDeal.vue&quot;;import TaskDetail from &quot;./TaskDetail.vue&quot;;import TaskDetailDid from &quot;./TaskDetailDid.vue&quot;;import TaskDealNew from &quot;./TaskDealNew.vue&quot;;export default &#123; install(app) &#123; app.component(&quot;TaskDeal&quot;, TaskDeal); app.component(&quot;TaskDetail&quot;, TaskDetail); app.component(&quot;TaskDetailDid&quot;, TaskDetailDid); app.component(&quot;TaskDealNew&quot;, TaskDealNew); &#125;,&#125;; 最后别忘了在 main.js 中注册使用 12345678910111213141516171819202122232425262728import &#123; createApp &#125; from &quot;vue&quot;;import &#123; createPinia &#125; from &quot;pinia&quot;;import * as ElementPlusIconsVue from &quot;@element-plus/icons-vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router/index.js&quot;;import &quot;element-plus/dist/index.css&quot;;import &quot;./assets/css/icon.css&quot;;// 引入pinia数据持久化插件import piniaPluginPersistedstate from &quot;pinia-plugin-persistedstate&quot;;import &#123; permissDirective &#125; from &quot;@/directives/index.js&quot;;import Components from &quot;@/components/index.js&quot;;import axios from &quot;axios&quot;;import print from &quot;vue3-print-nb&quot;;const app = createApp(App);const pinia = createPinia();app.use(pinia);pinia.use(piniaPluginPersistedstate);app.use(router);app.use(permissDirective);// 注册elementplus图标for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123; app.component(key, component);&#125;app.config.globalProperties.$http = axios;app.use(Components).use(print);app.mount(&quot;#app&quot;); 六、用户信息脱敏处理​ 对于像客户的电话号码、姓名、身份证号这些敏感数据，需要进行脱敏后再显示，为此可在 src&#x2F;utils 下新建 sensitiveDataHandle.js 进行数据脱敏处理 12345678910111213141516171819// 信息脱敏处理// beginLen:开始脱敏的字符下标; endLen:结束脱敏的字符下标; str:需要脱敏的字符串; max:掩码最大的重复数量，若不传，则默认为20export function getStr(beginLen, endLen, str, max = 20) &#123; // substr(begin,length),begin:需要截取的字符串的下标,必须是数值，若为负数,则从字符串最后一位向左数; // length:需要截取的字符串长度,若不写此参数,则返回从开始位置到结束的所有字符 const firstStr = str.substr(0, beginLen); // 结束脱敏的字符下标是否为0，为0则返回空，不为0则返回截取的字符 const lastStr = endLen == 0 ? &quot;&quot; : str.substr(endLen); // Math.max(x,y,z,...,n),返回x,y,z,...,n中的最大值 // Math.abs(x),返回x的绝对值 // Math.min(x,y,z,...,n),返回x,y,z,...,n中的最小值 // 开始脱敏的下标 加上 结束脱敏的下标是否小于字符串总长度 let repeatNum = Math.max(0, str.length - (beginLen + Math.abs(endLen))); // 若传了最大掩码重复数，则取数值小的那个 repeatNum = Math.min(max, repeatNum); // 字符串复制指定次数，语法: string.repeat(count), count:设置需要重复的次数 const middleStr = &quot;*&quot;.repeat(repeatNum); // 掩码要重复的数量 return firstStr + middleStr + lastStr;&#125; 七、客户类别互斥多选原先客户类别选择框只是简单的多选，比如我可以在所有的选项中随意的选取几项。但是其实选项里面是有分组和互斥关系的，比如市州政府、事业单位客户和省级政府、事业单位客户和省级政府、事业单位关键人这三个应该是一组的，只能从这组中选择一个。基于此又提出了更高的需求：要求选项之间分组，选择时互斥的多选 我将客户类型数据定义在了 src&#x2F;constant&#x2F;customerType.js 的常量中，用的时候直接引入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183//四级手机靓号客户类型// export const customerTypeLvl4 = [// &#123; label: &#x27;市州政府、事业单位客户&#x27;, value: &#x27;市州政府、事业单位客户&#x27; &#125;,// &#123; label: &#x27;县市级别关键人&#x27;, value: &#x27;县市级别关键人&#x27; &#125;,// &#123; label: &#x27;政企团购80户以上关键人&#x27;, value: &#x27;政企团购80户以上关键人&#x27; &#125;,// &#123; label: &#x27;年收入超过30万客户&#x27;, value: &#x27;年收入超过30万客户&#x27; &#125;,// &#123; label: &#x27;产数项目超100万客户&#x27;, value: &#x27;产数项目超100万客户&#x27; &#125;,// &#123; label: &#x27;省级政府、事业单位客户&#x27;, value: &#x27;省级政府、事业单位客户&#x27; &#125;,// &#123; label: &#x27;市州级别关键人&#x27;, value: &#x27;市州级别关键人&#x27; &#125;,// &#123; label: &#x27;政企团购150户以上关键人&#x27;, value: &#x27;政企团购150户以上关键人&#x27; &#125;,// &#123; label: &#x27;年收入超过100万客户&#x27;, value: &#x27;年收入超过100万客户&#x27; &#125;,// &#123; label: &#x27;产数项目超300万客户&#x27;, value: &#x27;产数项目超300万客户&#x27; &#125;,// &#123; label: &#x27;省级政府、事业单位关键人&#x27;, value: &#x27;省级政府、事业单位关键人&#x27; &#125;,// &#123; label: &#x27;重点大型企业集团客户关键人&#x27;, value: &#x27;重点大型企业集团客户关键人&#x27; &#125;,// &#123; label: &#x27;政企团购300户以上关键人&#x27;, value: &#x27;政企团购300户以上关键人&#x27; &#125;,// &#123; label: &#x27;年收入超过200万客户&#x27;, value: &#x27;年收入超过200万客户&#x27; &#125;,// &#123; label: &#x27;产数项目超500万客户&#x27;, value: &#x27;产数项目超500万客户&#x27; &#125;// ]// //五级手机靓号客户类型// export const customerTypeLvl5 = [// &#123; label: &#x27;省级政府、事业单位客户&#x27;, value: &#x27;省级政府、事业单位客户&#x27; &#125;,// &#123; label: &#x27;市州级别关键人&#x27;, value: &#x27;市州级别关键人&#x27; &#125;,// &#123; label: &#x27;政企团购150户以上关键人&#x27;, value: &#x27;政企团购150户以上关键人&#x27; &#125;,// &#123; label: &#x27;年收入超过100万客户&#x27;, value: &#x27;年收入超过100万客户&#x27; &#125;,// &#123; label: &#x27;产数项目超300万客户&#x27;, value: &#x27;产数项目超300万客户&#x27; &#125;,// &#123; label: &#x27;省级政府、事业单位关键人&#x27;, value: &#x27;省级政府、事业单位关键人&#x27; &#125;,// &#123; label: &#x27;重点大型企业集团客户关键人&#x27;, value: &#x27;重点大型企业集团客户关键人&#x27; &#125;,// &#123; label: &#x27;政企团购300户以上关键人&#x27;, value: &#x27;政企团购300户以上关键人&#x27; &#125;,// &#123; label: &#x27;年收入超过200万客户&#x27;, value: &#x27;年收入超过200万客户&#x27; &#125;,// &#123; label: &#x27;产数项目超500万客户&#x27;, value: &#x27;产数项目超500万客户&#x27; &#125;// ]// //六级手机靓号客户类型// export const customerTypeLvl6 = [// &#123; label: &#x27;省级政府、事业单位关键人&#x27;, value: &#x27;省级政府、事业单位关键人&#x27; &#125;,// &#123; label: &#x27;重点大型企业集团客户关键人&#x27;, value: &#x27;重点大型企业集团客户关键人&#x27; &#125;,// &#123; label: &#x27;政企团购300户以上关键人&#x27;, value: &#x27;政企团购300户以上关键人&#x27; &#125;,// &#123; label: &#x27;年收入超过200万客户&#x27;, value: &#x27;年收入超过200万客户&#x27; &#125;,// &#123; label: &#x27;产数项目超500万客户&#x27;, value: &#x27;产数项目超500万客户&#x27; &#125;// ]export const customerTypeLvl4 = [ &#123; label: &quot;1&quot;, options: [ &#123; label: &quot;市州政府、事业单位客户&quot;, value: &quot;市州政府、事业单位客户&quot;, state: false, &#125;, &#123; label: &quot;省级政府、事业单位客户&quot;, value: &quot;省级政府、事业单位客户&quot;, state: false, &#125;, &#123; label: &quot;省级政府、事业单位关键人&quot;, value: &quot;省级政府、事业单位关键人&quot;, state: false, &#125;, ], &#125;, &#123; label: &quot;2&quot;, options: [ &#123; label: &quot;县市级别关键人&quot;, value: &quot;县市级别关键人&quot;, state: false &#125;, &#123; label: &quot;市州级别关键人&quot;, value: &quot;市州级别关键人&quot;, state: false &#125;, &#123; label: &quot;重点大型企业集团客户关键人&quot;, value: &quot;重点大型企业集团客户关键人&quot;, state: false, &#125;, ], &#125;, &#123; label: &quot;3&quot;, options: [ &#123; label: &quot;政企团购80户以上关键人&quot;, value: &quot;政企团购80户以上关键人&quot;, state: false, &#125;, &#123; label: &quot;政企团购150户以上关键人&quot;, value: &quot;政企团购150户以上关键人&quot;, state: false, &#125;, &#123; label: &quot;政企团购300户以上关键人&quot;, value: &quot;政企团购300户以上关键人&quot;, state: false, &#125;, ], &#125;, &#123; label: &quot;4&quot;, options: [ &#123; label: &quot;年收入超过30万客户&quot;, value: &quot;年收入超过30万客户&quot;, state: false, &#125;, &#123; label: &quot;年收入超过100万客户&quot;, value: &quot;年收入超过100万客户&quot;, state: false, &#125;, &#123; label: &quot;年收入超过200万客户&quot;, value: &quot;年收入超过200万客户&quot;, state: false, &#125;, ], &#125;, &#123; label: &quot;5&quot;, options: [ &#123; label: &quot;产数项目超100万客户&quot;, value: &quot;产数项目超100万客户&quot;, state: false, &#125;, &#123; label: &quot;产数项目超300万客户&quot;, value: &quot;产数项目超300万客户&quot;, state: false, &#125;, &#123; label: &quot;产数项目超500万客户&quot;, value: &quot;产数项目超500万客户&quot;, state: false, &#125;, ], &#125;,];//五级手机靓号客户类型export const customerTypeLvl5 = [ &#123; label: &quot;1&quot;, options: [ &#123; label: &quot;省级政府、事业单位客户&quot;, value: &quot;省级政府、事业单位客户&quot; &#125;, &#123; label: &quot;省级政府、事业单位关键人&quot;, value: &quot;省级政府、事业单位关键人&quot; &#125;, ], &#125;, &#123; label: &quot;2&quot;, options: [ &#123; label: &quot;市州级别关键人&quot;, value: &quot;市州级别关键人&quot; &#125;, &#123; label: &quot;重点大型企业集团客户关键人&quot;, value: &quot;重点大型企业集团客户关键人&quot;, &#125;, ], &#125;, &#123; label: &quot;3&quot;, options: [ &#123; label: &quot;政企团购150户以上关键人&quot;, value: &quot;政企团购150户以上关键人&quot; &#125;, &#123; label: &quot;政企团购300户以上关键人&quot;, value: &quot;政企团购300户以上关键人&quot; &#125;, ], &#125;, &#123; label: &quot;4&quot;, options: [ &#123; label: &quot;年收入超过100万客户&quot;, value: &quot;年收入超过100万客户&quot; &#125;, &#123; label: &quot;年收入超过200万客户&quot;, value: &quot;年收入超过200万客户&quot; &#125;, ], &#125;, &#123; label: &quot;5&quot;, options: [ &#123; label: &quot;产数项目超300万客户&quot;, value: &quot;产数项目超300万客户&quot; &#125;, &#123; label: &quot;产数项目超500万客户&quot;, value: &quot;产数项目超500万客户&quot; &#125;, ], &#125;,];//六级手机靓号客户类型export const customerTypeLvl6 = [ &#123; label: &quot;省级政府、事业单位关键人&quot;, value: &quot;省级政府、事业单位关键人&quot; &#125;, &#123; label: &quot;重点大型企业集团客户关键人&quot;, value: &quot;重点大型企业集团客户关键人&quot; &#125;, &#123; label: &quot;政企团购300户以上关键人&quot;, value: &quot;政企团购300户以上关键人&quot; &#125;, &#123; label: &quot;年收入超过200万客户&quot;, value: &quot;年收入超过200万客户&quot; &#125;, &#123; label: &quot;产数项目超500万客户&quot;, value: &quot;产数项目超500万客户&quot; &#125;,]; 在具体的业务代码中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;template&gt; &lt;!-- 只在手机靓号四级、五级、六级时显示 --&gt; &lt;el-form-item label=&quot;客户类型&quot; prop=&quot;customerType&quot; v-if=&quot; selectFormData.level_name === &#x27;四级手机靓号&#x27; || selectFormData.level_name === &#x27;五级手机靓号&#x27; || selectFormData.level_name === &#x27;六级手机靓号&#x27; &quot; &gt; &lt;el-select style=&quot;width: 250px&quot; v-model=&quot;selectFormData.customerType&quot; placeholder=&quot;请选择&quot; multiple collapse-tags collapse-tags-tooltip @change=&quot;selectChange&quot; &gt; &lt;template v-if=&quot;selectFormData.level_name === &#x27;六级手机靓号&#x27;&quot;&gt; &lt;el-option v-for=&quot;item in customerTypeList&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot; &gt;&lt;/el-option&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;el-option-group v-for=&quot;group in customerTypeList&quot; :key=&quot;group.label&quot; :label=&quot;group.label&quot; &gt; &lt;el-option v-for=&quot;item in group.options&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot; :disabled=&quot;item.state&quot; /&gt; &lt;/el-option-group&gt; &lt;/template&gt; &lt;/el-select&gt; &lt;/el-form-item&gt;&lt;/template&gt;&lt;script setup&gt;const customerTypeList = ref([])watchEffect(() =&gt; &#123; if (selectFormData.value.level_name === &#x27;四级手机靓号&#x27;) &#123; customerTypeList.value = customerTypeLvl4 &#125; else if (selectFormData.value.level_name === &#x27;五级手机靓号&#x27;) &#123; customerTypeList.value = customerTypeLvl5 &#125; else if (selectFormData.value.level_name === &#x27;六级手机靓号&#x27;) &#123; customerTypeList.value = customerTypeLvl6 &#125; else &#123; customerTypeList.value = [] &#125; const selectChange = (val) =&gt; &#123; if (val.length === 0) &#123; customerTypeList.value.forEach((item) =&gt; item.options.forEach((ele) =&gt; (ele.state = false)) ) &#125; const tempList = ref([]) customerTypeList.value.forEach((item) =&gt; &#123; const tempArr = item.options.find((ele) =&gt; &#123; return ele.label === val[val.length - 1] &#125;) if (tempArr) &#123; tempList.value = item.options &#125; &#125;) tempList.value.forEach((item) =&gt; &#123; if (item.label !== val[val.length - 1]) &#123; item.state = true &#125; &#125;)&#125;&lt;/script&gt; 这里我为了实现组内互斥效果，在选项上加了一个 state 字段控制选项的可选状态。当本组内已经有选项被选择时，则将该组内其他选项的可选状态禁用。同时不影响其他组的可选状态。具体逻辑在 selectChange 函数中实现。 八、文件上传下载功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;template&gt; &lt;!-- 上传附件区域 --&gt; &lt;div class=&quot;container&quot; style=&quot;margin-bottom: 10px&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;span&gt;上传附件&lt;/span&gt; &lt;/div&gt; &lt;el-upload v-model:file-list=&quot;fileList&quot; ref=&quot;uploadRef&quot; class=&quot;upload-demo&quot; :on-remove=&quot;handleRemove&quot; :on-change=&quot;changeFile&quot; :http-request=&quot;upload&quot; action=&quot;#&quot; :auto-upload=&quot;false&quot; multiple style=&quot;display: flex; margin-bottom: 10px&quot; &gt; &lt;template #trigger&gt; &lt;el-button type=&quot;primary&quot; :icon=&quot;Document&quot; style=&quot;margin-right: 150px&quot; &gt;选择文件&lt;/el-button &gt; &lt;/template&gt; &lt;template #tip v-if=&quot;!tempList.length&quot;&gt; &lt;div class=&quot;el-upload__tip&quot; style=&quot;margin: 10px 0 0 -216px&quot;&gt; 未选择任何文件 &lt;/div&gt; &lt;/template&gt; &lt;el-button class=&quot;ml-3&quot; :icon=&quot;Upload&quot; type=&quot;success&quot; @click=&quot;handleUpload&quot; style=&quot;margin-top: 2px&quot; &gt; 上传 &lt;/el-button&gt; &lt;/el-upload&gt; &lt;span style=&quot;font-size: 14px; color: #606266&quot;&gt;附件列表&lt;/span&gt; &lt;el-table :data=&quot;fileTableData&quot; border class=&quot;table&quot; header-cell-class-name=&quot;table-header&quot; highlight-current-row &gt; &lt;el-table-column prop=&quot;uid&quot; label=&quot;附件编号&quot; width=&quot;155&quot; align=&quot;center&quot; &gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;filename&quot; label=&quot;附件名称&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;size&quot; label=&quot;附件大小&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;220&quot; align=&quot;center&quot;&gt; &lt;template #default=&quot;scope&quot;&gt; &lt;el-button type=&quot;warning&quot; size=&quot;small&quot; :icon=&quot;Delete&quot; @click=&quot;handleDel(scope.$index, scope.row)&quot; &gt; 删除 &lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; class=&quot;red&quot; size=&quot;small&quot; :icon=&quot;Download&quot; @click=&quot;handleDownload(scope.$index, scope.row)&quot; &gt; 下载 &lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;// 文件上传// 文件上传列表const fileTableData = ref([]);onMounted(() =&gt; &#123; if (applyForm.fileTableData) &#123; fileTableData.value = applyForm.fileTableData; &#125;&#125;);const fileList = ref([]);const uploadRef = ref();const tempList = ref([]);// file就是要删除的fileconst handleRemove = (file) =&gt; &#123;&#125;;// 不能够一味 的进行push 因为该函数会被多次调用 fileList其实就是当前最新的文件列表const changeFile = (file) =&gt; &#123; // params参数中的file就是要上传的文件 // 文件类型不限制 // const isIMAGE = (file.raw.type === &#x27;image/jpeg&#x27; || file.raw.type === &#x27;image/png&#x27; || file.raw.type === &#x27;image/gif&#x27;) const isLt25M = file.size / 1024 / 1024 &lt; 25; // 文件大小限制 if (!isLt25M) &#123; return ElMessage.error(&quot;上传文件大小不能超过25MB!&quot;); &#125; const reader = new FileReader(); reader.readAsDataURL(file.raw); reader.onload = function () &#123; // console.log(&#x27;文件的base64数据&#x27;, this.result)// 文件的base64数据 const fileInstance = &#123; filename: &quot;&quot;, size: &quot;&quot;, filenameHandler: &quot;&quot;, fileContent: &quot;&quot;, username: applyForm.staff_name, nodeCode: &quot;100&quot;, uid: &quot;&quot;, &#125;; const milliseconds = getCurrentMilliseconds(); // console.log(&#x27;milliseconds&#x27;, milliseconds) fileInstance.filename = file.name; fileInstance.size = file.size; fileInstance.filenameHandler = milliseconds + file.name; fileInstance.fileContent = this.result.split(&quot;,&quot;)[1]; fileInstance.uid = file.uid; tempList.value.push(fileInstance); &#125;;&#125;;// 后端要求filename加前缀New做新旧平台存储文件的区分//tempFileListTableData是给最后提交时用的const tempFileListTableData = computed(() =&gt; &#123; return fileTableData.value.map((item) =&gt; &#123; return &#123; filename: item.filename, size: item.size, filenameHandler: &quot;New&quot; + item.filenameHandler, fileContent: item.fileContent, username: item.username, nodeCode: item.nodeCode, uid: item.uid, &#125;; &#125;);&#125;);//tempFileList是给上传按钮用的const tempFileList = computed(() =&gt; &#123; return tempList.value.map((item) =&gt; &#123; return &#123; filename: item.filename, size: item.size, filenameHandler: &quot;New&quot; + item.filenameHandler, fileContent: item.fileContent, username: item.username, nodeCode: item.nodeCode, uid: item.uid, &#125;; &#125;);&#125;);const upload = () =&gt; &#123;&#125;;const handleUpload = async () =&gt; &#123; try &#123; await uploadAPI(&#123; fileList: tempFileList.value &#125;); fileTableData.value.push(...tempList.value); ElMessage.success(&quot;上传成功&quot;); tempFileListTableData.value = []; tempList.value = []; fileList.value = []; &#125; catch &#123; ElMessage.error(&quot;上传失败&quot;); &#125; uploadRef.value.submit();&#125;;&lt;/script&gt; 九、其他剩下的就是按照业务需求开发了","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"Node.js","slug":"Node.js","date":"2023-04-20T12:23:37.000Z","updated":"2024-03-12T08:27:48.581Z","comments":true,"path":"2023/04/20/Node.js/","link":"","permalink":"https://congtf.top/2023/04/20/Node.js/","excerpt":"","text":"Node.js一、Node.js 基础1、Node.js 是什么Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，用于后端 开发。通俗来讲，Node.js 就是一款应用程序、一款软件，它可以运行 JavaScript 。 JavaScript 有两种运行环境：浏览器和 Node.js。在浏览器中 JavaScript 通过调用浏览器内置的 DOM、BOM 这样的 API 函数（接口）操作 DOM 和 BOM，并被浏览器的 JavaScript 解析引擎（例如 Chrome 的 V8 引擎）所解析运行。同样在 Node.js 中也是这样，只不过他们各自的内置 API 不同 2、Node.js 可以做什么 基于 Express 框架（http://www.expressjs.com.cn/），可以快速构建 Web 应用 基于 Electron 框架（https://electronjs.org/），可以构建跨平台的*桌面 应用* 基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目 _读写和操作数据库_、创建实用的命令行工具辅助前端开发、etc… 二、计算机基础知识1、计算机基本组成 计算机由硬件和软件两大部分组成。硬件主要有以下部分： CPU：中央处理器，计算机最核心的配件，负责所有的计算、逻辑处理 内存：用来存储数据。程序、运行的游戏、打开的浏览器都要加载到内存中才能运行，程序读取的数据、计算的结果也都在内存中，内存的大小决定了能加载的东西的多少。特点是读写速度较快，断电丢失数据 硬盘：用来存储数据。特点是读写数据较慢，断电不丢失数据 主板：存放在内存中数据需要被 CPU 读取，CPU 计算完成后，还要把数据写入到内存中，然而 CPU 不能直接插在内存上，这就需要主板出马了，主板上很多个插槽，CPU 和内存都是插在主板上，主板的芯片组和总线解决了 CPU 和内存之间的通讯问题，芯片组控制数据传输的流转，决定数据从哪里流向哪里，总线是实际数据传输的告诉公里，总线速度决定了数据的传输速度 显卡：显卡里有 GPU 图形处理器，主要负责图形渲染，它将处理完的信号传递给显示器，最终由显示器呈现画面。使用图形界面操作系统的计算机，显卡是必不可少的。现在的主板都带了内置的显卡，如果想玩游戏、做图形渲染，一般需要一张单独的显卡，插在主板上 计算机软件分为系统软件和应用软件两大类。系统软件是指各类操作系统，如 Windows、Linux、UNIX、MacOS 等。操作系统本质上也是一种应用程序，用来管理和调度硬件资源。比如操作系统可以决定 CPU 处理哪些程序，比如操作系统可以与硬盘交互，读写文件。可以还包括操作系统的补丁程序及硬件驱动程序都属于系统类软件。应用程序是指用户可以使用的各种程序设计语言，以及各种程序设计语言编制的应用程序的集合。 2、程序运行的基本流程当我们打开一个程序的时候，首先系统会将程序从硬盘中载入到内存中，再交由 CPU 处理。CPU 处理完之后如果遇到图形信号将其交由显卡做进一步处理，最终呈现图像。遇到声音信号交由声卡处理最终呈现声音。 3、进程与线程进程：可以理解为程序的一次执行过程。比如打开资源管理器，我们可以看到计算机正在执行的进程 线程：线程是一个进程中执行的一个执行流。一个线程一定是属于某个进程的。一个进程可以分成很多个线程。可以将进程理解为一个完整的大的项目，而线程是这个项目中的某一个功能模块 三、内置模块 Buffer（缓冲器）1、概念Buffer 是一个类似于数组的对象 ，用于表示固定长度的字节序列。 Buffer 本质是一段内存空间，专门用来处理 二进制数据 2、特点 Buffer 大小固定且无法调整 Buffer 性能较好，可以直接对计算机内存进行操作 每个元素的大小为 1 字节（byte） 3、使用Buffer.alloc 创建 Buffer Buffer.allocUnsafe 创建 Buffer Buffer.from 创建 Buffer toString 方法将 Buffer 转为字符串 toString 默认是按照 utf-8 编码方式进行转换的 四、内置模块 fs 文件系统fs 全称为 file system ，称为文件系统 ，是 Node.js 中的内置模块，可以对计算机中的磁盘进行操作 1、文件写入文件写入就是将数据保存到文件中，我们可以使用如下几个方法来实现该效果 writeFile 异步写入 语法： fs.writeFile(file, data[, options], callback) 参数说明： file 文件路径 data 待写入的数据 options 选项设置 （可选） callback 写入 err 回调 返回值： undefined 代码示例： 1234567891011// require 是 Node.js 环境中的&#x27;全局&#x27;变量，用来导入模块const fs = require(&quot;fs&quot;);//将 『三人行，必有我师焉。』 写入到当前文件夹下的『座右铭.txt』文件中fs.writeFile(&quot;./座右铭.txt&quot;, &quot;三人行，必有我师焉。&quot;, (err) =&gt; &#123; //如果写入失败，则回调函数调用时，会传入错误对象，如写入成功，会传入 null if (err) &#123; console.log(err); return; &#125; console.log(&quot;写入成功&quot;);&#125;); writeFileSync 同步写入 语法: fs.writeFileSync(file, data[, options]) 参数与 fs.writeFile 大体一致，只是没有 callback 参数 返回值： undefined 代码示例： 12345try &#123; fs.writeFileSync(&quot;./座右铭.txt&quot;, &quot;三人行，必有我师焉。&quot;);&#125; catch (e) &#123; console.log(e);&#125; 注意 writeFile 和 writeFileSync 会将文件中原有的内容覆盖掉，因此有了追加写入 appendFile &#x2F; appendFileSync 追加写入 appendFile 作用是在文件尾部追加内容，appendFile 语法与 writeFile 语法完全相同 代码示例： 12345fs.appendFile(&quot;./座右铭.txt&quot;, &quot;择其善者而从之，其不善者而改之。&quot;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;追加成功&quot;);&#125;);fs.appendFileSync(&quot;./座右铭.txt&quot;, &quot;\\r\\n温故而知新, 可以为师矣&quot;); createWriteStream 流式写入 语法： fs.createWriteStream(path[, options]) 返回值： Object 代码示例： 123456let ws = fs.createWriteStream(&quot;./观书有感.txt&quot;);ws.write(&quot;半亩方塘一鉴开\\r\\n&quot;);ws.write(&quot;天光云影共徘徊\\r\\n&quot;);ws.write(&quot;问渠那得清如许\\r\\n&quot;);ws.write(&quot;为有源头活水来\\r\\n&quot;);ws.end(); 程序打开一个文件是需要消耗资源的 ，流式写入可以减少打开关闭文件的次数。 流式写入方式适用于 大文件写入或者频繁写入 的场景, writeFile 适合于 写入频率较低的场景 写入文件的场景 文件写入 在计算机中是一个非常常见的操作，下面的场景都用到了文件写入 下载文件 安装软件 保存程序日志，如 Git 编辑器保存文件 视频录制 当 需要持久化保存数据 的时候，应该想到 文件写入 2、文件读取文件读取顾名思义，就是通过程序从文件中取出其中的数据，我们可以使用如下几种方式： readFile 异步读取 语法： fs.readFile(path[, options], callback) 返回值： undefined 代码示例： 12345678910//导入 fs 模块const fs = require(&quot;fs&quot;);fs.readFile(&quot;./座右铭.txt&quot;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;);fs.readFile(&quot;./座右铭.txt&quot;, &quot;utf-8&quot;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;); readFileSync 同步读取 语法： fs.readFileSync(path[, options]) 返回值： string | Buffer 代码示例： 12let data = fs.readFileSync(&quot;./座右铭.txt&quot;);let data2 = fs.readFileSync(&quot;./座右铭.txt&quot;, &quot;utf-8&quot;); createReadStream 流式读取 语法： fs.createReadStream(path[, options]) 返回值： Object 代码示例： 1234567891011//创建读取流对象let rs = fs.createReadStream(&quot;./观书有感.txt&quot;);//每次取出 64k 数据后执行一次 data 回调rs.on(&quot;data&quot;, (data) =&gt; &#123; console.log(data); console.log(data.length);&#125;);//读取完毕后, 执行 end 回调rs.on(&quot;end&quot;, () =&gt; &#123; console.log(&quot;读取完成&quot;);&#125;); 读取文件应用场景 电脑开机 程序运行 编辑器打开文件 查看图片 播放视频 播放音乐 Git 查看日志 上传文件 查看聊天记录 3、文件移动与重命名在 Node.js 中，我们可以使用 rename 或 renameSync 来移动或重命名文件或文件夹 语法：fs.rename(oldPath, newPath, callback) fs.renameSync(oldPath, newPath) 代码示例： 12345fs.rename(&quot;./观书有感.txt&quot;, &quot;./论语/观书有感.txt&quot;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;移动完成&quot;);&#125;);fs.renameSync(&quot;./座右铭.txt&quot;, &quot;./论语/我的座右铭.txt&quot;); 4、文件删除在 Node.js 中，我们可以使用 unlink 或 unlinkSync 来删除文件 语法： fs.unlink(path, callback) fs.unlinkSync(path) 代码示例： 123456const fs = require(&quot;fs&quot;);fs.unlink(&quot;./test.txt&quot;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;删除成功&quot;);&#125;);fs.unlinkSync(&quot;./test2.txt&quot;); 5、文件夹操作借助 Node.js 的能力，我们可以对文件夹进行 创建 、 读取 、 删除 等操作 mkdir 创建文件夹 在 Node.js 中，我们可以使用 mkdir 或 mkdirSync 来创建文件夹 语法：fs.mkdir(path[, options], callback) fs.mkdirSync(path[, options]) 示例代码： 123456789101112//异步创建文件夹fs.mkdir(&quot;./page&quot;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;创建成功&quot;);&#125;);//递归异步创建fs.mkdir(&quot;./1/2/3&quot;, &#123; recursive: true &#125;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;递归创建成功&quot;);&#125;);//递归同步创建文件夹fs.mkdirSync(&quot;./x/y/z&quot;, &#123; recursive: true &#125;); readdir 读取文件夹 在 Node.js 中，我们可以使用 readdir 或 readdirSync 来读取文件夹 语法：fs.readdir(path[, options], callback) fs.readdirSync(path[, options]) 示例代码： 12345678//异步读取fs.readdir(&quot;./论语&quot;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;);//同步读取let data = fs.readdirSync(&quot;./论语&quot;);console.log(data); rmdir 删除文件夹 在 Node.js 中，我们可以使用 rmdir 或 rmdirSync 来删除文件夹 语法： fs.rmdir(path[, options], callback) fs.rmdirSync(path[, options]) 示例代码： 1234567891011121314//异步删除文件夹fs.rmdir(&quot;./page&quot;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;删除成功&quot;);&#125;);//异步递归删除文件夹fs.rmdir(&quot;./1&quot;, &#123; recursive: true &#125;, (err) =&gt; &#123; if (err) &#123; console.log(err); &#125; console.log(&quot;递归删除&quot;);&#125;);//同步递归删除文件夹fs.rmdirSync(&quot;./x&quot;, &#123; recursive: true &#125;); 6、路径问题fs 模块对资源进行操作时，路径的写法有两种： 相对路径 .&#x2F;座右铭.txt 当前目录下的座右铭.txt 座右铭.txt 等效于上面的写法 ..&#x2F;座右铭.txt 当前目录的上一级目录中的座右铭.txt 绝对路径 D:&#x2F;Program Files windows 系统下的绝对路径 &#x2F;usr&#x2F;bin Linux 系统下的绝对路径 相对路径中所谓的 当前目录 ，指的是 命令行的工作目录 ，而并非是文件的所在目录。所以当命令行的工作目录与文件所在目录不一致时，会出现一些 BUG。因此可以使用 dirname 与文件名拼接成绝对路径。dirname 与 require 类似，都是 Node.js 环境中的’全局’变量。**dirname 保存着 当前文件所在目录的绝对路径。使用 fs 模块的时候，尽量使用 **dirname 将路径转化为绝对路径，这样可以避免相对路径产生的 Bug 五、内置模块 pathpath 模块提供了操作路径的功能，几个较为常用的 API： 代码示例： 1234567891011121314const path = require(&quot;path&quot;);//获取路径分隔符console.log(path.sep);//拼接绝对路径console.log(path.resolve(__dirname, &quot;test&quot;));//解析路径let pathname = &quot;D:/program file/nodejs/node.exe&quot;;console.log(path.parse(pathname));//获取路径基础名称console.log(path.basename(pathname));//获取路径的目录名console.log(path.dirname(pathname));//获取路径的扩展名console.log(path.extname(pathname)); 六、http1、http 协议HTTP（hypertext transport protocol）协议，中文叫超文本传输协议。是一种基于 TCP&#x2F;IP 的应用层通信协议，它详细规定了 浏览器 和万维网 服务器 之间互相通信的规则 协议中主要规定了两个方面的内容 客户端：用来向服务器发送数据，可以被称之为请求报文 服务端：向客户端返回数据，可以被称之为响应报文 请求报文的组成 请求行 请求头 空行 请求体 HTTP 的请求行 请求方法（get、post、put、delete 等） 请求 URL（统一资源定位器） HTTP 协议版本号 HTTP 请求头 常见的请求头有： HTTP 的请求体 请求体内容的格式是非常灵活的， （可以是空）&#x3D;&#x3D;&gt; GET 请求， （也可以是字符串，还可以是 JSON）&#x3D;&#x3D;&#x3D;&gt; POST 请求 例如： 字符串：keywords&#x3D;手机&amp;price&#x3D;2000 JSON：{“keywords”:”手机”,”price”:2000} 响应报文的组成 响应行 HTTP&#x2F;1.1 200 OK HTTP&#x2F;1.1：HTTP 协议版本号 200：响应状态码 OK：响应状态描述 响应头 Cache-Control:缓存控制 private 私有的，只允许客户端缓存数据 Connection: 链接设置 Content-Type:text&#x2F;html;charset&#x3D;utf-8 设置响应体的数据类型以及字符集,响应体为 html，字符集 utf-8 Content-Length:响应体的长度，单位为字节 空行 响应体 响应体内容的类型是非常灵活的，常见的类型有 HTML、CSS、JS、图片、JSON 2、IP 地址IP 地址就是接入互联网的每台计算机的唯一地址，用来标识接入互联网的设备。通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用 点分十进表示的 IP 地址 （192.168.1.1） 共享 IP 为了更好的利用 IP 地址，节省资源。以家庭为例，手机、电脑、打印机、电视连接到同一路由器，路由器为他们分配各自的 IP，这就形成了一个局域网（私网），局域网中的设备之间可以互相通信。为了能够访问外部资源，还需接入到互联网才行。这样一个家庭中的所有设备就可以通过一个公网（广域网）IP 访问互联网了，实现了 IP 共享 此外，还有一类 IP 称为本机回环 IP 地址，比如 127.0.0.1，访问这个 IP 地址实际上就是访问本机，等价于 loacalhost 端口号 在一台电脑中，可以运行成百上千个 web 服务。每个 web 服 务都对应一个唯一的端口号。客户端发送过来的 网络请求，通过端口号，可以 被准确地交给对应的 web 服务进行处理 域名和域名服务器 尽管 IP 地址能够唯一地标记网络上的计算机，但 IP 地址是一长串数字， 不直观，而且不便于记忆，于是人们又发明了另一套 字符型的地址方案，即所谓的域名（Domain Name）地址。 IP 地址和域名是一一对应的关系，这就好比人名和身份证 ID 一样。这份对应关系存放在一种叫做域名服务器(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器 实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器 3、创建 http 服务使用 nodejs 创建 HTTP 服务 123456789101112//1. 导入 http 模块const http = require(&quot;http&quot;);//2. 创建服务对象 create 创建 server 服务// request 意为请求. 是对请求报文的封装对象, 通过 request 对象可以获得请求报文的数据// response 意为响应. 是对响应报文的封装对象, 通过 response 对象可以设置响应报文const server = http.createServer((request, response) =&gt; &#123; response.end(&quot;Hello HTTP server&quot;);&#125;);//3. 监听端口, 启动服务server.listen(9000, () =&gt; &#123; console.log(&quot;服务已经启动, 端口 9000 监听中...&quot;);&#125;); 注意事项 响应内容中文乱码的解决办法 1response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=utf-8&quot;); HTTP 协议默认端口是 80 。HTTPS 协议的默认端口是 443, HTTP 服务开发常用端口有 3000， 8080，8090，9000 等 获取 HTTP 请求报文 想要获取请求的数据，需要通过 request 对象 注意事项： request.url 只能获取路径以及查询字符串(端口号以后的内容)，无法获取 URL 中的域名以及协议的内容 request.headers 将请求信息转化成一个对象，并将属性名都转化成了『小写』 关于路径：如果访问网站的时候，只填写了 IP 地址或者是域名信息，此时请求的路径为『 &#x2F; 』 关于 favicon.ico：这个请求是属于浏览器自动发送的请求 设置 HTTP 响应报文 练习 搭建 HTTP 服务，响应一个 4 行 3 列的表格，并且要求表格有 隔行换色效果 ，且 点击 单元格能 高亮显示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//导入 http 模块const http = require(&quot;http&quot;);//创建服务对象const server = http.createServer((request, response) =&gt; &#123; response.end(`&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt;td&#123;padding: 20px 40px;&#125;table tr:nth-child(odd)&#123;background: #aef;&#125;table tr:nth-child(even)&#123;background: #fcb;&#125;table, td&#123;border-collapse: collapse;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;script&gt;//获取所有的 tdlet tds = document.querySelectorAll(&#x27;td&#x27;);//遍历tds.forEach(item =&gt; &#123;item.onclick = function()&#123;this.style.background = &#x27;#222&#x27;;&#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`); //设置响应体&#125;);//监听端口, 启动服务server.listen(9000, () =&gt; &#123; console.log(&quot;服务已经启动....&quot;);&#125;); 网页资源的基本加载过程 网页资源的加载都是循序渐进的，首先获取 HTML 的内容， 然后解析 HTML 在发送其他资源的请求，如 CSS，Javascript，图片等 静态资源服务 静态资源是指 内容长时间不发生改变的资源 ，例如图片，视频，CSS 文件，JS 文件，HTML 文件，字体文 件等 动态资源是指 内容经常更新的资源 ，例如百度首页，网易首页，京东搜索列表页面等 网站根目录或静态资源目录 HTTP 服务在哪个文件夹中寻找静态资源，那个文件夹就是 静态资源目录 ，也称之为 网站根目录 1234567891011121314151617181920212223242526require(&quot;http&quot;) .createServer((request, response) =&gt; &#123; //获取请求的方法已经路径 let &#123; url, method &#125; = request; //判断请求方式以及请求路径 if (method == &quot;GET&quot; &amp;&amp; url == &quot;/index.html&quot;) &#123; //需要响应文件中的内容 let data = require(&quot;fs&quot;).readFileSync(__dirname + &quot;/index.html&quot;); response.end(data); &#125; else if (method == &quot;GET&quot; &amp;&amp; url == &quot;/css/app.css&quot;) &#123; //需要响应文件中的内容 let data = require(&quot;fs&quot;).readFileSync(__dirname + &quot;/public/css/app.css&quot;); response.end(data); &#125; else if (method == &quot;GET&quot; &amp;&amp; url == &quot;/js/app.js&quot;) &#123; //需要响应文件中的内容 let data = require(&quot;fs&quot;).readFileSync(__dirname + &quot;/public/js/app.js&quot;); response.end(data); &#125; else &#123; //404响应 response.statusCode = 404; response.end(&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;); &#125; &#125;) .listen(80, () =&gt; &#123; console.log(&quot;80端口正在启动中....&quot;); &#125;); 上面这段代码根据路径和方法相应不同的资源，显然这种方式不够完美，我们需要更简洁的方法 123456789101112131415161718192021222324require(&quot;http&quot;) .createServer((request, response) =&gt; &#123; //获取请求的方法已经路径 let &#123; url, method &#125; = request; //文件夹路径 let rootDir = __dirname + &quot;/public&quot;; //拼接文件路径 let filePath = rootDir + url; //读取文件内容 fs.readFile(filePath, (err, data) =&gt; &#123; //判断 if (err) &#123; //如果出现错误，响应404状态码 response.statusCode = 404; response.end(&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;); &#125; else &#123; //响应文件内容 response.end(data); &#125; &#125;); &#125;) .listen(80, () =&gt; &#123; console.log(&quot;80端口正在启动中....&quot;); &#125;); 通过这种方法可以根据请求路径动态响应资源 设置资源类型（mime 类型） 媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、 文件或字节流的性质和格式。 HTTP 服务可以设置响应头 Content-Type 来表明响应体的 MIME 类型，浏览器会根据该类型决定如何处理 资源 下面是常见文件对应的 mime 类型 GET 和 POST GET 主要用来获取数据，POST 主要用来提交数据 GET 带参数请求是将参数缀到 URL 之后，在地址栏中输入 url 访问网站就是 GET 请求， POST 带参数请求是将参数放到请求体中 POST 请求相对 GET 安全一些，因为在浏览器中参数会暴露在地址栏 GET 请求大小有限制，一般为 2K，而 POST 请求则没有大小限制 以下均为 GET 请求： 在地址栏直接输入 url 访问 点击 a 链接 link 标签引入 css script 标签引入 js img 标签引入图片 form 标签中的 method 为 get （不区分大小写） ajax 中的 get 请求 以下均为 POST 请求： form 标签中的 method 为 post（不区分大小写） AJAX 的 post 请求 七、模块化模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过 程。对于整个系统来说，模块是可组 合、分解和更换的单元 编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相 依赖的多个小模块 把代码进行模块化拆分的好处 防止命名冲突 高复用性 高维护性 common.js 暴露数据 module.exports &#x3D; value exports.name &#x3D; value 注意 module.exports 可以暴露 任意 数据 不能使用 exports &#x3D; value 的形式暴露数据。exports &#x3D; module.exports &#x3D; {} ，require 返回的永远是目标模块中 module.exports 的值（因为 exports 和 module.exports 是对象，存的是引用。如果直接使用 exports &#x3D; value 赋值，相当于将 exports 与原来 module.exports 的链接断开了 ） common.js 导入（引入、加载）模块 在模块中使用 require 传入文件路径即可引入文件 1const test = require(&quot;./me.js&quot;); require 使用的一些注意事项： 对于自定义模块，导入时路径建议写相对路径 ，且不能省略 .&#x2F; 和 ..&#x2F; js 和 json 文件导入时可以不用写后缀，c&#x2F;c++编写的 node 扩展文件也可以不写后缀，但是一 般用不到 如果导入的路径是个文件夹，则会 首先 检测该文件夹下 package.json 文件中 main 属性对应 的文件。如果存在则导入，反之如果文件不存在会报错。如果 main 属性不存在，或者 package.json 不存在，则会尝试导入文件夹下的 index.js 和 index.json 。如果还是没找到，就会报错 导入 node.js 内置模块时，直接 require 模块的名字即可，无需加路径 八、包管理工具包管理工具是一个通用的概念，很多编程语言都有包管理工具 npm 全称 Node Package Manager ，翻译为中文意思是『Node 的包管理工具』。它是 node.js 官方内置的包管理工具 npm 初始化 npm init 命令的作用是将文件夹初始化为一个『包』， 交互式创建 package.json 文件。package.json 是包的配置文件，每个包都必须要有 package.json。也可以使用 npm init -y 或者 npm init –yes 极速创建 package.json。下面是一个 package.json 的示例 123456789101112&#123;&quot;name&quot;: &quot;1-npm&quot;, #包的名字&quot;version&quot;: &quot;1.0.0&quot;, #包的版本&quot;description&quot;: &quot;&quot;, #包的描述&quot;main&quot;: &quot;index.js&quot;, #包的入口文件&quot;scripts&quot;: &#123; #脚本配置&quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;&#125;,&quot;author&quot;: &quot;&quot;, #作者&quot;license&quot;: &quot;ISC&quot; #开源证书&#125; nodemodules 文件夹用来存放所有已安装到项目中的包。注意：今后在项目开发中，一定要把 nodemodules 文件夹，添加 到 .gitignore 忽略文件中 package-lock.json 配置文件用来记录 node_modules 目录下的每一个包 的下载信息，例如包的名字、版本号、下载地址等 生产依赖与开发依赖 我们可以在安装时设置选项来区分 依赖的类型 ，目前分为两类： 全局安装 我们可以执行安装选项 -g 进行全局安装 1npm i -g nodemon 全局安装完成之后就可以在命令行的任何位置运行 nodemon 命令 环境变量 Path Path 是操作系统的一个环境变量，可以设置一些文件夹的路径，在当前工作目录下找不到可执行文件 时，就会在环境变量 Path 的目录中挨个的查找，如果找到则执行，如果没有找到就会报错 如果希望某个程序在任何工作目录下都能正常运行，可以将该程序的所在目录配置到环境 变量 Path 中 安装包依赖 12npm inpm install 安装指定版本的包 1234## 格式npm i &lt;包名@版本号&gt;## 示例npm i jquery@1.11.2 删除依赖 12345## 局部删除npm remove uniqnpm r uniq## 全局删除npm remove -g nodemon yarn yarn 是由 Facebook 在 2016 年推出的新的 Javascript 包管理工具，官方网址：https://yarnpkg.com/ yarn 官方宣称的一些特点 速度超快：yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大 化资源利用率，因此安装速度更快 超级安全：在执行代码之前，yarn 会通过算法校验每个安装包的完整性 超级可靠：使用详细、简洁的锁文件格式和明确的安装算法，yarn 能够保证在不同系统上无差异的 工作 yarn 常用命令 nvm nvm 全称 Node Version Manager 顾名思义它是用来管理 node 版本的工具，方便切换不同版本的 Node.js nvm 的使用非常的简单，跟 npm 的使用方法类似 首先先下载 nvm，下载地址 https://github.com/coreybutler/nvm-windows/releases，选择 nvm-setup.exe 下载即可 常用命令 九、express 框架Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架http://www.expressjs.com.cn/ 对于前端程序员来说，最常见的两种服务器分别是： Web 网站服务器：专门对外提供 Web 网页资源的服务器 API 接口服务器：专门对外提供 API 接口的服务器 使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口 的服务器 1、express 使用express 本身是一个 npm 包，所以可以通过 npm 安装 1npm i express express 初体验 123456789101112//1. 导入 expressconst express = require(&quot;express&quot;);//2. 创建应用对象const app = express();//3. 创建路由规则app.get(&quot;/home&quot;, (req, res) =&gt; &#123; res.send(&quot;hello express server&quot;);&#125;);//4. 监听端口 启动服务app.listen(3000, () =&gt; &#123; console.log(&quot;服务已经启动, 端口监听为 3000...&quot;);&#125;); 在浏览器访问 http://127.0.0.1:3000/home 2、express 路由官方定义： 路由确定了应用程序如何响应客户端对特定端点的请求 路由的使用 一个路由的组成有请求方法 ， 路径和回调函数 组成 express 中提供了一系列方法，可以很方便的使用路由，使用格式如下： app.(path，callback) 代码示例： 12345678910111213141516171819202122232425262728//导入 expressconst express = require(&quot;express&quot;);//创建应用对象const app = express();//创建 get 路由app.get(&quot;/home&quot;, (req, res) =&gt; &#123; res.send(&quot;网站首页&quot;);&#125;);//首页路由app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(&quot;我才是真正的首页&quot;);&#125;);//创建 post 路由app.post(&quot;/login&quot;, (req, res) =&gt; &#123; res.send(&quot;登录成功&quot;);&#125;);//匹配所有的请求方法app.all(&quot;/search&quot;, (req, res) =&gt; &#123; res.send(&quot;1 秒钟为您找到相关结果约 100,000,000 个&quot;);&#125;);//自定义 404 路由app.all(&quot;*&quot;, (req, res) =&gt; &#123; res.send(&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;);&#125;);//监听端口 启动服务app.listen(3000, () =&gt; &#123; console.log(&quot;服务已经启动, 端口监听为 3000&quot;);&#125;); 路由的匹配过程 每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后， 才会调用对应的处理函数 在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时 匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理 注意 路由匹配按照定义的先后顺序进行匹配 请求类型和请求的 URL 同时匹配成功， 才会调用对应的处理函数 模块化路由 为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。 将路由抽离为单独模块的步骤如下： 创建路由模块对应的 .js 文件 调用 express.Router() 函数创建路由对象 向路由对象上挂载具体的路由 使用 module.exports 向外共享路由对象 使用 app.use() 函数注册路由模块 12345678910111213//1. 导入 expressconst express = require(&quot;express&quot;);//2. 创建路由器对象const router = express.Router();//3. 在 router 对象身上添加路由router.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(&quot;首页&quot;);&#125;);router.get(&quot;/cart&quot;, (req, res) =&gt; &#123; res.send(&quot;购物车&quot;);&#125;);//4. 暴露module.exports = router; express 中的 Router 是一个完整的中间件和路由系统，可以看做是一个小型的 app 对象 导入使用路由 123456789const express = require(&quot;express&quot;);const app = express();//5.引入子路由文件const homeRouter = require(&quot;./routes/homeRouter&quot;);//6.设置和使用中间件app.use(homeRouter);app.listen(3000, () =&gt; &#123; console.log(&quot;3000 端口启动....&quot;);&#125;); 为路由模块添加前缀 1234//1、导入路由模块const userRouter = require(&quot;./router/user.js&quot;);//2、使用app.use()注册路由模块，并添加统一的访问前缀 /apiapp.use(&quot;/api&quot;, userRouter); 获取 URL 中的查询参数 通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到 服务器的参数： 123456app.get(&quot;/&quot;, (req, res) =&gt; &#123; // req.query默认是一个空对象 // 客户端使用?name=zs&amp;age=20这种查询字符串的形式发送到服务器的参数， // 可以通过req.query对象访问到 console.log(req.query);&#125;); 获取 URL 中的动态参数 通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数 12345app.get(&quot;/user/:id&quot;, (req, res) =&gt; &#123; // req.params默认是一个空对象 // 里面存放着通过:动态匹配到的参数值 console.log(req.params);&#125;); express 响应设置 express 框架封装了一些 API 来方便给客户端响应数据，并且兼容原生 HTTP 模块的获取方式 1234567891011121314151617181920//获取请求的路由规则app.get(&quot;/response&quot;, (req, res) =&gt; &#123; //1. express 中设置响应的方式兼容 HTTP 模块的方式 res.statusCode = 404; res.statusMessage = &quot;xxx&quot;; res.setHeader(&quot;abc&quot;, &quot;xyz&quot;); res.write(&quot;响应体&quot;); res.end(&quot;xxx&quot;); //2. express 的响应方法 res.status(500); //设置响应状态码 res.set(&quot;xxx&quot;, &quot;yyy&quot;); //设置响应头 res.send(&quot;中文响应不乱码&quot;); //设置响应体 //连贯操作 res.status(404).set(&quot;xxx&quot;, &quot;yyy&quot;).send(&quot;你好朋友&quot;); //3. 其他响应 res.redirect(&quot;http://atguigu.com&quot;); //重定向 res.download(&quot;./package.json&quot;); //下载响应 res.json(); //响应 JSON res.sendFile(__dirname + &quot;/home.html&quot;); //响应文件内容&#125;); 注意，使用 res.send()发送的中文并没有乱码，这是因为 express 自动在响应头添加了res.setHeader(‘content-type’,’text&#x2F;html;charset&#x3D;utf-8’); 3、express 中间件中间件（Middleware）本质是一个回调函数 中间件函数 可以像路由回调一样访问 请求对象（request） ， 响应对象（response） 中间件的作用 就是 使用函数封装公共操作，简化代码 当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而 对这次请求进行预处理 注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中 只包含 req 和 res。**next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下 一个中间件或路由 定义全局中间件 客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生 效的中间件 声明中间件函数 123456let recordMiddleware = function (request, response, next) &#123; //实现功能代码 //..... //执行next函数(当如果希望执行完中间件函数之后，仍然继续执行路由中的回调函数，必须调用next) next();&#125;; 应用中间件 通过调用 app.use(中间件函数)，即可定义一个全局生效的中间件 1app.use(recordMiddleware); 声明时可以直接将匿名函数传递给 use 1234app.use(function (request, response, next) &#123; console.log(&quot;定义第一个中间件&quot;); next();&#125;); 定义多个全局中间件 可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之 后，会按照中间件定义的先后顺序依次进行调用 局部生效的中间件(路由中间件) 如果只需要对某一些路由进行功能封装 ，则就需要路由中间件。路由中间件不使用 app.use() 定义,调用格式如下： 123app.get(&quot;/路径&quot;, `中间件函数`, (request, response) =&gt; &#123;&#125;);// 使用多个路由中间件app.get(&quot;/路径&quot;, `中间件函数1`, `中间件函数2`, (request, response) =&gt; &#123;&#125;); 中间件的 几个使用注意事项 一定要在路由之前注册中间件 客户端发送过来的请求，可以连续调用多个中间件进行处理 执行完中间件的业务代码之后，不要忘记调用 next() 函数 为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码 连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象 Express 内置的中间件 自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大 的提高了 Express 项目的开发效率和体验 express.static 快速托管静态资源的内置中间件，例如： HTML 文件、 图片、CSS 样式等（无兼容性） express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性， 仅在 4.16.0+ 版本中可用） 1234567891011121314151617181920//引入express框架const express = require(&quot;express&quot;);//创建服务对象const app = express();// 配置解析application/json格式数据的内置中间件app.use(express.json());// 配置解析application/x-www-form-urlencoded格式数据的内置中间件app.use(express.urlencoded(&#123; extended: false &#125;));//静态资源中间件的设置，将当前文件夹下的public目录作为网站的根目录app.use(express.static(&quot;./public&quot;)); //当然这个目录中都是一些静态资源//如果访问的内容经常变化，还是需要设置路由//但是，在这里有一个问题，如果public目录下有index.html文件，单独也有index.html的路由，//则谁书写在前，优先执行谁app.get(&quot;/index.html&quot;, (request, response) =&gt; &#123; response.send(&quot;首页&quot;);&#125;);//监听端口app.listen(3000, () =&gt; &#123; console.log(&quot;3000 端口启动....&quot;);&#125;); 4、防盗链我们在访问第三方资源（如图片）的时候，有时可能会出现资源 403、404 的情况，这是因为服务端做了防盗链处理，只允许指定的域名访问资源 服务端一般使用 Referer 请求头识别访问来源，然后处理资源访问。 Referer 是 HTTP 请求头的一部分，当浏览器向 Web 服务器发送请求的时候，一般会带上 Referer，它包含了当前请求资源的来源页面的地址。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。 实现防盗链 在服务端只需通过中间件即可实现防盗链 123456789101112131415161718app.use((req, res, next) =&gt; &#123; //检测请求头中的referer是否为127.0.0.1 //获取referer let referer = req.get(&quot;referer&quot;); if (referer) &#123; //实例化 let url = new URL(referer); //获取hostname let hostname = url.hostname; //判断 if (hostname !== &quot;127.0.0.1&quot;) &#123; //响应404 res.status(404).send(&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;); return; &#125; &#125; next();&#125;); 如果第三方设置了防盗链，我们又想访问该怎么做呢 设置不发送 referrer 就行了 用 &lt;a&gt;、&lt;area&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;script&gt; 或者 &lt;link&gt; 元素上的 referrerpolicy 属性为其设置独立的请求策略，例如： 1&lt;img src=&quot;http://……&quot; referrerpolicy=&quot;no-referrer&quot; /&gt; 或者直接在 HTMl 页面头中通过 meta 属性全局配置： 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 扩展参考：http://www.ruanyifeng.com/blog/2019/06/http-referer.html 5、EJS 模板引擎模板引擎是分离用户界面和业务数据 的一种技术 EJS 是一个高效的 Javascript 的模板引擎。官网: https://ejs.co/ 中文站：https://ejs.bootcss.com/ EJS 使用 下载安装 EJS 1npm i ejs --save 代码示例 123456789//1.引入ejsconst ejs = require(&#x27;ejs&#x27;);//2.定义数据let person = [&#x27;张三&#x27;,&#x27;李四&#x27;,&#x27;王二麻子&#x27;];//3.ejs解析模板返回结构//&lt;%= %&gt; 是ejs解析内容的标记，作用是输出当前表达式的执行结构let html = ejs.render(‘&lt;%= person.join(&quot;,&quot;) %&gt;’, &#123;person:person&#125;);//4.输出结果console.log(html); render 渲染函数会将其第一个参数中&lt;% %&gt;中的值替换为第二个参数（也就是数据）进行解析渲染 EJS 常用语法 执行 JS 代码(可以认为里面是 js 语句，如条件语句、循环语句等) 1&lt;% code %&gt; 输出转义的数据到模板上(可以认为里面是 js 表达式) 1&lt;%= code %&gt; 实际上，我们通常将需要渲染的界面和数据分离开来 新建 test.ejs 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;我爱你&lt;%=name%&gt;&lt;/h2&gt; &lt;hr /&gt; &lt;h4&gt;&lt;%=word%&gt;&lt;/h4&gt; &lt;/body&gt;&lt;/html&gt; 主文件中 1234567891011121314const express = require(&quot;express&quot;);const ejs = require(&quot;ejs&quot;);const fs = require(&quot;fs&quot;);const app = express();const name = &quot;中国&quot;;const word = &quot;亲爱的母亲&quot;;const str = fs.readFileSync(__dirname + &quot;/test.ejs&quot;).toString();const result = ejs.render(str, &#123; name: name, word: word &#125;);app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(result);&#125;);app.listen(3000, () =&gt; &#123; console.log(&quot;服务器启动了...&quot;);&#125;); EJS 列表渲染 test.ejs 中 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;%name.forEach(item=&gt;&#123;%&gt; &lt;li&gt;&lt;%=item%&gt;&lt;/li&gt; &lt;%&#125;)%&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; EJS 条件渲染 test.ejs 中 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%if(isLogin)&#123;%&gt; &lt;span&gt;欢迎回来&lt;/span&gt; &lt;%&#125;else&#123;%&gt; &lt;button&gt;登录&lt;/button&gt;&lt;button&gt;注册&lt;/button&gt; &lt;%&#125;%&gt; &lt;/body&gt;&lt;/html&gt; express 中使用 EJS 在之前我们使用 fs 去手动读取 ejs 中的数据并交给 ejs.render 函数去渲染。但在 express 中我们有更简便的方法，无需手动读取 123456789101112131415const express = require(&quot;express&quot;);const path = require(&quot;path&quot;);const ejs = require(&quot;ejs&quot;);const app = express();//将express中的模板引擎设置为ejsapp.set(&quot;view engine&quot;, &quot;ejs&quot;);//设置模板文件的存放位置app.set(&quot;views&quot;, path.resolve(__dirname, &quot;./views&quot;));app.get(&quot;/&quot;, (req, res) =&gt; &#123; const title = &quot;人生得意须尽欢&quot;; res.render(&quot;test&quot;, &#123; title &#125;);&#125;);app.listen(3000, () =&gt; &#123; console.log(&quot;服务器启动了...&quot;);&#125;); 6、express-generatorexpress-generator 是一款官方推荐的 Express 应用程序生成器，通过它可以快速创建一个 Express 应用骨架 可以通过 npx（包含在 Node.js8.2.0 及更高版本中）命令来运行 Express 应用程序生成器 1$ npx express-generator 对于较老的 Node 版本，可以通过 npm 将 Express 应用程序生成器安装到全局环境中并使用 12$ npm install -g express-generator$ express 使用如下命令就可以快速创建一个 Express 应用骨架。其中-e 表示添加 EJS 模板引擎支持，dirname 是要创建的文件夹名称 1$ express -e dirname 文件上传处理 使用如下命令快速创建应用骨架 1$ express -e file 在 file&#x2F;routes&#x2F;index.js 中新增两个头像上传的路由 1234567891011121314const express = require(&quot;express&quot;);const router = express.Router();/* GET home page. */router.get(&quot;/&quot;, function (req, res, next) &#123; res.render(&quot;index&quot;, &#123; title: &quot;Express&quot; &#125;);&#125;);router.get(&quot;/portrait&quot;, function (req, res, next) &#123; res.render(&quot;portrait&quot;);&#125;);router.post(&quot;/portrait&quot;, function (req, res, next) &#123; res.send(&quot;111&quot;);&#125;);module.exports = router; 对应的在 views 文件下创建 portrait.ejs 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 对于文件上传，必须将enctype属性设置为multipart/form-data --&gt; &lt;form action=&quot;/portrait&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;portrait&quot; placeholder=&quot;上传头像&quot; /&gt; &lt;hr /&gt; &lt;button&gt;上传&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 接下来需要使用一个包叫 formidable 对上传的文件作进一步处理 1npm i formidable 1234567891011121314151617181920212223const express = require(&quot;express&quot;);//导入formidableconst formidable = require(&quot;formidable&quot;);const router = express.Router();/* GET home page. */router.get(&quot;/&quot;, function (req, res, next) &#123; res.render(&quot;index&quot;, &#123; title: &quot;Express&quot; &#125;);&#125;);router.get(&quot;/portrait&quot;, function (req, res, next) &#123; res.render(&quot;portrait&quot;);&#125;);router.post(&quot;/portrait&quot;, function (req, res, next) &#123; const form = formidable(&#123; multiples: true &#125;); form.parse(req, (err, fields, files) =&gt; &#123; if (err) &#123; next(err); return; &#125; res.json(&#123; fields, files &#125;); &#125;);&#125;);module.exports = router; 查看浏览器，可以看到 fields 里面存放的是一般表单的数据，比如 text、radio、select、checkbox 这种类型。而 files 里面保存的是 file 类型的数据 一般拿到客户端上传的文件之后，可以将其保存在静态资源目录下以方便用户访问。并将访问的路径保存在数据库里，并且返回给用户。 12345678910111213141516171819202122232425262728293031const express = require(&quot;express&quot;);//导入formidableconst formidable = require(&quot;formidable&quot;);const router = express.Router();/* GET home page. */router.get(&quot;/&quot;, function (req, res, next) &#123; res.render(&quot;index&quot;, &#123; title: &quot;Express&quot; &#125;);&#125;);router.get(&quot;/portrait&quot;, function (req, res, next) &#123; res.render(&quot;portrait&quot;);&#125;);router.post(&quot;/portrait&quot;, function (req, res, next) &#123; const form = formidable(&#123; multiples: true, //设置文件上传保存的路径 uploadDir: __dirname + &quot;/../public/images&quot;, //保持文件后缀 keepExtensions: true, &#125;); form.parse(req, (err, fields, files) =&gt; &#123; if (err) &#123; next(err); return; &#125; //通过files.portrait.newFilename拼接保存文件上传的路径 let url = &quot;/images/&quot; + files.portrait.newFilename; res.send(url); &#125;);&#125;);module.exports = router; 7、账单案例使用 express-generator 快速生成一个应用骨架 accounts 在 routes&#x2F;index.js 中新增&#x2F;account 和&#x2F;account&#x2F;create 路由中间件 12345678910111213141516171819202122232425262728293031323334const express = require(&quot;express&quot;);const router = express.Router();/* GET home page. */router.get(&quot;/&quot;, function (req, res, next) &#123; res.render(&quot;index&quot;, &#123; title: &quot;Express&quot; &#125;);&#125;);// 账单列表页router.get(&quot;/account&quot;, function (req, res, next) &#123; const accounts = [ &#123; time: &quot;2023-04-01&quot;, title: &quot;吃饭&quot;, type: &quot;-1&quot;, account: 36, &#125;, &#123; time: &quot;2023-04-20&quot;, title: &quot;发工资&quot;, type: &quot;1&quot;, account: 15000, &#125;, ]; res.render(&quot;list&quot;, &#123; accounts &#125;);&#125;);//新增记录页router.get(&quot;/account/create&quot;, function (req, res, next) &#123; res.render(&quot;create&quot;);&#125;);//处理新增记录router.post(&quot;/account&quot;, function (req, res, next) &#123; res.send(&quot;提交成功&quot;);&#125;);module.exports = router; 并在 views 中新建 list.ejs 和 create.ejs，这样账单的基本静态页面就搭建起来了 list.ejs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;style&gt; label &#123; font-weight: normal; &#125; .panel-body .glyphicon-remove &#123; display: none; &#125; .panel-body:hover .glyphicon-remove &#123; display: inline-block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-lg-8 col-lg-offset-2&quot;&gt; &lt;h2&gt;记账本&lt;/h2&gt; &lt;hr /&gt; &lt;div class=&quot;accounts&quot;&gt; &lt;% accounts.forEach(item =&gt; &#123; %&gt; &lt;div class=&quot;panel &lt;%= item.type===&#x27;-1&#x27; ? &#x27;panel-danger&#x27; : &#x27;panel-success&#x27; %&gt;&quot; &gt; &lt;div class=&quot;panel-heading&quot;&gt;&lt;%= item.time %&gt;&lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;div class=&quot;col-xs-6&quot;&gt;&lt;%= item.title %&gt;&lt;/div&gt; &lt;div class=&quot;col-xs-2 text-center&quot;&gt; &lt;span class=&quot;label &lt;%= item.type===&#x27;-1&#x27; ? &#x27;label-warning&#x27; : &#x27;label-success&#x27; %&gt;&quot; &gt;&lt;%= item.type===&#x27;-1&#x27; ? &#x27;支出&#x27; : &#x27;收入&#x27; %&gt;&lt;/span &gt; &lt;/div&gt; &lt;div class=&quot;col-xs-2 text-right&quot;&gt;&lt;%= item.account %&gt; 元&lt;/div&gt; &lt;div class=&quot;col-xs-2 text-right&quot;&gt; &lt;a href=&quot;/account/&lt;%= item.id %&gt;&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-remove&quot; aria-hidden=&quot;true&quot; &gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; create.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;添加记录&lt;/title&gt; &lt;link href=&quot;/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;link href=&quot;/css/bootstrap-datepicker.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-lg-8 col-lg-offset-2&quot;&gt; &lt;h2&gt;添加记录&lt;/h2&gt; &lt;hr /&gt; &lt;form method=&quot;post&quot; action=&quot;/account&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;item&quot;&gt;事项&lt;/label&gt; &lt;input name=&quot;title&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;item&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;time&quot;&gt;时间&lt;/label&gt; &lt;input name=&quot;time&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;time&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;type&quot;&gt;类型&lt;/label&gt; &lt;select name=&quot;type&quot; class=&quot;form-control&quot; id=&quot;type&quot;&gt; &lt;option value=&quot;-1&quot;&gt;支出&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;收入&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;account&quot;&gt;金额&lt;/label&gt; &lt;input name=&quot;account&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;account&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;remarks&quot;&gt;备注&lt;/label&gt; &lt;textarea name=&quot;remarks&quot; class=&quot;form-control&quot; id=&quot;remarks&quot; &gt;&lt;/textarea&gt; &lt;/div&gt; &lt;hr /&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-block&quot;&gt; 添加 &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/bootstrap-datepicker.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/bootstrap-datepicker.zh-CN.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意：需要将 ejs 文件中引用到的 css 和 js 文件放在静态资源 public 目录下，并将 ejs 文件中的路径设置为绝对路径 十、MongoDB1、MongoDB 基础知识MongoDB 是一个基于分布式文件存储的数据库，官方地址 https://www.mongodb.com/ 数据库（DataBase）是按照数据结构来组织、存储和管理数据的 应用程序 数据库的主要作用就是 管理数据 ，对数据进行 增（c）、删（d）、改（u）、查（r） 相比于纯文件管理数据，数据库管理数据有如下特点： 速度更快 扩展性更强 安全性更强 市面上的数据库有很多种，最常见的数据库有如下几个： MySQL 数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise） Oracle 数据库（收费） SQL Server 数据库（收费） Mongodb 数据库（Community + Enterprise） 其中，MySQL、Oracle、SQL Server 属于传统型数据库（又叫做：关系型数据库 或 SQL 数据库），这三者的 设计理念相同，用法比较类似 而 Mongodb 属于新型数据库（又叫做：非关系型数据库 或 NoSQL 数据库），它在一定程度上弥补了传统型 数据库的缺陷 Mongodb 中有三个重要概念需要掌握 数据库（database） 数据库是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存 放很多集合 集合（collection） 集合类似于 JS 中的数组，在集合中可以存放很多文档 文档（document） 文档是数据库中的最小单位，类似于 JS 中的对象 Mongodb 下载地址： https://www.mongodb.com/try/download/community 配置步骤如下: 将压缩包移动到 C:\\Program Files 下，然后解压 创建 C:\\data\\db 目录，mongodb 会将数据默认保存在这个文件夹 以 mongodb 中 bin 目录作为工作目录，启动命令行 运行命令 mongod 此时 Mongodb 的数据库服务已经启动了 重新打开一个以 mongodb 中 bin 目录作为工作目录的终端，使用 mongo 命令连接本机的 mongodb 服务 注意： 为了方便后续方便使用 mongod 命令，可以将 bin 目录配置到环境变量 Path 中 千万不要选中服务端窗口的内容 ，选中会停止服务，可以 敲回车 取消选中 2、命令行交互数据库命令 显示所有的数据库 1show dbs 切换到指定的数据库，如果数据库不存在会自动创建数据库 1use 数据库名 显示当前所在的数据库 1db 删除当前数据库 12use 库名db.dropDatabase() 集合命令 创建集合 1db.createCollection(&#x27;集合名称&#x27;) 显示当前数据库中的所有集合 1show collections 删除某个集合 1db.集合名.drop() 重命名集合 1db.集合名.renameCollection(&#x27;newName&#x27;) 文档命令 插入文档 1db.集合名.insert(文档对象) 查询文档 1db.集合名.find(查询条件) _id 是 mongodb 自动生成的唯一编号，用来唯一标识文档 更新文档 12db.集合名.update(查询条件,新的文档)db.集合名.update(&#123;name:&#x27;张三&#x27;&#125;,&#123;$set:&#123;age:19&#125;&#125;) 直接使用 db.集合名.update(查询条件,新的文档)这种方式，会覆盖式更新，因此可以使用第二种方式精确（局部）更新 删除文档 1db.集合名.remove(查询条件) 3、MongooseMongoose 是一个对象文档模型库，官网 http://www.mongoosejs.net/ 它的本质就是一个包，方便使用代码操作 mongodb 数据库。取代我们之前在终端中使用 mongo 命令行的方式操作数据库 使用流程 1234567891011121314151617181920212223242526272829303132333435//1. 安装 mongoose//2. 导入 mongooseconst mongoose = require(&quot;mongoose&quot;);//3. 连接数据库,27017是mongodb的默认端口号，可以省略。如果bilibili数据库不存在则会自动创建// mongodb是MongoDB的连接协议，正如我们之前http服务使用http协议一样，MongoDB数据库服务使用mongodb协议mongoose.connect(&quot;mongodb://127.0.0.1:27017/bilibili&quot;);//4. 设置连接回调//连接成功mongoose.connection.on(&quot;open&quot;, () =&gt; &#123; console.log(&quot;连接成功&quot;); //5. 创建文档结构对象 let BookSchema = new mongoose.Schema(&#123; title: String, author: String, price: Number, &#125;); //6. 创建文档模型对象 let BookModel = mongoose.model(&quot;book&quot;, BookSchema); //7. 插入文档 BookModel.create(&#123; title: &quot;西游记&quot;, author: &quot;吴承恩&quot;, price: 19.9, &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err));&#125;);//连接出错mongoose.connection.on(&quot;error&quot;, () =&gt; &#123; console.log(&quot;连接出错~~&quot;);&#125;);//连接关闭mongoose.connection.on(&quot;close&quot;, () =&gt; &#123; console.log(&quot;连接关闭&quot;);&#125;); 字段类型 文档结构可选的常用字段类型列表 字段值验证 Mongoose 有一些内建验证器，可以对字段值进行验证 必填项 1234title: &#123; type: String, required: true // 设置必填项&#125; 默认值 1234author: &#123; type: String, default: &#x27;匿名&#x27; //默认值&#125; 枚举值 1234gender: &#123; type: String, enum: [&#x27;男&#x27;,&#x27;女&#x27;] //设置的值必须是数组中的&#125; 唯一值 1234username: &#123; type: String, unique: true&#125; unique 需要 重建集合 才能有效果 Mongoose 操作数据库的基本操作：增加（create），删除（delete），修改（update），查（read） 增加 插入一条 1234567BookModel.create(&#123; title: &quot;西游记&quot;, author: &quot;吴承恩&quot;, price: 19.9,&#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 批量插入 1234567891011121314151617181920//批量插入BookModel.insertMany([ &#123; title: &quot;红楼梦&quot;, author: &quot;曹雪芹&quot;, price: 29.9, &#125;, &#123; title: &quot;水浒传&quot;, author: &quot;施耐庵&quot;, price: 39.9, &#125;, &#123; title: &quot;三国演义&quot;, author: &quot;罗贯中&quot;, price: 49.9, &#125;,]) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 删除 删除一条数据 1234//删除一条BookModel.deleteOne(&#123; title: &quot;红楼梦&quot; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 批量删除 1234//批量删除BookModel.deleteMany(&#123; author: &quot;罗贯中&quot; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 更新 更新一条数据 1234//更新一条BookModel.updateOne(&#123; author: &quot;罗贯中&quot; &#125;, &#123; price: 9.9 &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 批量更新数据 同上 查询 查询一条数据 1234567BookModel.findOne(&#123; name: &quot;三国演义&quot; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err));//根据id查询BookModel.findById(&#123; _id: &quot;6438c46df163eb812a612bb5&quot; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 批量查询数据 12345678//不加条件查询BookModel.find() .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err));//加条件查询BookModel.find(&#123; author: &quot;余华&quot; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 条件控制 Mongoose 中主要有运算符、 逻辑运算、正则匹配三中条件控制 运算符 在 mongodb 不能 &gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D;&#x3D; 等运算符，需要使用替代符号 &gt; 使用 $gt &lt; 使用 $lt &#x3D; 使用 $gte &lt;&#x3D; 使用 $lte !&#x3D;&#x3D; 使用 $ne 123BookModel.find(&#123; price: &#123; $gt: 60 &#125; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 逻辑运算 $or 逻辑或 123BookModel.find(&#123; $or: [&#123; author: &quot;罗贯中&quot; &#125;, &#123; price: 59.8 &#125;] &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); $and 逻辑与 123BookModel.find(&#123; $and: [&#123; price: &#123; $gt: 20 &#125; &#125;, &#123; price: &#123; $lt: 30 &#125; &#125;] &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 正则匹配 条件中可以直接使用 JS 的正则语法，通过正则可以进行模糊查询 123BookModel.find(&#123; name: /三/ &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 个性化读取 字段筛选 1234567//0:不要的字段//1:要的字段BookModel.find() .select(&#123; name: 1, author: 1 &#125;) .exec() .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 将筛选字段的条件放在 select 函数中，值为 1 表示需要筛选出来，为 0 表示该字段不需要。回调函数放在 exec 中。当然 find 函数中也可以写入筛选条件 数据排序 12345BookModel.find() .sort(&#123; price: 1 &#125;) .exec() .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); sort 函数函数中参数名表示排序的字段名，值为 1 表示升序，-1 表示降序 数据截取 12345BookModel.find() .skip(3) .limit(2) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); skip 表示跳过前 3 个，limit 表示取 2 个，因此最终取值结果为第 4 个至第 5 个 图形化管理工具 我们可以使用图形化的管理工具来对 Mongodb 进行交互 Robo 3T 免费 https://github.com/Studio3T/robomongo/releases Navicat 收费 https://www.navicat.com.cn/ Mongoose 模块化 随着业务的增多，我们可以将 Mongoose 操作分模块管理 主要思路如下： 将连接成功之后的回调函数里面的操作单独拿出来放在 index.js，剩下的内容以函数的形式进行封装放在 db 目录下的 index.js，并通过 module.exports 暴露出去 123456789101112131415161718192021module.exports = function (success, err) &#123; //1. 安装 mongoose //2. 导入 mongoose const mongoose = require(&quot;mongoose&quot;); //3. 连接数据库,27017是mongodb的默认端口号，可以省略。如果bilibili数据库不存在则会自动创建 // mongodb是MongoDB的连接协议，正如我们之前http服务使用http协议一样，MongoDB数据库服务使用mongodb协议 mongoose.connect(&quot;mongodb://127.0.0.1:27017/bilibili&quot;); //4. 设置连接回调 //连接成功 mongoose.connection.on(&quot;open&quot;, () =&gt; &#123; success(); &#125;); //连接出错 mongoose.connection.on(&quot;error&quot;, () =&gt; &#123; err(); &#125;); //连接关闭 mongoose.connection.on(&quot;close&quot;, () =&gt; &#123; console.log(&quot;连接关闭&quot;); &#125;);&#125;; index.js 引入 db&#x2F;index.js，并将连接成功之后的回调函数里面的操作作为 success 函数参数传递过去 123456789101112131415161718192021module.exports = function (success, err) &#123; //1. 安装 mongoose //2. 导入 mongoose const mongoose = require(&quot;mongoose&quot;); //3. 连接数据库,27017是mongodb的默认端口号，可以省略。如果bilibili数据库不存在则会自动创建 // mongodb是MongoDB的连接协议，正如我们之前http服务使用http协议一样，MongoDB数据库服务使用mongodb协议 mongoose.connect(&quot;mongodb://127.0.0.1:27017/bilibili&quot;); //4. 设置连接回调 //连接成功 mongoose.connection.on(&quot;open&quot;, () =&gt; &#123; success(); &#125;); //连接出错 mongoose.connection.on(&quot;error&quot;, () =&gt; &#123; err(); &#125;); //连接关闭 mongoose.connection.on(&quot;close&quot;, () =&gt; &#123; console.log(&quot;连接关闭&quot;); &#125;);&#125;; 由于随着业务的增多，后面可能会有越来越多的文档，因此我们可以将创建文档的代码继续拆分出去。在 models 目录下新建 BookModles.js 和 MovieModles.js 123456789101112131415//导入 mongooseconst mongoose = require(&quot;mongoose&quot;);//创建文档的结构对象//设置集合中文档的属性以及属性值的类型let BookSchema = new mongoose.Schema(&#123; name: String, author: String, price: Number,&#125;);//创建模型对象 对文档操作的封装对象let BookModel = mongoose.model(&quot;books&quot;, BookSchema);//暴露模型对象module.exports = BookModel; 1234567891011121314//导入 mongooseconst mongoose = require(&quot;mongoose&quot;);// 创建文档结构const MovieSchema = new mongoose.Schema(&#123; title: String, director: String,&#125;);//创建模型对象const MovieModel = mongoose.model(&quot;movie&quot;, MovieSchema);//暴露module.exports = MovieModel; index.js 主文件中引入 12345678910111213141516171819202122232425262728293031323334//导入 db 文件const db = require(&quot;./db/db&quot;);//导入 mongooseconst mongoose = require(&quot;mongoose&quot;);//导入 BookModelconst BookModel = require(&quot;./models/BookModel&quot;);// 调用函数db( () =&gt; &#123; //7. 新增 BookModel.create( &#123; name: &quot;西游记&quot;, author: &quot;吴承恩&quot;, price: 19.9, &#125;, (err, data) =&gt; &#123; //判断是否有错误 if (err) &#123; console.log(err); return; &#125; //如果没有出错, 则输出插入后的文档对象 console.log(data); //8. 关闭数据库连接 (项目运行过程中, 不会添加该代码) mongoose.disconnect(); &#125; ); &#125;, () =&gt; &#123; console.log(&quot;连接失败...&quot;); &#125;); 接下来 db 目录下的 index.js 中我们连接的数据库地址和集合名称是写死的，我们可以新建一个 config&#x2F;config.js 文件单独进行配置 123456//配置文件module.exports = &#123; DBHOST: &quot;127.0.0.1&quot;, DBPORT: 27017, DBNAME: &quot;bilibili&quot;,&#125;; db 下的 index.js 12345678910111213141516171819202122232425262728293031323334/** * * @param &#123;*&#125; success 数据库连接成功的回调 * @param &#123;*&#125; error 数据库连接失败的回调 */module.exports = function (success, error) &#123; //1. 安装 mongoose //2. 导入 mongoose const mongoose = require(&quot;mongoose&quot;); //导入 配置文件 const &#123; DBHOST, DBPORT, DBNAME &#125; = require(&quot;../config/config.js&quot;); //设置 strictQuery 为 true mongoose.set(&quot;strictQuery&quot;, true); //3. 连接 mongodb 服务 数据库的名称 mongoose.connect(`mongodb://$&#123;DBHOST&#125;:$&#123;DBPORT&#125;/$&#123;DBNAME&#125;`); //4. 设置回调 // 设置连接成功的回调 once 一次 事件回调函数只执行一次 mongoose.connection.once(&quot;open&quot;, () =&gt; &#123; success(); &#125;); // 设置连接错误的回调 mongoose.connection.on(&quot;error&quot;, () =&gt; &#123; error(); &#125;); //设置连接关闭的回调 mongoose.connection.on(&quot;close&quot;, () =&gt; &#123; console.log(&quot;连接关闭&quot;); &#125;);&#125;; 接下来可以对之前做过的账单案例进行优化了。将数据库的操作应用到案例中 十一、接口接口是 前后端通信的桥梁 简单理解：一个接口就是 服务中的一个路由规则 ，根据请求响应结果 一般情况下，接口返回的都是 json 格式 RESTful API RESTful API 是一种特殊风格的接口，主要特点有如下几个： URL 中的路径表示 资源 ，路径中不能有 动词 ，例如 create , delete , update 等这些都不能有 操作资源要与 HTTP 请求方法对应 操作结果要与 HTTP 响应状态码对应 规则示例： 扩展阅读：https://www.ruanyifeng.com/blog/2014/05/restful_api.html 基于 RESTful API 我们可以给之前的账单案例添加 API 接口 在 routes 目录下新建 web 文件夹（专门用来存放路由文件），将原来 routes 下的 index.js 文件放到 web 文件夹下。在 routes 目录下新建 api 文件夹（专门用来存放对外的 api 接口文件），并将 index.js 文件中的内容复制一份，方便我们进行改造 在 app.js 中引入 account.js 接口文件，并配置中间件，这样外部就可以通过&#x2F;api&#x2F;xxx 来访问接口了 12const accountRouter = require(&quot;./routes/api/account&quot;);app.use(&quot;/api&quot;, accountRouter); 接下来我们对 account.js 进行改造即可 获取账单列表接口 12345678910111213141516171819router.get(&quot;/account&quot;, checkToken, function (req, res, next) &#123; AccountModel.find() .sort(&#123; time: -1 &#125;) .exec() .then((data) =&gt; res.json(&#123; code: &quot;0000&quot;, msg: &quot;读取成功&quot;, data: data, &#125;) ) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1001&quot;, msg: &quot;读取失败&quot;, data: null, &#125;); &#125;);&#125;); 添加账单记录接口 1234567891011121314151617router.post(&quot;/account&quot;, checkToken, function (req, res, next) &#123; AccountModel.create(req.body) .then((data) =&gt; &#123; res.json(&#123; code: &quot;0000&quot;, msg: &quot;新增成功&quot;, data: data, &#125;); &#125;) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1002&quot;, msg: &quot;新增失败&quot;, data: null, &#125;); &#125;);&#125;); 删除账单记录接口 1234567891011121314151617router.delete(&quot;/account/:id&quot;, checkToken, function (req, res, next) &#123; AccountModel.deleteOne(&#123; _id: req.params.id &#125;) .then(() =&gt; &#123; res.json(&#123; code: &quot;0000&quot;, msg: &quot;删除成功&quot;, data: null, &#125;); &#125;) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1003&quot;, msg: &quot;删除失败&quot;, data: null, &#125;); &#125;);&#125;); 获取单条账单记录接口 123456789101112131415161718//获取单条记录router.get(&quot;/account/:id&quot;, checkToken, function (req, res, next) &#123; AccountModel.find(&#123; _id: req.params.id &#125;) .then((data) =&gt; &#123; res.json(&#123; code: &quot;0000&quot;, msg: &quot;获取成功&quot;, data: data, &#125;); &#125;) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1004&quot;, msg: &quot;获取失败&quot;, data: null, &#125;); &#125;);&#125;); 更新账单接口 1234567891011121314151617router.patch(&quot;/account/:id&quot;, checkToken, function (req, res, next) &#123; AccountModel.updateOne(&#123; _id: req.params.id &#125;, req.body) .then((data) =&gt; &#123; res.json(&#123; code: &quot;0000&quot;, msg: &quot;更新成功&quot;, data: data, &#125;); &#125;) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1005&quot;, msg: &quot;更新失败&quot;, data: null, &#125;); &#125;);&#125;); 注意 patch 是局部更新，而 put 是覆盖式更新 以上接口均可以通过接口测试工具去测试是否正常。 在之前的 res 响应中，我们都是通过 res.render 去响应一个页面。而接口则是只需响应一个 json（一般情况下）格式的数据即可。由前端拿到数据后去做进一步的处理，最终呈现页面。 十二、会话控制1、Web 开发模式目前主流的 Web 开发模式有两种，分别是： 基于服务端渲染的传统 Web 开发模式 基于前后端分离的新型 Web 开发模式 服务端渲染的传统 Web 开发模式：服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接，动态生成的（或者模板引擎 ejs）。因此，客户端不需要使用 Ajax 这样的技术额外请求页面的数据 服务端渲染的优缺点 优点： 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电 有利于 SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO 缺点： 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于 项目高效开发 前后端分离的 Web 开发模式：依赖于 Ajax 技术的广泛应用。简而言之，前后端分离的 Web 开发模式， 就是后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式 前后端分离的优缺点 优点： 开发体验好。前端专注于 UI 页面的开发，后端专注于 api 的开发，且前端有更多的选择性 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的 缺点： 不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方 案：利用 Vue、React 等前端框架的 SSR （server side render）技术能够很好的解决 SEO 问题！） 如何选择 Web 开发模式 不谈业务场景而盲目选择使用何种开发模式都是耍流氓。 比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染 而类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式 另外，具体使用何种开发模式并不是绝对的，为了同时兼顾了首页的渲染速度和前后端分离的开发效率，一些网站采用了 首屏服务器端渲染 + 其他页面前后端分离的开发模式 HTTP 是一种无状态的协议。所谓 HTTP 协议的无状态性，指的是客户端的每次 HTTP 请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次 HTTP 请求的状态。因此它没有办法区分多次的请求是否来自于同一个客户端， 无法区分用户 而产品中又大量存在的这样的需求，所以我们需要通过 会话控制 来解决该问题 常见的会话控制技术有三种： cookie session token 对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案： 服务端渲染推荐使用 Session 认证机制 前后端分离推荐使用 JWT 认证机制 2、CookieCookie 是 HTTP 服务器发送到用户浏览器并存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用 于控制 Cookie 有效期、安全性、使用范围的可选属性组成。 不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器 客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动 将 Cookie 保存在浏览器中 随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给 服务器，服务器即可验明客户端的身份 Cookie 就像我们去办某个店的会员，当我们成为会员之后，店子会给我们发一张会员卡。后续我们出示会员卡来店即可认证我们的身份 express 中可以使用 cookie-parser 操作 cookie 12345678910111213141516171819202122232425262728293031323334const express = require(&quot;express&quot;);//1. 安装 cookie-parser npm i cookie-parser//2. 引入 cookieParser 包const cookieParser = require(&quot;cookie-parser&quot;);const app = express();//3. 设置 cookieParser 中间件app.use(cookieParser());//4-1 设置 cookieapp.get(&quot;/set-cookie&quot;, (request, response) =&gt; &#123; // 不带时效性 response.cookie(&quot;username&quot;, &quot;wangwu&quot;); // 带时效性 response.cookie(&quot;email&quot;, &quot;23123456@qq.com&quot;, &#123; maxAge: 5 * 60 * 1000 &#125;); //响应 response.send(&quot;Cookie的设置&quot;);&#125;);//4-2 读取 cookieapp.get(&quot;/get-cookie&quot;, (request, response) =&gt; &#123; //读取 cookie console.log(request.cookies); //响应体 response.send(&quot;Cookie的读取&quot;);&#125;);//4-3 删除cookieapp.get(&quot;/delete-cookie&quot;, (request, response) =&gt; &#123; //删除 response.clearCookie(&quot;username&quot;); //响应 response.send(&quot;cookie 的清除&quot;);&#125;);//4. 启动服务app.listen(3000, () =&gt; &#123; console.log(&quot;服务已经启动....&quot;);&#125;); 3、Session由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全 性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器 为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，还要在收银机上进行刷卡认证。只有收银机确认存在的 会员卡，才能被正常使用 这种“会员卡 + 刷卡认证”的设计理念，就是 Session 认证机制的精髓 express 中可以使用 express-session 对 session 进行操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const express = require(&quot;express&quot;);//1. 安装包 npm i express-session connect-mongo//2. 引入 express-session connect-mongoconst session = require(&quot;express-session&quot;);const MongoStore = require(&quot;connect-mongo&quot;);const app = express();//3. 设置 session 的中间件app.use( session(&#123; name: &quot;sid&quot;, //设置cookie的name，默认值是：connect.sid secret: &quot;atguigu&quot;, //参与加密的字符串（又称签名） saveUninitialized: false, //是否为每次请求都设置一个cookie用来存储session的id resave: true, //是否在每次请求时重新保存session store: MongoStore.create(&#123; mongoUrl: &quot;mongodb://127.0.0.1:27017/project&quot;, //数据库的连接配置 &#125;), cookie: &#123; httpOnly: true, // 开启后前端无法通过 JS 操作 maxAge: 1000 * 300, // 这一条 是控制 sessionID 的过期时间的！！！ &#125;, &#125;));//创建 sessionapp.get(&quot;/login&quot;, (req, res) =&gt; &#123; //设置session req.session.username = &quot;zhangsan&quot;; req.session.email = &quot;zhangsan@qq.com&quot;; res.send(&quot;登录成功&quot;);&#125;);//获取 sessionapp.get(&quot;/home&quot;, (req, res) =&gt; &#123; console.log(&quot;session的信息&quot;); console.log(req.session.username); if (req.session.username) &#123; res.send(`你好 $&#123;req.session.username&#125;`); &#125; else &#123; res.send(&quot;登录 注册&quot;); &#125;&#125;);//销毁 sessionapp.get(&quot;/logout&quot;, (req, res) =&gt; &#123; //销毁session // res.send(&#x27;设置session&#x27;); req.session.destroy(() =&gt; &#123; res.send(&quot;成功退出&quot;); &#125;);&#125;);app.listen(3000, () =&gt; &#123; console.log(&quot;服务已经启动, 端口 &quot; + 3000 + &quot; 监听中...&quot;);&#125;); session 和 cookie 的区别 存储的位置。cookie：浏览器端，session：服务端 安全性。cookie 是以明文的方式存放在客户端的，安全性相对较低。session 存放于服务器中，所以安全性 相对 较好 网络传输量。cookie 设置内容过多会增大报文体积， 会影响传输效率。session 数据存储在服务器，只是通过 cookie 传递 id，所以不影响传输效率 存储限制。浏览器限制单个 cookie 保存的数据不能超过 4K ，且单个域名下的存储数量也有限制。session 数据存储在服务器中，所以没有这些限制 4、完善账单案例接下来我们可以对账单案例添加权限认证的功能 在 views 目录下新建登录和注册页面 reg.ejs 和 login.ejs 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;注册&lt;/title&gt; &lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-md-8 col-md-offset-2 col-lg-4 col-lg-offset-4&quot;&gt; &lt;h2&gt;注册&lt;/h2&gt; &lt;hr /&gt; &lt;form method=&quot;post&quot; action=&quot;/reg&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;item&quot;&gt;用户名&lt;/label&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;item&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;time&quot;&gt;密码&lt;/label&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;time&quot; /&gt; &lt;/div&gt; &lt;hr&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-block&quot;&gt;注册&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在 routes&#x2F;web 目录下新建 user.js 用来存放用户登录、注册、退出相关的路由，并配置路由规则 1234567891011121314151617181920212223242526272829303132333435363738var express = require(&quot;express&quot;);// 引入md5对密码进行加密const md5 = require(&quot;md5&quot;);var router = express.Router();const UserModel = require(&quot;../../Models/UserModel&quot;);//注册页面router.get(&quot;/reg&quot;, (req, res) =&gt; &#123; res.render(&quot;reg&quot;);&#125;);// 提交注册表单router.post(&quot;/reg&quot;, (req, res) =&gt; &#123; // 使用md5对密码进行加密，存储到数据库中 UserModel.create(&#123; ...req.body, password: md5(req.body.password) &#125;) .then(() =&gt; &#123; res.render(&quot;success&quot;, &#123; msg: &quot;注册成功&quot;, url: &quot;/login&quot; &#125;); &#125;) .catch(() =&gt; &#123; res.render(&quot;error&quot;); &#125;);&#125;);//登录页面router.get(&quot;/login&quot;, (req, res) =&gt; &#123; res.render(&quot;login&quot;);&#125;);//提交登录表单router.post(&quot;/login&quot;, (req, res) =&gt; &#123; const &#123; username, password &#125; = req.body; // 用户提交的账号密码跟数据库存储的账号密码进行比对 UserModel.findOne(&#123; username: username, password: md5(password) &#125;) .then((data) =&gt; &#123; if (!data) return res.render(&quot;error&quot;); res.render(&quot;success&quot;, &#123; msg: &quot;登录成功&quot;, url: &quot;/account&quot; &#125;); &#125;) .catch(() =&gt; &#123; res.render(&quot;error&quot;); &#125;);&#125;);module.exports = router; Models 目录下新建 UserModel.js 用来存放用户登录的账户密码 123456789101112131415const mongoose = require(&quot;mongoose&quot;);//创建文档结构对象let UserSchema = new mongoose.Schema(&#123; username: &#123; type: String, required: true, &#125;, password: &#123; type: String, required: true, &#125;,&#125;);//6. 创建文档模型对象let UserModel = mongoose.model(&quot;user&quot;, UserSchema);module.exports = UserModel; 最后 app.js 引入并注册新建的路由规则，这样一个简单的登录注册功能就实现了 接下来我们需要进行 Session 身份认证 在 app.js 中设置 session 的中间件 12345678910111213141516171819// 引入 express-session connect-mongoconst session = require(&quot;express-session&quot;);const MongoStore = require(&quot;connect-mongo&quot;);//设置 session 的中间件app.use( session(&#123; name: &quot;sid&quot;, //设置cookie的name，默认值是：connect.sid secret: &quot;iloveyou&quot;, //参与加密的字符串（又称签名） saveUninitialized: false, //是否为每次请求都设置一个cookie用来存储session的id resave: true, //是否在每次请求时重新保存session store: MongoStore.create(&#123; mongoUrl: &quot;mongodb://127.0.0.1:27017/bilibili&quot;, //数据库的连接配置 &#125;), cookie: &#123; httpOnly: true, // 开启后前端无法通过 JS 操作 maxAge: 1000 * 60 * 60 * 24, // 这一条 是控制 sessionID 的过期时间的！！！ &#125;, &#125;)); 登录成功后写入 session user.js 中 1234567891011121314//提交登录表单router.post(&quot;/login&quot;, (req, res) =&gt; &#123; const &#123; username, password &#125; = req.body; UserModel.findOne(&#123; username: username, password: md5(password) &#125;) .then((data) =&gt; &#123; if (!data) return res.render(&quot;error&quot;); // 登录成功写入session req.session.username = username; res.render(&quot;success&quot;, &#123; msg: &quot;登录成功&quot;, url: &quot;/account&quot; &#125;); &#125;) .catch(() =&gt; &#123; res.render(&quot;error&quot;); &#125;);&#125;); 但是截至到现在，我们只是做了 session 写入，并没有做 session 验证。此时仍然可以通过浏览器地址栏输入路径直接访问账单列表页、并对其进行新增和删除操作。因此我们还需要一个 session 验证的中间件 新建文件夹 MiddleWare，并在此文件夹下新建 sessionLogin.js 12345// 设置页面访问session验证的中间件module.exports = function (req, res, next) &#123; if (!req.session.username) return res.redirect(&quot;/login&quot;); next();&#125;; 在 routes&#x2F;web&#x2F;index.js 引入上述中间件并为需要的页面单独添加路由中间件即可。此时，若我们没有登录，直接通过浏览器地址栏输入账单页面的 url 是无法访问的 5、CSRFCSRF（Cross Site Request Forgery，跨站域请求伪造），也被称为 “One Click Attack” 或者 Session Riding，通常缩写为 CSRF 或者 XSRF 原理 前面我们提到，不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。然而相同域名和协议下不同端口之间的 cookie 是共享的。这是因为 cookie 存储在客户端的浏览器中，而不是在服务器中，因此不同的端口只是访问同一个服务器的不同入口，它们共享同一个 cookie 存储空间 CSRF 攻击就是利用了浏览器在同一域名下共享 cookie 的特性，从而让攻击者能够携带合法用户的 cookie 发送恶意请求，冒充合法用户执行一些操作 更多 CSRF 攻击知识请参考https://blog.csdn.net/weixin_44211968/article/details/124703525 6、JWT 认证机制Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接 口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。于是就引出了 token token 是服务端生成并返回给 HTTP 客户端的一串加密字符串， token 中保存着 用户信息 token 的特点 服务端压力更小（数据存储在客户端） 相对更安全（数据加密、可以避免 CSRF（跨站请求伪造）） 扩展性更强（服务间可以共享、增加服务节点更简单） JWT JWT（JSON Web Token ）是目前最流行的跨域认证解决方案，可用于基于 token 的身份验证 JWT 的工作原理 总结：用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份 JWT 的使用方式 客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中 此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP 请求头的 Authorization 字段中，格式如下： 1Authorization:Bearer &lt;token&gt; express 中使用 jsonwebtoken 包来操作 token 123456789101112131415161718192021//导入 jsonwebtokanconst jwt = require(&quot;jsonwebtoken&quot;);//创建 token// jwt.sign(数据, 加密字符串, 配置对象)let token = jwt.sign( &#123; username: &quot;zhangsan&quot;, &#125;, &quot;iloveyou&quot;, &#123; expiresIn: 60, //过期时间 单位是 秒 &#125;);//解析 tokenjwt.verify(token, &quot;atguigu&quot;, (err, data) =&gt; &#123; if (err) &#123; console.log(&quot;校验失败~~&quot;); return; &#125; console.log(data);&#125;); 更多 JWT 相关知识请参考https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html 完善账单案例 接下来我们可以使用 JWT 认证机制完善账单案例的 API 接口了。之前我们所写的接口，能够直接去访问。现在我们希望必须在 token 检验通过后才能访问接口 在 routes&#x2F;api 下新建 auth.js。配置登录的 api 接口，登录成功设置 token 123456789101112131415161718192021222324252627282930313233343536373839404142434445const express = require(&quot;express&quot;);const md5 = require(&quot;md5&quot;);const UserModel = require(&quot;../../Models/UserModel&quot;);//导入 jsonwebtokanconst jwt = require(&quot;jsonwebtoken&quot;);const router = express.Router();//提交登录表单router.post(&quot;/login&quot;, (req, res) =&gt; &#123; const &#123; username, password &#125; = req.body; UserModel.findOne(&#123; username: username, password: md5(password) &#125;) .then((data) =&gt; &#123; if (!data) &#123; res.json(&#123; code: &quot;1006&quot;, msg: &quot;用户名或密码错误&quot;, data: null, &#125;); return; &#125; // 登录成功创建token // jwt.sign(数据, 加密字符串, 配置对象) let token = jwt.sign( &#123; username: &quot;username&quot;, &#125;, &quot;iloveyou&quot;, &#123; expiresIn: 60 * 60 * 24, //过期时间 单位是 秒 &#125; ); res.json(&#123; code: &quot;0000&quot;, msg: &quot;登录成功&quot;, data: token, &#125;); &#125;) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1007&quot;, msg: &quot;登录失败&quot;, data: null, &#125;); &#125;);&#125;);module.exports = router; 接下来在 MiddleWare 目录下新建 checkToken.js 12345678910111213141516171819202122232425//导入 jwtconst jwt = require(&quot;jsonwebtoken&quot;);module.exports = (req, res, next) =&gt; &#123; const token = req.get(&quot;token&quot;); if (!token) &#123; res.json(&#123; code: &quot;1008&quot;, msg: &quot;token缺失&quot;, data: null, &#125;); return; &#125; //校验token jwt.verify(token, &quot;iloveyou&quot;, (err, data) =&gt; &#123; if (err) &#123; res.json(&#123; code: &quot;1008&quot;, msg: &quot;token验证失败&quot;, data: null, &#125;); return; &#125; next(); &#125;);&#125;; 最后在 api&#x2F;account.js 的 api 路由规则中使用该路由中间件即可。在 APIFOX 中测试，此时必须在 headers 中添加 token 才能访问 API 接口 十二、项目上线部署1、购买云服务器以阿里云为例，购买成功后 2、连接云服务器 复制我们上面购买的云服务器的公网 IP 地址 桌面-开始菜单-搜索远程桌面连接 输入复制的公网 IP 地址连接云服务器 3、安装软件在云服务器上安装 git、node、MongoDB 4、启动项目 在云服务器 C 盘新建 www 文件夹 在 www 文件夹下运行终端命令，将项目从远程仓库克隆下来 安装项目依赖 启动项目（确保 MongoDB 的服务也已经启动） 在云服务器的浏览器地址栏输入http://127.0.0.1:3000，我们会发现此时项目已经启动了。而且，我们在其他任何一台接入互联网的电脑上输入云服务器的公网IP，都可以访问到我们的项目 5、域名购买与解析阿里云购买域名 购买完成，打开域名控制台，等待购买的域名状态审核通过后点击解析，将云服务器的 IP 地址与域名做映射关联 添加记录，记录值就是云服务器的 IP 地址 配置完成后，即可通过主机记录对应的域名访问我们的项目了 当然，除了 Nodejs server，我们还可以将项目部署在 Nginx、Apache、Tomcat、IIS 等 web 服务器上。他们都可以向外提供 web 服务","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"我的前端学习资源汇总","slug":"我的前端学习资源汇总","date":"2023-03-27T03:23:37.000Z","updated":"2023-03-27T05:59:33.345Z","comments":true,"path":"2023/03/27/我的前端学习资源汇总/","link":"","permalink":"https://congtf.top/2023/03/27/%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/","excerpt":"","text":"本篇本章是想将我前端之路上的各种资源，包括视频、博客、网站、我自己电脑常用的软件进行归纳整理备份。虽然谷歌浏览器相关的已经和我的谷歌账号绑定了，vscode 相关的也和 github 账号绑定了。但还是手动备份一份心里踏实一些。 一、常用软件浏览器：Chrome、Edge、Firefox Chrome 浏览器插件：Vue.js devtools、iGG 谷歌学术助手、RSS Reader Extension 代码编辑器：VSCode VSCode 插件：any-rule、Atom One Dark Theme、Auto Rename Tag、ChatGPT 中文版、Chinese（Simplified）（简体中文）、Code Runner、Codeif、Easy LESS、Error Lens、ESLint、HTML CSS Support、JavaScript（ES6）code snippets、jQuery Code Snippets、Live Server、Material Icon Theme、open in browser、Prettier-Code formatter、px to rem&amp;rpx&amp;vw（cssrem）、vscode-icons、Vue Language Features (Volar)、VueHelper、Vetur VSCode 字体：Fira Code VSCode 中 settings.json 设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&#123; &quot;editor.formatOnSave&quot;: true, &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;, &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;, &quot;liveServer.settings.donotShowInfoMsg&quot;: true, &quot;workbench.colorCustomizations&quot;: &#123; &quot;editor.lineHighlightBackground&quot;: &quot;#1073cf2d&quot;, &quot;editor.lineHighlightBorder&quot;: &quot;#9fced11f&quot; &#125;, &quot;editor.wordWrap&quot;: &quot;off&quot;, &quot;diffEditor.wordWrap&quot;: &quot;off&quot;, &quot;editor.guides.bracketPairs&quot;: false, &quot;liveServer.settings.CustomBrowser&quot;: &quot;chrome&quot;, &quot;code-runner.runInTerminal&quot;: true, &quot;vsicons.dontShowNewVersionMessage&quot;: true, &quot;emmet.triggerExpansionOnTab&quot;: true, &quot;explorer.confirmDelete&quot;: false, &quot;editor.inlayHints.enabled&quot;: &quot;on&quot;, &quot;less.compile&quot;: &#123; &quot;out&quot;: &quot;../css/&quot; &#125;, &quot;cssrem.rootFontSize&quot;: 80, &quot;cssrem.vwDesign&quot;: 1920, &quot;vetur.completion.scaffoldSnippetSources&quot;: &#123; &quot;workspace&quot;: &quot;💼&quot;, &quot;user&quot;: &quot;🗒️&quot;, &quot;vetur&quot;: &quot;✌&quot; &#125;, &quot;emmet.syntaxProfiles&quot;: &#123; &quot;vue-html&quot;: &quot;html&quot;, &quot;vue&quot;: &quot;html&quot; &#125;, //vue自动补全 &quot;files.associations&quot;: &#123; &quot;*.vue&quot;: &quot;vue&quot;, &quot;*.ejs&quot;: &quot;html&quot;, &quot;*.js&quot;: &quot;javascript&quot; &#125;, &quot;vetur.experimental.templateInterpolationService&quot;: true, &quot;vetur.validation.interpolation&quot;: false, &quot;workbench.tree.renderIndentGuides&quot;: &quot;always&quot;, &quot;workbench.tree.indent&quot;: 18, &quot;workbench.preferredHighContrastLightColorTheme&quot;: &quot;Default Dark+&quot;, &quot;workbench.preferredLightColorTheme&quot;: &quot;Default Dark+&quot;, &quot;eslint.enable&quot;: true, &quot;eslint.run&quot;: &quot;onType&quot;, &quot;eslint.options&quot;: &#123; &quot;extensions&quot;: [&quot;.js&quot;, &quot;.vue&quot;, &quot;.jsx&quot;, &quot;.tsx&quot;] &#125;, &quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll.eslint&quot;: true &#125;, &quot;workbench.colorTheme&quot;: &quot;Atom One Dark&quot;, &quot;editor.tokenColorCustomizations&quot;: &#123; &quot;comments&quot;: &#123; // 设置字体样式 加粗 下划线 斜体等 &quot;fontStyle&quot;: &quot;italic&quot;, // 设置字体颜色 &quot;foreground&quot;: &quot;#4CAEE2&quot; &#125;, // 注释 &quot;keywords&quot;: &quot;#0a0&quot;, // 关键字 &quot;variables&quot;: &quot;#f00&quot;, // 变量名 &quot;strings&quot;: &quot;#e2d75dbd&quot;, // 字符串 &quot;functions&quot;: &quot;#5b99fcc9&quot;, // 函数名 &quot;numbers&quot;: &quot;#AE81FF&quot; // 数字 &#125;, &quot;prettier.trailingComma&quot;: &quot;es5&quot;, &quot;[vue]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[html]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;editor.fontLigatures&quot;: true, &quot;editor.fontVariations&quot;: false, &quot;settingsSync.ignoredSettings&quot;: [&quot;terminal.integrated.fontFamily&quot;], &quot;editor.fontFamily&quot;: &quot;Fira Code&quot;, &quot;http.proxyAuthorization&quot;: null, &quot;vetur.format.defaultFormatter.js&quot;: &quot;prettier-eslint&quot;, &quot;vetur.format.defaultFormatterOptions&quot;: &#123; &quot;prettier&quot;: &#123; &quot;singleQuote&quot;: true, //用单引号 &quot;semi&quot;: false //不加分号 &#125; &#125;, &quot;editor.inlineSuggest.enabled&quot;: true&#125; 文档笔记：Typora 插件&#x2F;应用：uTools、PxCook 像素大厨 截图工具：snipaste 翻译工具：有道词典 VPN：目前用的红海 API 接口测试工具：Postman、ApiFox 画图工具：DiagramDesigner、draw.io JSON 格式化工具：Notepad++、Notepad– github 加速工具：FastGithub、SwitchHosts 数据库管理工具：Navicat 版本控制：git 运行环境：Node.js（自带 npm）、NVM 切换 node 版本、nodemon 查看 npm 包：https://www.npmjs.com/ Web 开发框架：Express 前端框架：Vue 二、常用网站Vue：https://cn.vuejs.org/ ElementUI：https://element.eleme.cn/#/zh-CN MDN：https://developer.mozilla.org/zh-CN/ GitHub：https://github.com/ 稀土掘金：https://juejin.cn/ 书栈网：https://www.bookstack.cn/ Vant：https://vant-ui.github.io/vant/?#/zh-CN NutUI：https://nutui.jd.com/#/ 查询兼容性：https://caniuse.com/ 在线工具：https://tool.lu/ lodash 工具库：https://www.lodashjs.com/ 字体图标：https://www.iconfont.cn/ 腾讯云：https://cloud.tencent.com/ 三、学习资源前端入门： pink 老师前端入门教程：https://www.bilibili.com/video/BV14J4114768 ES6： https://es6.ruanyifeng.com/ Vue2+Vue3 尚硅谷张天禹老师：https://www.bilibili.com/video/BV1Zy4y1K7SH/?spm_id_from=333.337.search-card.all.click Vue3+TS 快速上手：https://24kcs.github.io/vue3_study/ 四、常用插件移动端 REM 适配： postcss-pxtorem 是一款 postcss 插件，用于将单位转化为 rem lib-flexible 用于设置 rem 基准值 移动端 vw 适配：postcss-px-to-viewport 网络请求：axios 时间处理： Moment.js Day.js 文章样式处理：github-markdown-css 图片裁切处理：cropper.js 后台前端解决方案:vue-element-admin Excel 导入导出：js-xlsx 图片地址生成二维码:qrcode 打印：vue-print-nb 数据持久化：vuex-persistedstate","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"两种移动端适配方案","slug":"两种移动端适配方案","date":"2023-03-12T08:25:19.000Z","updated":"2024-03-12T08:26:17.052Z","comments":true,"path":"2023/03/12/两种移动端适配方案/","link":"","permalink":"https://congtf.top/2023/03/12/%E4%B8%A4%E7%A7%8D%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/","excerpt":"","text":"一、lib-flexible+postcss-pxtorem在相当长一段时间里，这两个插件搭配都是解决移动端布局的神器，lib-flexible是阿里手淘系开源的一个库，用于设置 font-size，同时处理一些窗口缩放的问题。直到今天，这个方案仍是解决移动端布局的主流方案。 postcss-pxtorem 是一款 postcss 插件，用于将单位转化为 rem lib-flexible 用于设置 rem 基准值 下面我们分别将这两个工具配置到项目中完成 REM 适配。 1.1使用 lib-flexible 动态设置 REM 基准值（html 标签的字体大小）1、安装 12# yarn add amfe-flexiblenpm i amfe-flexible 2、然后在 main.js 中加载执行该模块 1import &quot;amfe-flexible&quot;; 最后测试：在浏览器中切换不同的手机设备尺寸，观察 html 标签 font-size 的变化。 1.2使用 postcss-pxtorem 将 px 转为 rem1、安装 123# yarn add -D postcss-pxtorem# -D 是 --save-dev 的简写npm install postcss-pxtorem -D 2、然后在项目根目录中创建 .postcssrc.js 文件 1234567891011module.exports = &#123; plugins: &#123; autoprefixer: &#123; browsers: [&quot;Android &gt;= 4.0&quot;, &quot;iOS &gt;= 8&quot;], &#125;, &quot;postcss-pxtorem&quot;: &#123; rootValue: 37.5, propList: [&quot;*&quot;], &#125;, &#125;,&#125;; 3、配置完毕，重新启动服务 最后测试：刷新浏览器页面，审查元素的样式查看是否已将 px 转换为 rem。 需要注意的是： 该插件**不能转换行内样式中的 px**，例如 &lt;div style=&quot;width: 200px;&quot;&gt;&lt;/div&gt; 1.3 关于 .postcssrc.js 配置文件1234567891011module.exports = &#123; plugins: &#123; autoprefixer: &#123; browsers: [&quot;Android &gt;= 4.0&quot;, &quot;iOS &gt;= 8&quot;], &#125;, &quot;postcss-pxtorem&quot;: &#123; rootValue: 37.5, propList: [&quot;*&quot;], &#125;, &#125;,&#125;; .postcssrc.js 是 PostCSS 的配置文件。 （1）PostCSS 介绍 PostCSS 是一个处理 CSS 的处理工具，本身功能比较单一，它主要负责解析 CSS 代码，再交由插件来进行处理，它的插件体系非常强大，所能进行的操作是多种多样的，例如： Autoprefixer 插件可以实现自动添加浏览器相关的声明前缀 PostCSS Preset Env 插件可以让你使用更新的 CSS 语法特性并实现向下兼容 postcss-pxtorem 可以实现将 px 转换为 rem … 目前 PostCSS 已经有 200 多个功能各异的插件。开发人员也可以根据项目的需要，开发出自己的 PostCSS 插件。 PostCSS 一般不单独使用，而是与已有的构建工具进行集成。 Vue CLI 默认集成了 PostCSS，并且默认开启了 autoprefixer 插件。 Vue CLI 内部使用了 PostCSS。 你可以通过 .postcssrc 或任何 postcss-load-config 支持的配置源来配置 PostCSS。也可以通过 vue.config.js 中的 css.loaderOptions.postcss 配置 postcss-loader。 我们默认开启了 autoprefixer。如果要配置目标浏览器，可使用 package.json 的 browserslist 字段。 （2）Autoprefixer 插件的配置 autoprefixer 是一个自动添加浏览器前缀的 PostCss 插件，browsers 用来配置兼容的浏览器版本信息，但是写在这里的话会引起编译器警告。 1234567891011Replace Autoprefixer browsers option to Browserslist config.Use browserslist key in package.json or .browserslistrc file.Using browsers option can cause errors. Browserslist configcan be used for Babel, Autoprefixer, postcss-normalize and other tools.If you really need to use option, rename it to overrideBrowserslist.Learn more at:https://github.com/browserslist/browserslist#readmehttps://twitter.com/browserslist 警告意思就是说你应该将 browsers 选项写到 package.json 或 .browserlistrc 文件中。 123456[Android]&gt;= 4.0[iOS]&gt;= 8 具体语法请参考这里。 （3）postcss-pxtorem 插件的配置 rootValue：表示根元素字体大小，它会根据根元素大小进行单位转换 propList 用来设定可以从 px 转为 rem 的属性 例如 * 就是所有属性都要转换，width 就是仅转换 width 属性 rootValue 应该如何设置呢？ 12如果你使用的是基于 lib-flexable 的 REM 适配方案，则应该设置为你的设计稿的十分之一。例如设计稿是 750 宽，则应该设置为 75。 大多数设计稿的原型都是以 iphone6 为原型，iphone6 设备的宽是 750，我们的设计稿也是这样。 但是 Vant 建议设置为 37.5，为什么呢？ 1因为 Vant 是基于 375 写的，所以如果你设置为 75 的话，Vant 的样式就小了一半。 所以如果设置为 37.5 的话，Vant 的样式是没有问题的，但是我们在测量设计稿的时候都必须除 2 才能使用，否则就会变得很大。 这样做其实也没有问题，但是有没有更好的办法呢？我就想实现测量多少写多少（不用换算）。于是聪明的你就想，可以不可以这样来做？ 如果是 Vant 的样式，就把 rootValue 设置为 37.5 来转换 如果是我们的样式，就按照 75 的 rootValue 来转换 通过查阅文档我们可以看到 rootValue 支持两种参数类型： 数字：固定值 函数：动态计算返回 postcss-pxtorem 处理每个 CSS 文件的时候都会来调用这个函数 它会把被处理的 CSS 文件相关的信息通过参数传递给该函数 所以我们修改配置如下： 1234567891011121314151617181920212223242526/** * PostCSS 配置文件 */module.exports = &#123; // 配置要使用的 PostCSS 插件 plugins: &#123; // 配置使用 autoprefixer 插件 // 作用：生成浏览器 CSS 样式规则前缀 // VueCLI 内部已经配置了 autoprefixer 插件 // 所以又配置了一次，所以产生冲突了 // &#x27;autoprefixer&#x27;: &#123; // autoprefixer 插件的配置 // // 配置要兼容到的环境信息 // browsers: [&#x27;Android &gt;= 4.0&#x27;, &#x27;iOS &gt;= 8&#x27;] // &#125;, // 配置使用 postcss-pxtorem 插件 // 作用：把 px 转为 rem &quot;postcss-pxtorem&quot;: &#123; rootValue(&#123; file &#125;) &#123; return file.indexOf(&quot;vant&quot;) !== -1 ? 37.5 : 75; &#125;, propList: [&quot;*&quot;], &#125;, &#125;,&#125;; 配置完毕，把服务重启一下 二、postcss-px-to-viewport在最近的一个移动端项目中，我使用第一种方案遇到了一些问题，导致我不能将 px 转化为 rem。于是我又找到了另外一种方案 postcss-px-to-viewport是一款优秀的插件，它将 px 转换成视口单位 vw https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0 2.1 安装1$ npm install postcss-px-to-viewport --save-dev 或者 1$ yarn add -D postcss-px-to-viewport 2.2 在项目根目录下添加.postcssrc.js文件12345678910111213141516171819202122module.exports = &#123; plugins: &#123; &quot;postcss-px-to-viewport&quot;: &#123; // 配置详情可见 https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0 unitToConvert: &quot;px&quot;, viewportWidth: 750, unitPrecision: 5, propList: [&quot;*&quot;], viewportUnit: &quot;vw&quot;, fontViewportUnit: &quot;vw&quot;, selectorBlackList: [], minPixelValue: 1, mediaQuery: false, replace: true, exclude: [/node_modules/], include: undefined, landscape: false, landscapeUnit: &quot;vw&quot;, landscapeWidth: 1920, &#125;, &#125;,&#125;; 最后重启项目即可","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"ES6补充","slug":"ES6补充","date":"2023-02-11T14:48:05.000Z","updated":"2024-03-12T08:27:38.824Z","comments":true,"path":"2023/02/11/ES6补充/","link":"","permalink":"https://congtf.top/2023/02/11/ES6%E8%A1%A5%E5%85%85/","excerpt":"","text":"更多请参考 阮一峰老师 ES6 入门教程https://es6.ruanyifeng.com/ MDN 官方文档https://developer.mozilla.org/zh-CN/ 一、作用域1、作用域链作用域链本质上是底层的变量查找机制。在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域。这种嵌套关系的作用域串联起来就形成了作用域链 2、JS 垃圾回收机制垃圾回收机制(Garbage Collection) 简称 GC JS 中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收 虽然垃圾回收器会帮我们自动回收内存，但我们仍有必要了解 JS 的内存管理机制。它可以帮助我们理解内存泄漏（内存无法被回收） 不再用到的内存，没有及时释放，就叫做内存泄漏 内存的生命周期 JS 环境中分配的内存, 一般有如下生命周期： 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 说明： 全局变量一般不会回收(关闭页面回收)； 一般情况下局部变量的值, 不用了, 会被自动回收掉 两种常见的浏览器垃圾回收算法 引用计数法 IE 采用的引用计数算法, 定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象 具体步骤： 跟踪记录被引用的次数 如果被引用了一次，那么就记录次数 1,多次引用会累加 如果减少一个引用就减 1 当引用次数是 0 时 ，则释放内存 它存在一个致命的问题：嵌套引用（循环引用） 如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。 12345678function fn() &#123; let o1 = &#123;&#125;; let o2 = &#123;&#125;; o1.a = o2; o2.a = o1; return &quot;引用计数无法回收&quot;;&#125;fn(); 正常情况下，上述代码中的变量 o1、o2 在函数 fn 执行完毕之后就应该被回收掉，但是根据引用计数法，虽然函数 fn 已经执行完成，但是由于 o1、o2 中存在着相互引用的关系，因此实际上并不会被回收，这就造成了内存泄漏。于是就有了标记清除法 标记清除法 现代的浏览器已经不再使用引用计数算法了 现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。 核心： 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 就是从根部（在 JS 中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 同样上述的代码，如果用标记清除法，在函数 fn 执行完毕之后，函数作用域里面的变量，从全局对象开始已经访问不到了，因此会被回收掉 3、闭包MDN 官方解释：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域 从代码结构上看，闭包 &#x3D; 内层函数 + 外层函数的变量。 12345678function outer() &#123; const a = 100; function inner() &#123; console.log(a); &#125; inner();&#125;outer(); 闭包作用：封闭数据，提供操作，外部也可以访问函数内部的变量 闭包的基本形式 12345678function outer() &#123; const a = 100; return function inner() &#123; console.log(a); &#125;;&#125;const fun = outer();fun(); 闭包应用：实现数据的私有 比如，我们要做个统计函数调用次数，函数调用一次，就++ 1234567let i = 1;function count() &#123; i++; console.log(`函数被调用了$&#123;i&#125;次`);&#125;count(); // 2count(); // 3 但是这样定义的全局变量 i 很容易被修改，一旦修改，统计的函数调用次数就不准确了。可以通过闭包解决这个问题 12345678910function count() &#123; let i = 1; return function fn() &#123; i++; console.log(`函数被调用了$&#123;i&#125;次`); &#125;;&#125;const fun = count();fun(); // 2fun(); // 3 这样实现了数据私有，无法直接修改 count 二、深入对象创建对象的三种方式 利用对象字面量创建对象 利用 new Object 创建对象 利用构造函数创建对象 1、构造函数构造函数 ：是一种特殊的函数，主要用来初始化对象 使用场景：常规的 {…} 语法允许创建一个对象。比如我们创建了佩奇的对象，继续创建乔治的对象还需要重新写一 遍。此时可以通过构造函数，它就像一个模子一样，能帮助我们快速创建多个类似的对象。 1234567891011121314151617181920const xiaoming = &#123; name: &#x27;小明&#x27;, age: 18, gender: &#x27;男&#x27;&#125;const xiaohong = &#123; name: &#x27;小红&#x27;, age: 17, gender: &#x27;女&#x27;&#125;// 这种类似的结构，我们可以通过构造函数来创建// 声明一个&quot;人类&quot;的构造函数function Person(name,age,gender) &#123; this.name = name this.age = age this.gender = gender&#125;// 通过实例化来批量生产“人类”const xiaoming = new Person(&#x27;小明&#x27;，18，&#x27;男&#x27;)const xiaohong = new Person(&#x27;小红&#x27;，18，&#x27;女&#x27;) 构造函数本质上也函数，不过一般情况下： 它们的命名以大写字母开头，以表明这是一个构造函数 它们只能由 “new” 操作符来执行 new Object()、new Date()这些都是内置的构造函数 构造函数的实例化执行过程 创建新对象 2.构造函数 this 指向新对象 3.执行构造函数代码，修改 this，添加新的属性 4.返回新对象 实例成员&amp;静态成员 实例成员：通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。 1234567891011function Person(name, age, gender) &#123; // 构造函数中直接声明的这些方法和属性就是实例成员 this.name = name; this.age = age; this.gender = gender;&#125;// 直接为构造函数添加的这些方法和属性就是静态成员Person.eyes = 2;Person.say = function () &#123; console.log(&quot;会说话&quot;);&#125;; 请注意： 构造函数创建的实例对象彼此独立互不影响 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 2、内置构造函数引用类型：Object，Array，RegExp，Date 等 包装类型：String，Number，Boolean 等 数组常见实例方法-核心方法 reduce 语法 求和 12const arr = [1, 2, 3, 4, 5];const result = arr.reduce((prev, current) =&gt; prev + current); 数组常见实例方法-其他方法 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法slice返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括 end）（此截取方法字符串也有） 实例方法 reverse 反转数组 实例方法 findIndex 返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回 -1 实例方法includes用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false 实例方法push添加元素到数组末尾 实例方法pop（弹出）删除数组末尾的元素 实例方法shift删除数组头部元素 实例方法unshift添加元素到数组的头部 实例方法indexOf返回数组中第一次出现给定元素的下标，如果不存在则返回 -1 实例方法fill用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引 数组常见静态方法 Array.from()：对一个伪数组或可迭代对象创建一个新的，浅拷贝的数组实例 Array.isArray()：用于确定传递的值是否是一个 Array String 常见实例方法 在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法。这是因为它们是 JavaScript 底层使用 Object 构造函数“包装”来的 String 常见实例方法 实例属性 length 用来获取字符串的度长(重点) 实例方法 split(&#39;分隔符&#39;) 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 实例方法trim从字符串的两端清除空格，返回一个新的字符串，而不修改原始字符串 实例方法slice 方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串 Number 常见方法 实例方法toFixed设置保留小数位的长度 静态方法 Number.parseInt() 方法依据指定基数，解析字符串并返回一个整数。 静态方法Number.parseFloat() 方法可以把一个字符串解析成浮点数 Date 常见方法 实例方法toLocaleString方法返回该日期对象的字符串 实例方法toLocaleDateString 方法返回指定日期对象日期部分的字符串 实例方法getDate根据本地时间，返回一个指定的 Date 对象为一个月中的哪一日（1-31） 实例方法getDay根据本地时间，返回一个指定的 Date 对象是在一周中的第几天（0-6），0 表示星期天 实例方法getFullYear根据本地时间，返回一个指定的 Date 对象的完整年份（四位数年份） 实例方法getHours根据本地时间，返回一个指定的 Date 对象的小时（0–23） 实例方法getMinutes根据本地时间，返回一个指定的 Date 对象的分钟数（0–59） 实例方法getMonth根据本地时间，返回一个指定的 Date 对象的月份（0–11），0 表示一年中的第一月 实例方法getSeconds根据本地时间，返回一个指定的 Date 对象的秒数（0–59） 实例方法getTime返回一个数值，表示从 1970 年 1 月 1 日 0 时 0 分 0 秒（UTC，即协调世界时）距离该 Date 对象所代表时间的毫秒数（时间戳） 静态方法Date.now()返回自 1970-1-1 00:00:00 UTC（世界标准时间）至今所经过的毫秒数(时间戳) Math 常见方法 静态方法Math.floor(x)返回小于一个数的最大整数，即一个数向下取整后的值 静态方法Math.ceil(x)返回大于一个数的最大整数，即一个数向上取整后的值 静态方法Math.max(x,y,...)返回零到多个数值中最大值 静态方法Math.min(x,y,...)返回零到多个数值中最小值 静态方法Math.pow(x,y)返回一个数的 y 次幂 静态方法Math.random()返回一个 0 到 1 之间的伪随机数 静态方法Math.round(x)返回四舍五入后的整数 三、面向对象1、面向对象的编程思想面向过程编程 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程 缺点：没有面向对象易维护、易复用、易扩展 面向对象编程 (oop) 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。 面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目 面向对象的特性： 封装性 继承性 多态性 优点：易维护、易复用、易扩展，由于面向对象有封装 、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点：性能比面向过程低 2、封装JavaScript 中可以通过构造函数实现面向对象的封装 将相同的结构封装在构造函数中，通过 this 指向实现数据的共享。并且通过构造函数创造出来的实例对象之间彼此独立、互不影响 1234567891011function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; this.sing = function () &#123; console.log(&quot;说话&quot;); &#125;;&#125;const ldh = new Person(&quot;刘德华&quot;, 18, &quot;男&quot;);const zxy = new Person(&quot;张学友&quot;, 20, &quot;男&quot;);console.log(ldh.sing === zxy.sing); // false 然而，由于构造函数创造出来的实例对象之间彼此独立、互不影响。我们会发现ldh.sing和zxy.sing并不相等，这不是我们想要的，因为实际上每个实例对象（比如ldh和zxy）之间的sing方法应该是相同的，他们实现的是相同的功能，因此没必要单独给它们各自分配内存。 原型 使用原型对象就可以实现方法的共享 构造函数通过原型分配的函数是所有实例对象所共享的 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象 这个对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法 构造函数和原型对象中的 this 都指向实例化的对象 1234567891011function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Person.prototype.sing = function () &#123; console.log(&quot;说话&quot;);&#125;;const ldh = new Person(&quot;刘德华&quot;, 18, &quot;男&quot;);const zxy = new Person(&quot;张学友&quot;, 20, &quot;男&quot;);console.log(ldh.sing === zxy.sing); // true constructor 属性 每个原型对象里面都有个 constructor 属性（constructor 构造函数） 该属性指向该原型对象的构造函数 使用场景： 如果有多个对象的方法，我们可以给原型对象采取对象形式赋值. 但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了 。也就是说正常情况下，原型对象上是存在着 constructor 属性的，现在我们想往原型对象上挂载多个方法，我们不想一个一个的添加，于是我们采用直接赋值的方式。但是我们通过赋值的形式往原型对象上挂载方法后，把原来的原型对象上的 constructor 属性覆盖掉了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 1234567891011121314151617181920212223242526272829303132333435function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;// 多个方法挂载到原型对象上，为了方便不想一个一个的挂载Person.prototype.sing = function () &#123; console.log(&quot;说话&quot;);&#125;;Person.prototype.dance = function () &#123; console.log(&quot;跳舞&quot;);&#125;;// 于是直接给prototype属性赋值Person.prototype = &#123; sing: function () &#123; console.log(&quot;说话&quot;); &#125;, dance: function () &#123; console.log(&quot;跳舞&quot;); &#125;,&#125;;// 但是这样，原本原型对象prototype上的constructor 属性就被赋值给覆盖掉了Person.prototype = &#123; // 因此利用constructor，手动指回Person构造函数 constructor: Person, sing: function () &#123; console.log(&quot;说话&quot;); &#125;, dance: function () &#123; console.log(&quot;跳舞&quot;); &#125;,&#125;;const ldh = new Person(&quot;刘德华&quot;, 18, &quot;男&quot;);const zxy = new Person(&quot;张学友&quot;, 20, &quot;男&quot;);console.log(ldh.sing === zxy.sing); // true 但是当我们把原本放在构造函数上的一些公共属性或方法放到原型对象上后，实例对象如何访问到原型对象上的公共属性或方法呢？ proto 对象都会有一个属性 proto 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 proto 原型的存在 3、原型继承继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性 123456789101112// 定义一个中国人的构造函数function Chinese() &#123; this.header = 1; this.eyes = 2; this.language = &quot;chinese&quot;;&#125;// 定义一个日本人的构造函数function Japanese() &#123; this.header = 1; this.eyes = 2; this.language = &quot;japanese&quot;;&#125; 我们发现，不管是中国人还是日本人，他们都属于人类。因此可以将人类的一些公共特征抽取出来，单独封装成一个人类的构造函数，让中国人和日本人共享这个构造函数的属性和方法 1234567891011121314151617181920// 封装一个人类的构造函数function Human() &#123; this.header = 1; this.eyes = 2;&#125;// 中国人的构造函数function Chinese() &#123; this.language = &quot;chinese&quot;;&#125;// 日本人的构造函数function Japanese() &#123; this.language = &quot;japanese&quot;;&#125;// 通过改变中国人和日本人的原型对象指向到Human，以此继承Human上的方法和属性Chinese.prototype = Human;// 不要忘了constructor 指回ChineseChinese.prototype.constructor = Chinese;// 同理日本人Japanese.prototype = Human;Japanese.prototype.constructor = Japanese; 但是此时会有一个问题，当我们向单独给 Chinese 添加一个属性或者方法时，我们会发现 Japanese 也被自动添加了这个属性或方法。并且由于Japanese.prototype.constructor是后来定义的，它将Chinese.prototype.constructor = Chinese覆盖掉了，因此Chinese.prototype.constructor竟然也指向了Japanese！ 1234567891011121314151617181920212223242526// 封装一个人类的构造函数function Human() &#123; this.header = 1; this.eyes = 2;&#125;// 中国人的构造函数function Chinese() &#123; this.language = &quot;chinese&quot;;&#125;// 日本人的构造函数function Japanese() &#123; this.language = &quot;japanese&quot;;&#125;// 通过改变中国人和日本人的原型对象指向到Human，以此继承Human上的方法和属性Chinese.prototype = Human;// 不要忘了constructor 指回ChineseChinese.prototype.constructor = Chinese;// 同理日本人Japanese.prototype = Human;Japanese.prototype.constructor = Japanese;Chinese.prototype.smoking = function () &#123; console.log(&quot;抽烟&quot;);&#125;;const xiaoming = new Chinese();const guitian = new Japanese();console.log(xiaoming, guitian); 这是因为Chinese.prototype和Japanese.prototype都是一个指向了构造函数Human的地址，通过Chinese.prototype.smoking修改了Human的值，Japanese.prototype也会受到影响。因此我们可以将Chinese.prototype和Japanese.prototype各自指向一个 Human 的实例对象，这样它们就互不影响了！ 1234567891011121314151617181920212223242526// 封装一个人类的构造函数function Human() &#123; this.header = 1; this.eyes = 2;&#125;// 中国人的构造函数function Chinese() &#123; this.language = &quot;chinese&quot;;&#125;// 日本人的构造函数function Japanese() &#123; this.language = &quot;japanese&quot;;&#125;// 通过改变中国人和日本人的原型对象指向到Human，以此继承Human上的方法和属性Chinese.prototype = new Human();// 不要忘了constructor 指回ChineseChinese.prototype.constructor = Chinese;// 同理日本人Japanese.prototype = new Human();Japanese.prototype.constructor = Japanese;Chinese.prototype.smoking = function () &#123; console.log(&quot;抽烟&quot;);&#125;;const xiaoming = new Chinese();const guitian = new Japanese();console.log(xiaoming, guitian); 原型链 基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对 象的链状结构关系称为原型链 原型链-查找规则 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型（也就是 proto指向的 prototype 原型对象） 如果还没有就查找原型对象的原型（Object 的原型对象） 依此类推一直找到 Object 为止（null） proto对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线 可以使用 instanceof 运算符检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 4、深浅拷贝开发中我们经常需要复制一个引用类型。如果直接赋值，当我们修改一个值时，另一个值也变了 浅拷贝和深拷贝只针对引用类型 浅拷贝常见方法： 拷贝对象：Object.assgin() &#x2F; 展开运算符 拷贝数组：Array.prototype.concat() 或者展开运算符 但是如果引用数据类型里面出现了嵌套引用数据类型的情况，深拷贝就又会出现上述问题，这时需要深拷贝 深拷贝常见方法： 通过递归实现深拷贝 lodash 库 cloneDeep 函数 通过 JSON.stringify()实现 递归 如果一个函数在内部调用其本身，那么这个函数就是递归函数 由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return 利用递归函数实现 setTimeout 模拟 setInterval 效果 12345function getTime() &#123; console.log(new Date().toLocaleString()); setTimeout(getTime, 1000);&#125;getTime(); 利用递归函数实现基本的深拷贝 1234567891011121314151617function deepCopy(newData, oldData) &#123; // 遍历原对象 for (let k in oldData) &#123; // 如果是数组 if (oldData[k] instanceof Array) &#123; newData[k] = []; deepCopy(newData[k], oldData[k]); &#125; else if (oldData[k] instanceof Object) &#123; // 如果是对象 newData[k] = &#123;&#125;; deepCopy(newData[k], oldData[k]); &#125; else &#123; // 基本数据类型直接赋值 newData[k] = oldData[k]; &#125; &#125;&#125; 通过 JSON.stringify()实现深拷贝 1234567891011const obj = &#123; name: &quot;佩奇&quot;, age: 18, hobby: [&quot;抽烟&quot;, &quot;喝酒&quot;, &quot;烫头&quot;], family: &#123; sister: &quot;乔治&quot;, father: &quot;猪爸爸&quot;, mother: &quot;猪妈妈&quot;, &#125;,&#125;;const obj2 = JSON.parse(JSON.stringify(obj)); JSON.stringify()可以将 JS 对象转化为 JSON 字符串，JSON 字符串就是一个字符串，就不存在所谓的地址引用了 5、异常处理throw 抛异常 异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行 1234567891011function counter(x, y) &#123; if (!x || !y) &#123; // throw &#x27;参数不能为空！&#x27; throw new Error(&quot;参数不能为空！&quot;); console.log(111); &#125; console.log(222); return x + y;&#125;counter();console.log(333); throw 抛出异常信息，整个程序也会终止执行 throw 后面跟的是错误提示信息,可以直接跟字符串 Error 对象配合 throw 使用，能够设置更详细的错误信息 try &#x2F;catch 捕获异常 可以通过 try &#x2F; catch 捕获错误信息（浏览器提供的错误信息） 12345678910111213function fn() &#123; try &#123; const p = document.querySelector(&quot;.p&quot;); p.style.color = &quot;red&quot;; &#125; catch (error) &#123; console.log(error.message); &#125; finally &#123; console.log(&quot;finally执行了！&quot;); &#125; console.log(&quot;我是函数fn中的最后打印&quot;);&#125;fn();console.log(&quot;我是函数fn外的打印&quot;); 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 finally 不管是否有错误，都会执行 使用 try &#x2F; catch 捕获错误信息，发生异常后程序不会终止执行 debugger 可以在代码中用 debugger 打断点调试程序，它和我们在控制台打断点的效果是一样的 6、thisthis 指向 普通函数中的 this：指向 window 构造函数、原型对象中的 this：指向实例化对象 对象中的方法中的 this：指向该对象 定时器、延时器中的 this：指向 window 事件处理函数中的 this：指向事件源 箭头函数中的 this：实际上箭头函数中并不存在 this，箭头函数中的 this 指向上层作用域的 this，如果上层作用域也没有 this，则一级一级向上查找 简单来说，this 总是指向调用者。我们所说的 this 指向是按作用域划分的 改变 this 指向 JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向 call() 语法： thisArg：在 fun 函数运行时指定的 this 值 arg1，arg2：函数 fun 正常的参数 返回值就是函数的返回值，因为它就是调用函数（当一个函数调用了 call 方法时，这个函数也被调用执行了） apply() 语法： thisArg：在 fun 函数运行时指定的 this 值 argsArray：函数 fun 正常的参数，但是在 apply 中必须包含在数组里面 因为 apply 的参数主要跟数组有关系，因此在涉及到数组处理时，应该想到 apply 比如使用 Math.max() 求数组的最大值 返回值就是函数的返回值，因为它就是调用函数当一个函数调用了 apply 方法时，这个函数也被调用执行了） 1234// 求数组最大值const arr = [1, 3, 5, 7, 9];// console.log(Math.max(...arr))console.log(Math.max.apply(null, arr)); bind() 语法： thisArg：在 fun 函数运行时指定的 this 值 arg1，arg2：函数 fun 具体的参数 返回由指定的 this 值和初始化参数改造的原函数拷贝 （新函数），并不调用原函数 因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind，比如改变定时器内部的 this 指向","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"token失效的处理","slug":"token失效的处理","date":"2023-01-13T12:51:01.000Z","updated":"2024-03-15T08:50:48.010Z","comments":true,"path":"2023/01/13/token失效的处理/","link":"","permalink":"https://congtf.top/2023/01/13/token%E5%A4%B1%E6%95%88%E7%9A%84%E5%A4%84%E7%90%86/","excerpt":"","text":"一、主动处理主动处理主要是前端在每次发起请求时都主动去检查一下 token 是否过期。流程图如下： 具体业务图如下 流程图转化代码流程图转化代码 src/utils/auth.js 123456789101112131415161718192021222324252627import Cookies from &quot;js-cookie&quot;;const TokenKey = &quot;hr-saas-111-token&quot;;const timeKey = &quot;hr-sass-time-key&quot;; // 用来作为时间戳存储的keyexport function getToken() &#123; return Cookies.get(TokenKey);&#125;export function setToken(token) &#123; return Cookies.set(TokenKey, token);&#125;export function removeToken() &#123; return Cookies.remove(TokenKey);&#125;export function setTimeStamp() &#123; // 设置当前最新的时间戳 // Date.now() new Date.getTime() Cookies.set(timeKey, Date.now());&#125;export function getTimeStamp() &#123; return Cookies.get(timeKey);&#125; src/utils/request.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import axios from &quot;axios&quot;;import store from &quot;@/store&quot;;import router from &quot;@/router&quot;;import &#123; Message &#125; from &quot;element-ui&quot;;import &#123; getTimeStamp &#125; from &quot;@/utils/auth&quot;;const TimeOut = 3600; // 定义超时时间const service = axios.create(&#123; // 当执行 npm run dev =&gt; .evn.development =&gt; /api =&gt; 跨域代理 baseURL: process.env.VUE_APP_BASE_API, // npm run dev =&gt; /api npm run build =&gt; /prod-api timeout: 5000, // 设置超时时间&#125;);// 请求拦截器service.interceptors.request.use( (config) =&gt; &#123; // config 是请求的配置信息 // 注入token if (store.getters.token) &#123; // 只有在有token的情况下 才有必要去检查时间戳是否超时 if (IsCheckTimeOut()) &#123; // 如果它为true表示 过期了 // token没用了 因为超时了 store.dispatch(&quot;user/logout&quot;); // 登出操作 // 跳转到登录页 router.push(&quot;/login&quot;); return Promise.reject(new Error(&quot;token超时了&quot;)); &#125; config.headers[&quot;Authorization&quot;] = `Bearer $&#123;store.getters.token&#125;`; &#125; return config; // 必须要返回的 &#125;, (error) =&gt; &#123; return Promise.reject(error); &#125;);// 响应拦截器service.interceptors.response.use( (response) =&gt; &#123; // axios默认加了一层data const &#123; success, message, data &#125; = response.data; // 要根据success的成功与否决定下面的操作 if (success) &#123; return data; &#125; else &#123; // 业务已经错误了 还能进then ? 不能 ！ 应该进catch Message.error(message); // 提示错误消息 return Promise.reject(new Error(message)); &#125; &#125;, (error) =&gt; &#123; Message.error(error.message); // 提示错误信息 return Promise.reject(error); // 返回执行错误 让当前的执行链跳出成功 直接进入 catch &#125;);// 是否超时// 超时逻辑 (当前时间 - 缓存中的时间) 是否大于 时间差function IsCheckTimeOut() &#123; var currentTime = Date.now(); // 当前时间戳 var timeStamp = getTimeStamp(); // 缓存时间戳 return (currentTime - timeStamp) / 1000 &gt; TimeOut;&#125;export default service; 在登录的时候，如果登录成功，我们应该设置时间戳 12345678910111213// 定义login action 也需要参数 调用action时 传递过来的参数// async 标记的函数其实就是一个异步函数 -&gt; 本质是还是 一个promiseasync login(context, data) &#123; // 经过响应拦截器的处理之后 这里的result实际上就是 token const result = await login(data) // 实际上就是一个promise result就是执行的结果 // axios默认给数据加了一层data // 表示登录接口调用成功 也就是意味着你的用户名和密码是正确的 // 现在有用户token // actions 修改state 必须通过mutations context.commit(&#x27;setToken&#x27;, result) // 写入时间戳 setTimeStamp() // 将当前的最新时间写入缓存&#125; 二、被动处理被动处理就是后端告诉我们超时了，我们按照后端接口做出反应即可。如果后端接口没有做处理，主动介入就是一种简单的方式 token 超时的错误码是**10002** 代码实现 src/utils/request.js 123456789101112131415(error) =&gt; &#123; // error 信息 里面 response的对象 if ( error.response &amp;&amp; error.response.data &amp;&amp; error.response.data.code === 10002 ) &#123; // 当等于10002的时候 表示 后端告诉我token超时了 store.dispatch(&quot;user/logout&quot;); // 登出action 删除token router.push(&quot;/login&quot;); &#125; else &#123; Message.error(error.message); // 提示错误信息 &#125; return Promise.reject(error);&#125;; 无论是主动介入还是被动处理，这些操作都是为了更好地处理 token，减少错误异常的可能性","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"基于RBAC的菜单权限控制","slug":"基于RBAC的菜单权限控制","date":"2022-12-13T13:27:23.000Z","updated":"2024-03-15T08:45:51.991Z","comments":true,"path":"2022/12/13/基于RBAC的菜单权限控制/","link":"","permalink":"https://congtf.top/2022/12/13/%E5%9F%BA%E4%BA%8ERBAC%E7%9A%84%E8%8F%9C%E5%8D%95%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/","excerpt":"","text":"RBAC (Role-Based Access Control) 是一种基于角色的访问控制方式。在这种模式中，权限不是直接分配给用户，而是分配给角色，然后用户被分配到不同的角色。用户通过角色获得权限。这种方式使得权限管理变得更加灵活和方便。 在 RBAC 模型中，可以包含以下几个主要元素： 用户（User）：系统的操作者，可以是人，也可以是内部的程序或进程。 角色（Role）：用户的身份，它是权限的集合。一个用户可以拥有多个角色。 权限（Permission）：对一种操作或者资源的访问控制。权限通常是系统定义好的，例如读权限、写权限等。 RBAC 模型的主要优点是可以简化权限管理。在大型组织中，用户经常会更换部门，或者角色会随着时间而变化。使用 RBAC 模型，只需要更改用户的角色，而不需要单独更改每个用户的权限。 在企业服务中，权限一般分割为 页面访问权限，按钮操作权限，API 访问权限 一、权限受控的主体思路 我们将路由模块分为静态路由和动态路由，静态路由是所有人都能访问的，而动态路由则是需要权限才能访问的 在用户登录获取的用户信息中，携带有用户拥有的权限标识。我们可以将用户携带的权限标识和动态路由对应起来（比如对应到路由模块的 name），这样就可以从动态路由中筛选出用户所拥有的路由了 静态路由和筛选出的路由合并得到用户完整路由。侧边栏根据完整路由渲染出菜单栏、路由守卫根据完整路由拦截或放行 二、拆分路由模块拆分后的&#x2F;src&#x2F;router.index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import Vue from &quot;vue&quot;;import Router from &quot;vue-router&quot;;Vue.use(Router);// 引入多个模块的规则import approvalsRouter from &quot;./modules/approvals&quot;;import departmentsRouter from &quot;./modules/departments&quot;;import employeesRouter from &quot;./modules/employees&quot;;import permissionRouter from &quot;./modules/permission&quot;;import attendancesRouter from &quot;./modules/attendances&quot;;import salarysRouter from &quot;./modules/salarys&quot;;import settingRouter from &quot;./modules/setting&quot;;import socialRouter from &quot;./modules/social&quot;;import userRouter from &quot;./modules/user&quot;;/* Layout */import Layout from &quot;@/layout&quot;;export const constantRoutes = [ &#123; path: &quot;/login&quot;, component: () =&gt; import(&quot;@/views/login/index&quot;), hidden: true, &#125;, &#123; path: &quot;/404&quot;, component: () =&gt; import(&quot;@/views/404&quot;), hidden: true, &#125;, &#123; path: &quot;/&quot;, component: Layout, redirect: &quot;/dashboard&quot;, children: [ &#123; path: &quot;dashboard&quot;, name: &quot;dashboard&quot;, component: () =&gt; import(&quot;@/views/dashboard/index&quot;), meta: &#123; title: &quot;首页&quot;, icon: &quot;dashboard&quot; &#125;, &#125;, ], &#125;, &#123; path: &quot;/import&quot;, component: Layout, hidden: true, // 该组件不在菜单中显示 children: [ &#123; path: &quot;&quot;, component: () =&gt; import(&quot;@/views/import&quot;), meta: &#123; title: &quot;导入&quot;, &#125;, &#125;, ], &#125;, userRouter, // 404 page must be placed at the end !!! // &#123; path: &#x27;*&#x27;, redirect: &#x27;/404&#x27;, hidden: true &#125;];// 动态路由的变量export const asyncRoutes = [ approvalsRouter, departmentsRouter, employeesRouter, permissionRouter, attendancesRouter, salarysRouter, settingRouter, socialRouter,];const createRouter = () =&gt; new Router(&#123; mode: &quot;history&quot;, // require service support base: &quot;/hrsaas/&quot;, scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes: [...constantRoutes], &#125;);const router = createRouter();// Detail see: https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465export function resetRouter() &#123; const newRouter = createRouter(); router.matcher = newRouter.matcher; // reset router&#125;export default router; 三、在 vuex 中新建 permission 模块src/store/modules/permission.js 1234567891011121314151617181920212223// vuex的权限模块import &#123; constantRoutes &#125; from &quot;@/router&quot;;// vuex中的permission模块用来存放当前的 静态路由 + 当前用户的 权限路由const state = &#123; routes: constantRoutes, // 所有人默认拥有静态路由&#125;;const mutations = &#123; // newRoutes可以认为是 用户登录 通过权限所得到的动态路由的部分 setRoutes(state, newRoutes) &#123; // 下面这么写不对 不是语法不对 是业务不对 // state.routes = [...state.routes, ...newRoutes] // 有一种情况 张三 登录 获取了动态路由 追加到路由上 李四登录 4个动态路由 // 应该是每次更新 都应该在静态路由的基础上进行追加 state.routes = [...constantRoutes, ...newRoutes]; &#125;,&#125;;const actions = &#123;&#125;;export default &#123; namespaced: true, state, mutations, actions,&#125;; 在 Vuex 管理模块中引入 permisson 模块 12345678910111213import permission from &quot;./modules/permission&quot;;const store = new Vuex.Store(&#123; modules: &#123; // 子模块 $store.state.app. // mapGetters([]) app, settings, user, permission, &#125;, getters,&#125;); 四、vuex 筛选路由权限我们可以按照这张图，做进一步的操作 后端返回的用户信息 接下来， 在 vuex 的 permission 中写一个 action，通过路由模块的 name 与用户信息中的权限标识进行关联，最终筛选出用户所拥有的权限路由 123456789101112131415161718192021import &#123; asyncRoutes, constantRoutes &#125; from &#x27;@/router&#x27;const actions = &#123; // 筛选权限路由 // 第二个参数为当前用户的所拥有的菜单权限 // menus: [&quot;settings&quot;,&quot;permissions&quot;] // asyncRoutes是所有的动态路由 // asyncRoutes [&#123;path: &#x27;setting&#x27;,name: &#x27;setting&#x27;&#125;,&#123;&#125;] filterRoutes(context, menus) &#123; const routes = [] // 筛选出 动态路由中和menus中能够对上的路由 menus.forEach(key =&gt; &#123; // key就是标识 // asyncRoutes 找 有没有对象中的name属性等于 key的 如果找不到就没权限 如果找到了 要筛选出来 routes.push(...asyncRoutes.filter(item =&gt; item.name === key)) // 得到一个数组 有可能 有元素 也有可能是空数组 &#125;) // 得到的routes是所有模块中满足权限要求的路由数组 // routes就是当前用户所拥有的 动态路由的权限 context.commit(&#x27;setRoutes&#x27;, routes) // 将动态路由提交给mutations return routes // 这里为什么还要return state数据 是用来 显示左侧菜单用的 return 是给路由addRoutes用的 &#125; 五、权限拦截处调用筛选权限 Action在拦截的位置，调用关联 action， 获取新增 routes，并且addRoutes 注意，由于内容较多，我们可以将拦截这块从&#x2F;src&#x2F;router&#x2F;index.js 中抽离出来，形成一个单独的模块，&#x2F;src&#x2F;permission.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 权限拦截在路由跳转 导航守卫import router from &quot;@/router&quot;;import store from &quot;@/store&quot;; // 引入store实例 和组件中的this.$store是一回事import nprogress from &quot;nprogress&quot;; // 引入进度条import &quot;nprogress/nprogress.css&quot;; // 引入进度条样式// 不需要导出 因为只需要让代码执行即可// 前置守卫// next是前置守卫必须必须必须执行的钩子 next必须执行 如果不执行 页面就死了// next() 放过// next(false) 跳转终止// next(地址) 跳转到某个地址const whiteList = [&quot;/login&quot;, &quot;/404&quot;]; // 定义白名单router.beforeEach(async (to, from, next) =&gt; &#123; nprogress.start(); // 开启进度条的意思 if (store.getters.token) &#123; // 只有有token的情况下 才能获取资料 // 如果有token if (to.path === &quot;/login&quot;) &#123; // 如果要访问的是 登录页 next(&quot;/&quot;); // 跳到主页 // 有token 用处理吗？不用 &#125; else &#123; // 只有放过的时候才去获取用户资料 // 是每次都获取吗 // 如果当前vuex中有用户的资料的id 表示 已经有资料了 不需要获取了 如果没有id才需要获取 if (!store.getters.userId) &#123; // 如果没有id才表示当前用户资料没有获取过 // async 函数所return的内容 用 await就可以接收到 const &#123; roles &#125; = await store.dispatch(&quot;user/getUserInfo&quot;); // 如果说后续 需要根据用户资料获取数据的话 这里必须改成 同步 // 筛选用户的可用路由 // actions中函数 默认是Promise对象 调用这个对象 想要获取返回的值话 必须 加 await或者是then // actions是做异步操作的 const routes = await store.dispatch( &quot;permission/filterRoutes&quot;, roles.menus ); // routes就是筛选得到的动态路由 // 动态路由 添加到 路由表中 默认的路由表 只有静态路由 没有动态路由 // addRoutes 必须 用 next(地址) 不能用next() router.addRoutes(routes); // 添加动态路由到路由表 铺路 // 添加完动态路由之后 next(to.path); // 相当于跳到对应的地址 相当于多做一次跳转 为什么要多做一次跳转 // 进门了，但是进门之后我要去的地方的路还没有铺好，直接走，掉坑里，多做一次跳转，再从门外往里进一次，跳转之前 把路铺好，再次进来的时候，路就铺好了 &#125; else &#123; next(); &#125; &#125; &#125; else &#123; // 没有token的情况下 if (whiteList.indexOf(to.path) &gt; -1) &#123; // 表示要去的地址在白名单 next(); &#125; else &#123; next(&quot;/login&quot;); &#125; &#125; nprogress.done(); // 解决手动切换地址时 进度条不关闭的问题&#125;);// 后置守卫router.afterEach(() =&gt; &#123; nprogress.done(); // 关闭进度条&#125;); 在**src/store/getters.js**配置导出 routes 12345678910const getters = &#123; sidebar: (state) =&gt; state.app.sidebar, device: (state) =&gt; state.app.device, token: (state) =&gt; state.user.token, name: (state) =&gt; state.user.userInfo.username, // 建立用户名称的映射 userId: (state) =&gt; state.user.userInfo.userId, // 建立用户id的映射 companyId: (state) =&gt; state.user.userInfo.companyId, // 建立用户的公司Id映射 routes: (state) =&gt; state.permission.routes, // 导出当前的路由&#125;;export default getters; 六、在左侧菜单组件中， 引入 routes&#x2F;src&#x2F;layout&#x2F;components&#x2F;Siderbar&#x2F;index.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div :class=&quot;&#123; &#x27;has-logo&#x27;: showLogo &#125;&quot;&gt; &lt;logo v-if=&quot;showLogo&quot; :collapse=&quot;isCollapse&quot; /&gt; &lt;el-scrollbar wrap-class=&quot;scrollbar-wrapper&quot;&gt; &lt;el-menu :default-active=&quot;activeMenu&quot; :collapse=&quot;isCollapse&quot; :background-color=&quot;variables.menuBg&quot; :text-color=&quot;variables.menuText&quot; :unique-opened=&quot;false&quot; :active-text-color=&quot;variables.menuActiveText&quot; :collapse-transition=&quot;false&quot; mode=&quot;vertical&quot; &gt; &lt;sidebar-item v-for=&quot;route in routes&quot; :key=&quot;route.path&quot; :item=&quot;route&quot; :base-path=&quot;route.path&quot; /&gt; &lt;/el-menu&gt; &lt;/el-scrollbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &quot;vuex&quot;;import Logo from &quot;./Logo&quot;;import SidebarItem from &quot;./SidebarItem&quot;;import variables from &quot;@/styles/variables.scss&quot;;export default &#123; components: &#123; SidebarItem, Logo &#125;, computed: &#123; ...mapGetters([&quot;sidebar&quot;, &quot;routes&quot;]), // 路由 addRoutes之后 不会响应式的更新的组件 // 默认静态路由 5条 + addRoutes(6条) = 11条 // routes() &#123; // return this.$router.options.routes // &#125;, activeMenu() &#123; const route = this.$route; const &#123; meta, path &#125; = route; // if set path, the sidebar will highlight the path you set if (meta.activeMenu) &#123; return meta.activeMenu; &#125; return path; &#125;, showLogo() &#123; return this.$store.state.settings.sidebarLogo; &#125;, variables() &#123; return variables; &#125;, isCollapse() &#123; return !this.sidebar.opened; &#125;, &#125;,&#125;;&lt;/script&gt; 七、登出时重置路由权限和 404 问题 现在，我们看似完成了访问权限的功能，实则不然，因为当我们登出操作之后，虽然看不到菜单，但是用户实际上可以访问页面，直接在地址栏输入地址就能访问 这是怎么回事？ 这是因为我们前面在addRoutes的时候，一直都是在加，登出的时候，我们并没有删，也没有重置，也就是说，我们之前加的路由在登出之后一直在，这怎么处理？ 在router&#x2F;index.js文件中提供一个重置路由方法 12345// 重置路由export function resetRouter() &#123; const newRouter = createRouter(); router.matcher = newRouter.matcher; // 重新设置路由的可匹配路径&#125; 这个方法可以将路由重新实例化，相当于换了一个新的路由，之前**加的路由**自然不存在了，只需要在登出的时候， 调用此方法即可 12345678910111213141516// 登出的actionlgout(context) &#123; // 删除token context.commit(&#x27;removeToken&#x27;) // 不仅仅删除了vuex中的 还删除了缓存中的 // 删除用户资料 context.commit(&#x27;removeUserInfo&#x27;) // 删除用户信息 // 重置路由 resetRouter() // 还有一步 vuex中的数据是不是还在 // 要清空permission模块下的state数据 // vuex中 user子模块 permission子模块 // 子模块调用子模块的action 默认情况下 子模块的context是子模块的 // 父模块 调用 子模块的action context.commit(&#x27;permission/setRoutes&#x27;, [], &#123; root: true &#125;) // 子模块调用子模块的action 可以 将 commit的第三个参数 设置成 &#123; root: true &#125; 就表示当前的context不是子模块了 而是父模块&#125; 除此之外，我们发现在页面刷新的时候，本来应该拥有权限的页面出现了 404，这是因为 404 的匹配权限放在了静态路由，而动态路由在没有 addRoutes 之前，找不到对应的地址，就会显示 404，所以我们需要将 404 放置到动态路由的最后 src/permission.js 1router.addRoutes([...routes, &#123; path: &quot;*&quot;, redirect: &quot;/404&quot;, hidden: true &#125;]); // 添加到路由表 八、完整代码1、路由模块&#x2F;src&#x2F;router&#x2F;index.js 路由模块提供了静态路由和动态路由（从&#x2F;src&#x2F;router 中的其他路由子模块导入） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import Vue from &quot;vue&quot;;import Router from &quot;vue-router&quot;;Vue.use(Router);// 引入多个模块的规则import approvalsRouter from &quot;./modules/approvals&quot;;import departmentsRouter from &quot;./modules/departments&quot;;import employeesRouter from &quot;./modules/employees&quot;;import permissionRouter from &quot;./modules/permission&quot;;import attendancesRouter from &quot;./modules/attendances&quot;;import salarysRouter from &quot;./modules/salarys&quot;;import settingRouter from &quot;./modules/setting&quot;;import socialRouter from &quot;./modules/social&quot;;import userRouter from &quot;./modules/user&quot;;/* Layout */import Layout from &quot;@/layout&quot;;export const constantRoutes = [ &#123; path: &quot;/login&quot;, component: () =&gt; import(&quot;@/views/login/index&quot;), hidden: true, &#125;, &#123; path: &quot;/404&quot;, component: () =&gt; import(&quot;@/views/404&quot;), hidden: true, &#125;, &#123; path: &quot;/&quot;, component: Layout, redirect: &quot;/dashboard&quot;, children: [ &#123; path: &quot;dashboard&quot;, name: &quot;dashboard&quot;, component: () =&gt; import(&quot;@/views/dashboard/index&quot;), meta: &#123; title: &quot;首页&quot;, icon: &quot;dashboard&quot; &#125;, &#125;, ], &#125;, &#123; path: &quot;/import&quot;, component: Layout, hidden: true, // 该组件不在菜单中显示 children: [ &#123; path: &quot;&quot;, component: () =&gt; import(&quot;@/views/import&quot;), meta: &#123; title: &quot;导入&quot;, &#125;, &#125;, ], &#125;, userRouter,];// 动态路由的变量export const asyncRoutes = [ approvalsRouter, departmentsRouter, employeesRouter, permissionRouter, attendancesRouter, salarysRouter, settingRouter, socialRouter,];const createRouter = () =&gt; new Router(&#123; mode: &quot;history&quot;, // require service support base: &quot;/hrsaas/&quot;, scrollBehavior: () =&gt; (&#123; y: 0 &#125;), routes: [...constantRoutes], // 动态路由和静态路由的临时合并 &#125;);const router = createRouter();// Detail see: https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465export function resetRouter() &#123; const newRouter = createRouter(); router.matcher = newRouter.matcher; // reset router&#125;export default router; 2、store 模块&#x2F;src&#x2F;store&#x2F;index.js 它将其他 store 子模块汇总到一起导出供使用 1234567891011121314151617181920212223import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;import getters from &quot;./getters&quot;;import app from &quot;./modules/app&quot;;import settings from &quot;./modules/settings&quot;;import user from &quot;./modules/user&quot;;import permission from &quot;./modules/permission&quot;;import tagsView from &quot;./modules/tagsView&quot;;Vue.use(Vuex);const store = new Vuex.Store(&#123; modules: &#123; app, settings, user, permission, tagsView, &#125;, getters,&#125;);export default store; &#x2F;src&#x2F;store&#x2F;getter.js getter 模块提供了其他 store 模块的快捷访问方式 1234567891011const getters = &#123; sidebar: (state) =&gt; state.app.sidebar, device: (state) =&gt; state.app.device, token: (state) =&gt; state.user.token, // 将user模块下的token作为快捷方式放出来 name: (state) =&gt; state.user.userInfo.username, // 将子模块中的对象中的名称开放出来 userId: (state) =&gt; state.user.userInfo.userId, staffPhoto: (state) =&gt; state.user.userInfo.staffPhoto, // 头像 companyId: (state) =&gt; state.user.userInfo.companyId, routes: (state) =&gt; state.permission.routes,&#125;;export default getters; &#x2F;src&#x2F;store&#x2F;modules&#x2F;user.js user 模块主要用来存储 token 和用户信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import &#123; getToken, setToken, removeToken, setTimeStamp &#125; from &quot;@/utils/auth&quot;;import &#123; login, getUserInfo, getUserDetailById &#125; from &quot;@/api/user&quot;;import &#123; resetRouter &#125; from &quot;@/router&quot;;const state = &#123; token: getToken(), // 设置token为共享 userInfo: &#123;&#125;, // 这里为什么不写null ?&#125;;const mutations = &#123; // 设置token的mutations setToken(state, token) &#123; state.token = token; // 只是设置了vuex中的数据 // 需要将vuex中的数据同步到缓存 setToken(token); &#125;, removeToken(state) &#123; state.token = null; // 设置vuex中的token为null removeToken(); // 同步删除缓存中的token &#125;, setUserInfo(state, userInfo) &#123; state.userInfo = userInfo; // state.userInfo = &#123; ...userInfo &#125; // 浅拷贝 如果要去改属性里面的某一个值 可以用浅拷贝的方式 &#125;, removeUserInfo(state) &#123; state.userInfo = &#123;&#125;; // 重置为空对象 &#125;,&#125;;const actions = &#123; // 封装一个登录的action // data认为是 &#123; mobile,password &#125; // 只要用async标记了函数 那么这个函数本身就是promise对象 async login(context, data) &#123; // 调用登录接口 const result = await login(data); // result就是token context.commit(&quot;setToken&quot;, result); setTimeStamp(); // 设置时间戳 &#125;, // 获取用户资料 async getUserInfo(context) &#123; const result = await getUserInfo(); // 此时result里面已经有userId const baseInfo = await getUserDetailById(result.userId); // 用户的基本信息 context.commit(&quot;setUserInfo&quot;, &#123; ...result, ...baseInfo &#125;); // 修改state中的用户资料 return result; &#125;, // 登出action lgout(&#123; commit &#125;) &#123; // 删除token commit(&quot;removeToken&quot;); // 删除用户资料 commit(&quot;removeUserInfo&quot;); // 重置路由 resetRouter(); // 清空路由模块下的路由信息 // Vuex子模块 调用子模块的mutation commit(&quot;permission/setRoutes&quot;, [], &#123; root: true &#125;); // commit默认是提交的当前子模块的mutations // 如果加上 root: true 就表示commit此时是根级的commit // this.$store.commit(&#x27;permission/setRoutes&#x27;) &#125;,&#125;;export default &#123; namespaced: true, state, mutations, actions,&#125;; &#x2F;src&#x2F;store&#x2F;modules&#x2F;permission.js permission 模块主要用来筛选出用户所拥有的路由 123456789101112131415161718192021222324252627282930313233343536// 引入了静态路由// 权限模块的目的 是提供当前用户所拥有的路由权限的数据 静态路由 + 当前用户的自身的动态路由import &#123; constantRoutes, asyncRoutes &#125; from &quot;@/router&quot;;const state = &#123; // routes表示当前人的路由权限 routes: constantRoutes, // 当前所有人都默认拥有静态路由&#125;;const mutations = &#123; // newRoutes认为是用户登录之后获取的新路由 setRoutes(state, newRoutes) &#123; state.routes = [...constantRoutes, ...newRoutes]; // 静态路由 + 动态路由 // 需要得到newRoutes 才能调用mutations &#125;,&#125;;const actions = &#123; // 筛选路由模块 menus认为是当前用户资料的menus标识 代表用户所拥有的的权限 filterRoutes(context, menus) &#123; // menus [&#x27;setting&#x27;,&#x27;approvals] // asyncRoutes [&#123; name: &#x27;&#x27; &#125;] var routes = []; menus.forEach((item) =&gt; &#123; // item是字符串 去asyncRoutes里面找有没有路由的name叫这个字符串 routes.push(...asyncRoutes.filter((route) =&gt; route.name === item)); &#125;); // routes就是当前用户的筛选之后的动态路由 context.commit(&quot;setRoutes&quot;, routes); // 最后加一行代码 return routes; // 这里返回是因为后面调用action的时候 要使用 &#125;,&#125;;export default &#123; namespaced: true, state, mutations, actions,&#125;; 3、权限拦截模块src&#x2F;permission.js 这个模块主要是通过路由守卫进行页面权限控制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 路由的拦截权限问题import router from &quot;@/router&quot;;import store from &quot;@/store&quot;;import NProgress from &quot;nprogress&quot;;import &quot;nprogress/nprogress.css&quot;; // 引入进度条样式// 前置守卫const whileList = [&quot;/login&quot;, &quot;/404&quot;];router.beforeEach(async (to, from, next) =&gt; &#123; NProgress.start(); // 开启进度条 // next是一个必须执行的钩子 不执行就卡主了 if (store.getters.token) &#123; if (to.path === &quot;/login&quot;) &#123; // next() 放行 // next(false) 终止 // next(地址) 跳到某个 地址 next(&quot;/&quot;); // 跳到主页 &#125; else &#123; // 要判断是不是已经获取过资料了 if (!store.getters.userId) &#123; // 如果id不存在 意味着当前没有用户资料 就要去获取用户资料 // vuex的action是一个promise const &#123; roles &#125; = await store.dispatch(&quot;user/getUserInfo&quot;); // 此时已经获取完资料 const routes = await store.dispatch( &quot;permission/filterRoutes&quot;, roles.menus ); // 此时得到的routes是当前用户的所拥有的的动态路由的权限 router.addRoutes([ ...routes, &#123; path: &quot;*&quot;, redirect: &quot;/404&quot;, hidden: true &#125;, ]); // 将当前动态路由加到当前路由规则上 // 加await的意思是 强制等待获取完用户资料之后 才去放行 就能保证 用户进到页面时候 有资料 // 添加完路由之后 不能用next() 要用next(to.path) 否则地址不能生效 这算是一个已知 的小缺陷 // 执行完addRoutes 必须执行next(to.path) 不能执行 next() 这是一个已知的问题缺陷 next(to.path); // 解决直接执行next()时的异常 &#125; else &#123; next(); // 放行 &#125; &#125; &#125; else &#123; if (whileList.indexOf(to.path) &gt; -1) &#123; // 表示在白名单里面 next(); &#125; else &#123; next(&quot;/login&quot;); &#125; &#125; NProgress.done(); // 是为了解决手动输入地址时 进度条不关闭的问题&#125;);// 后置守卫router.afterEach(() =&gt; &#123; NProgress.done();&#125;); 4、侧边栏&#x2F;src&#x2F;layout&#x2F;components&#x2F;Siderbar&#x2F;index.vue 最终侧边栏组件根据 store 中的用户路由模块，渲染出用户可以访问的菜单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div :class=&quot;&#123; &#x27;has-logo&#x27;: showLogo &#125;&quot;&gt; &lt;logo v-if=&quot;showLogo&quot; :collapse=&quot;isCollapse&quot; /&gt; &lt;el-scrollbar wrap-class=&quot;scrollbar-wrapper&quot;&gt; &lt;el-menu :default-active=&quot;activeMenu&quot; :collapse=&quot;isCollapse&quot; :background-color=&quot;variables.menuBg&quot; :text-color=&quot;variables.menuText&quot; :unique-opened=&quot;false&quot; :active-text-color=&quot;variables.menuActiveText&quot; :collapse-transition=&quot;false&quot; mode=&quot;vertical&quot; &gt; &lt;sidebar-item v-for=&quot;route in routes&quot; :key=&quot;route.path&quot; :item=&quot;route&quot; :base-path=&quot;route.path&quot; /&gt; &lt;/el-menu&gt; &lt;/el-scrollbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &quot;vuex&quot;;import Logo from &quot;./Logo&quot;;import SidebarItem from &quot;./SidebarItem&quot;;import variables from &quot;@/styles/variables.scss&quot;;export default &#123; components: &#123; SidebarItem, Logo &#125;, computed: &#123; ...mapGetters([&quot;sidebar&quot;, &quot;routes&quot;]), // 路由 addRoutes之后 不会响应式的更新的组件 // 默认静态路由 5条 + addRoutes(6条) = 11条 // routes() &#123; // return this.$router.options.routes // &#125;, activeMenu() &#123; const route = this.$route; const &#123; meta, path &#125; = route; // if set path, the sidebar will highlight the path you set if (meta.activeMenu) &#123; return meta.activeMenu; &#125; return path; &#125;, showLogo() &#123; return this.$store.state.settings.sidebarLogo; &#125;, variables() &#123; return variables; &#125;, isCollapse() &#123; return !this.sidebar.opened; &#125;, &#125;,&#125;;&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"小兔鲜电商项目练手","slug":"小兔鲜电商项目练手","date":"2022-12-05T13:28:44.000Z","updated":"2024-03-12T08:27:10.888Z","comments":true,"path":"2022/12/05/小兔鲜电商项目练手/","link":"","permalink":"https://congtf.top/2022/12/05/%E5%B0%8F%E5%85%94%E9%B2%9C%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%83%E6%89%8B/","excerpt":"","text":"vue 学习推荐去看 vue 官方文档https://cn.vuejs.org/ 视频学习推荐张天禹老师https://www.bilibili.com/video/BV1Zy4y1K7SH/?spm_id_from=333.337.search-card.all.click 一、项目简介这是一个 B2C 电商平台类项目 1、功能模块首页模块：顶部通栏，吸顶导航，网站头部，左侧分类，轮播图，新鲜好物，人气推荐，热门品牌，分类商品推荐，专题推荐，网站底部 一级分类：面包屑，轮播图，全部二级分类，二级分类推荐商品 二级分类：筛选区域，排序功能，商品列表，无限加载。 商品详情：商品图片展示，基本信息展示，配送城市选择，SKU 选择，库存选择，商品详情展示，商品评价展示，24 小时热销，相关专题，加入购物车 购物车：头部购物车：展示商品数量和列表，删除商品，跳转购物车页面。购物车页面：购物车商品展示，选择商品，修改数量，修改商品规格，价格计算，跳转下单 登录模块：表单校验，账户密码登录 订单模块：订单商品展示，收货地址选择，收货地址新增，支付方式选择，生成订单 支付模块：订单信息展示，跳转支付网关，提示正在支付，等待支付结果，跳转支付成功页面。 个人中心：中心首页：展示个人信息，近期收藏商品，近期足迹，猜你喜欢 订单管理：全部订单，待付款，待发货，待收货，待评价，已完成，已取消。立即付款，取消订单，确认收货，删除订单，查看物流。订单详情：订单状态，订单进度，详细信息。 2、技术栈 vue3.x （组合式 API） vite（构件工具） axios（请求接口） vue-router (单页路由) pinia（状态管理） element-plus（适用 vue3 的 UI 组件库） @vueuse&#x2F;core（vue 组合式 API 的工具库） 二、项目初始化1、创建项目1npm init vue@latest 2、jsconfig.json 配置别名路径配置别名路径可以在写代码时联想提示路径 123456789// jsconfig.json文件中 @别名联想提示&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125; &#125;&#125; 这里需要注意的是，这个配置只是让我们在写代码，输入@时有一个路径联想提示的功能。真正实现 src 转化为@功能的是 vite.config.js 中的如下配置 1234567// ...省略其他代码// @别名设置 resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125; 3、ElementPlus 自动按需导入此处可以参考 ElementPlus 官网教程配置自动按需导入，并定制主题。最终配置的 vite.config.js 如下 12345678910111213141516171819202122232425262728293031323334353637383940import &#123; fileURLToPath, URL &#125; from &quot;node:url&quot;;import &#123; defineConfig &#125; from &quot;vite&quot;;import vue from &quot;@vitejs/plugin-vue&quot;;// 配置elementui自动按需导入import AutoImport from &quot;unplugin-auto-import/vite&quot;;import Components from &quot;unplugin-vue-components/vite&quot;;import &#123; ElementPlusResolver &#125; from &quot;unplugin-vue-components/resolvers&quot;;// 导入对应包import ElementPlus from &quot;unplugin-element-plus/vite&quot;;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver(&#123; importStyle: &quot;sass&quot; &#125;)], &#125;), // 按需定制主题配置 ElementPlus(&#123; useSource: true, &#125;), ], // @别名设置 resolve: &#123; alias: &#123; &quot;@&quot;: fileURLToPath(new URL(&quot;./src&quot;, import.meta.url)), &#125;, &#125;, css: &#123; preprocessorOptions: &#123; //按需导入自定义主题和自动导入scss变量 scss: &#123; additionalData: `@use &quot;@/styles/element/index.scss&quot; as *; @use &quot;@/styles/var.scss&quot; as *;`, &#125;, &#125;, &#125;,&#125;); 按照官网教程在 src&#x2F;styles 下新建 element&#x2F;index.scss 定制化的主题样式文件 12345678910111213141516171819202122232425/* 只需要重写你需要的即可 */@forward &quot;element-plus/theme-chalk/src/common/var.scss&quot; with ( $colors: ( &quot;primary&quot;: ( // 主色 &quot;base&quot;: #27ba9b, ), &quot;success&quot;: ( // 成功色 &quot;base&quot;: #1dc779, ), &quot;warning&quot;: ( // 警告色 &quot;base&quot;: #ffb302, ), &quot;danger&quot;: ( // 危险色 &quot;base&quot;: #e26237, ), &quot;error&quot;: ( // 错误色 &quot;base&quot;: #cf4444, ), )); 4、axiosutils 下新建 request.js 1234567891011121314151617181920212223import axios from &quot;axios&quot;;// 创建axios实例const request = axios.create(&#123; baseURL: &quot;http://pcapi-xiaotuxian-front-devtest.itheima.net&quot;, timeout: 5000,&#125;);// axios请求拦截器request.interceptors.request.use( (config) =&gt; &#123; return config; &#125;, (e) =&gt; Promise.reject(e));// axios响应式拦截器request.interceptors.response.use( (res) =&gt; res.data, (e) =&gt; Promise.reject(e));export default request; src 下新建 api 文件夹，之后我们的所有接口将按模块集中管理在这个文件夹下 5、路由12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// router/index.jsimport &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), // history: createWebHistory(&#x27;/#&#x27;), routes: [ &#123; path: &quot;/&quot;, name: &quot;layout&quot;, component: () =&gt; import(&quot;@/views/layout/index.vue&quot;), children: [ &#123; path: &quot;&quot;, name: &quot;home&quot;, component: () =&gt; import(&quot;@/views/layout/components/home/index.vue&quot;), &#125;, &#123; path: &quot;category/sub/:id&quot;, name: &quot;sub-category&quot;, component: () =&gt; import(&quot;@/views/layout/components/sub-category/index.vue&quot;), &#125;, &#123; path: &quot;category/:id&quot;, name: &quot;category&quot;, component: () =&gt; import(&quot;@/views/layout/components/category/index.vue&quot;), &#125;, &#123; path: &quot;goodsInfo/:id&quot;, name: &quot;goodsInfo&quot;, component: () =&gt; import(&quot;@/views/layout/components/goodsInfo/index.vue&quot;), &#125;, &#123; path: &quot;cartList&quot;, name: &quot;cartList&quot;, component: () =&gt; import(&quot;@/views/layout/components/cartList.vue&quot;), &#125;, &#123; path: &quot;orders&quot;, name: &quot;orders&quot;, component: () =&gt; import(&quot;@/views/layout/components/orders/index.vue&quot;), &#125;, &#123; path: &quot;payPage/:id&quot;, name: &quot;payPage&quot;, component: () =&gt; import(&quot;@/views/layout/components/payPage/index.vue&quot;), &#125;, &#123; path: &quot;paycallback&quot;, name: &quot;paycallback&quot;, component: () =&gt; import(&quot;@/views/layout/components/payPage/paycallback.vue&quot;), &#125;, &#123; path: &quot;VIP&quot;, name: &quot;VIP&quot;, component: () =&gt; import(&quot;@/views/layout/components/VIP/index.vue&quot;), children: [ &#123; path: &quot;&quot;, name: &quot;userInfo&quot;, component: () =&gt; import(&quot;@/views/layout/components/VIP/userInfo.vue&quot;), &#125;, &#123; path: &quot;myOrders&quot;, name: &quot;myOrders&quot;, component: () =&gt; import(&quot;@/views/layout/components/VIP/myOrders.vue&quot;), &#125;, ], &#125;, ], &#125;, &#123; path: &quot;/login&quot;, name: &quot;login&quot;, component: () =&gt; import(&quot;@/views/login/index.vue&quot;), &#125;, ], scrollBehavior() &#123; // 始终滚动到顶部 return &#123; top: 0 &#125;; &#125;,&#125;);export default router; 6、静态资源引入样式资源 - 把 common.scss 文件放到 styles 目录下 之后不要忘了在 main.js 中导入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// common.scss// 重置样式* &#123; box-sizing: border-box;&#125;html &#123; height: 100%; font-size: 14px;&#125;body &#123; height: 100%; color: #333; min-width: 1240px; font: 1em/1.4 &quot;Microsoft Yahei&quot;, &quot;PingFang SC&quot;, &quot;Avenir&quot;, &quot;Segoe UI&quot;, &quot;Hiragino Sans GB&quot;, &quot;STHeiti&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;&#125;body,ul,h1,h3,h4,p,dl,dd &#123; padding: 0; margin: 0;&#125;a &#123; text-decoration: none; color: #333; outline: none;&#125;i &#123; font-style: normal;&#125;input[type=&quot;text&quot;],input[type=&quot;search&quot;],input[type=&quot;password&quot;],input[type=&quot;checkbox&quot;] &#123; padding: 0; outline: none; border: none; -webkit-appearance: none; &amp;::placeholder &#123; color: #ccc; &#125;&#125;img &#123; max-width: 100%; max-height: 100%; vertical-align: middle; background: #ebebeb url(&quot;@/assets/images/200.png&quot;) no-repeat center / contain;&#125;ul &#123; list-style: none;&#125;#app &#123; background: #f5f5f5; user-select: none;&#125;.container &#123; width: 1240px; margin: 0 auto; position: relative;&#125;.ellipsis &#123; white-space: nowrap; text-overflow: ellipsis; overflow: hidden;&#125;.ellipsis-2 &#123; word-break: break-all; text-overflow: ellipsis; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden;&#125;.fl &#123; float: left;&#125;.fr &#123; float: right;&#125;.clearfix:after &#123; content: &quot;.&quot;; display: block; visibility: hidden; height: 0; line-height: 0; clear: both;&#125;// reset element.el-breadcrumb__inner.is-link &#123; font-weight: 400 !important;&#125; scss 变量 1234567// styles/var.scss$xtxColor: #27ba9b;$helpColor: #e26237;$sucColor: #1dc779;$warnColor: #ffb302;$priceColor: #cf4444; 三、Layout 组件1、总体架构本项目一级路由有 Login 组件、Layout 组件，当然还可以有 404 组件（我并没有做） Layout 组件结构如下 因此，依次创建 4 个组件并导入到 Layout 组件 1234567891011121314151617181920212223242526&lt;script setup&gt;import Topnav from &quot;./components/topnav.vue&quot;;import Header from &quot;./components/header.vue&quot;;import Footer from &quot;./components/footer.vue&quot;;import HeaderSticky from &quot;./components/header-sticky.vue&quot;;import &#123; useScroll &#125; from &quot;@vueuse/core&quot;;import &#123; useCategoryStore &#125; from &quot;@/stores/category&quot;;const &#123; y &#125; = useScroll(window);const &#123; getCategory &#125; = useCategoryStore();getCategory();&lt;/script&gt;&lt;template&gt; &lt;!-- 顶部Nav栏 --&gt; &lt;Topnav /&gt; &lt;!-- 顶部导航栏 --&gt; &lt;Header /&gt; &lt;!-- 吸顶导航 --&gt; &lt;HeaderSticky :y=&quot;y&quot; /&gt; &lt;!-- 中间二级菜单 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 底部 --&gt; &lt;Footer /&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt; 其中的 Topnav 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;script setup&gt;import &#123; useUserInfoStore &#125; from &quot;@/stores/userInfo.js&quot;;import &#123; useRouter &#125; from &quot;vue-router&quot;;const router = useRouter();const &#123; userInfo, clearUserInfo &#125; = useUserInfoStore();// 确认退出const confirm = () =&gt; &#123; clearUserInfo(); router.push(&quot;/login&quot;);&#125;;&lt;/script&gt;&lt;template&gt; &lt;nav class=&quot;app-topnav&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul&gt; &lt;template v-if=&quot;userInfo.account&quot;&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot; &gt;&lt;i class=&quot;iconfont icon-user&quot;&gt;&lt;/i&gt;&#123;&#123; userInfo.account &#125;&#125;&lt;/a &gt; &lt;/li&gt; &lt;li&gt; &lt;el-popconfirm title=&quot;确认退出吗?&quot; confirm-button-text=&quot;确认&quot; cancel-button-text=&quot;取消&quot; @confirm=&quot;confirm&quot; &gt; &lt;template #reference&gt; &lt;a href=&quot;javascript:;&quot;&gt;退出登录&lt;/a&gt; &lt;/template&gt; &lt;/el-popconfirm&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;我的订单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/VIP&quot;&gt;会员中心&lt;/a&gt;&lt;/li&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;li&gt;&lt;a href=&quot;/login&quot;&gt;请先登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;帮助中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.app-topnav &#123; background: #333; ul &#123; display: flex; height: 53px; justify-content: flex-end; align-items: center; li &#123; a &#123; padding: 0 15px; color: #cdcdcd; line-height: 1; display: inline-block; i &#123; font-size: 14px; margin-right: 2px; &#125; &amp;:hover &#123; color: $xtxColor; &#125; &#125; ~ li &#123; a &#123; border-left: 2px solid #666; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; Header 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;script setup&gt;import &#123; toRefs &#125; from &quot;vue&quot;;import &#123; useCategoryStore &#125; from &quot;@/stores/category&quot;;import HeadCart from &quot;./headCart.vue&quot;;const &#123; categoryList &#125; = toRefs(useCategoryStore());&lt;/script&gt;&lt;template&gt; &lt;header class=&quot;app-header&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;logo&quot;&gt; &lt;RouterLink to=&quot;/&quot;&gt;小兔鲜&lt;/RouterLink&gt; &lt;/h1&gt; &lt;ul class=&quot;app-header-nav&quot;&gt; &lt;li class=&quot;home&quot;&gt; &lt;RouterLink to=&quot;/&quot;&gt;首页&lt;/RouterLink&gt; &lt;/li&gt; &lt;li v-for=&quot;item in categoryList&quot; :key=&quot;item.id&quot;&gt; &lt;RouterLink :to=&quot;`/category/$&#123;item.id&#125;`&quot; active-class=&quot;active&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/RouterLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;search&quot;&gt; &lt;i class=&quot;iconfont icon-search&quot;&gt;&lt;/i&gt; &lt;input type=&quot;text&quot; placeholder=&quot;搜一搜&quot; /&gt; &lt;/div&gt; &lt;!-- 头部购物车 --&gt; &lt;HeadCart /&gt; &lt;/div&gt; &lt;/header&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.app-header &#123; background: #fff; .container &#123; display: flex; align-items: center; &#125; .logo &#123; width: 200px; a &#123; display: block; height: 132px; width: 100%; text-indent: -9999px; background: url(&quot;@/assets/images/logo.png&quot;) no-repeat center 18px / contain; &#125; &#125; .app-header-nav &#123; width: 820px; display: flex; padding-left: 40px; position: relative; z-index: 998; li &#123; margin-right: 40px; width: 38px; text-align: center; a &#123; font-size: 16px; line-height: 32px; height: 32px; display: inline-block; &amp;:hover &#123; color: $xtxColor; border-bottom: 1px solid $xtxColor; &#125; &#125; .active &#123; color: $xtxColor; border-bottom: 1px solid $xtxColor; &#125; &#125; &#125; .search &#123; width: 170px; height: 32px; position: relative; border-bottom: 1px solid #e7e7e7; line-height: 32px; .icon-search &#123; font-size: 18px; margin-left: 5px; &#125; input &#123; width: 140px; padding-left: 5px; color: #666; &#125; &#125; .cart &#123; width: 50px; .curr &#123; height: 32px; line-height: 32px; text-align: center; position: relative; display: block; .icon-cart &#123; font-size: 22px; &#125; em &#123; font-style: normal; position: absolute; right: 0; top: 0; padding: 1px 6px; line-height: 1; background: $helpColor; color: #fff; font-size: 12px; border-radius: 10px; font-family: Arial; &#125; &#125; &#125;&#125;&lt;/style&gt; HeaderSticky 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;script setup&gt;import &#123; toRefs &#125; from &quot;vue&quot;;import &#123; useCategoryStore &#125; from &quot;@/stores/category&quot;;defineProps(&#123; y: &#123; type: Number, required: true, &#125;,&#125;);const &#123; categoryList &#125; = toRefs(useCategoryStore());&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;app-header-sticky&quot; :class=&quot;&#123; show: y &gt; 78 &#125;&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;RouterLink class=&quot;logo&quot; to=&quot;/&quot; /&gt; &lt;!-- 导航区域 --&gt; &lt;ul class=&quot;app-header-nav&quot;&gt; &lt;li class=&quot;home&quot;&gt; &lt;RouterLink to=&quot;/&quot;&gt;首页&lt;/RouterLink&gt; &lt;/li&gt; &lt;li v-for=&quot;item in categoryList&quot; :key=&quot;item.id&quot;&gt; &lt;RouterLink :to=&quot;`/category/$&#123;item.id&#125;`&quot; active-class=&quot;active&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/RouterLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;right&quot;&gt; &lt;RouterLink to=&quot;/&quot;&gt;品牌&lt;/RouterLink&gt; &lt;RouterLink to=&quot;/&quot;&gt;专题&lt;/RouterLink&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.app-header-sticky &#123; width: 100%; height: 80px; position: fixed; left: 0; top: 0; z-index: 999; background-color: #fff; border-bottom: 1px solid #e4e4e4; // 此处为关键样式!!! // 状态一：往上平移自身高度 + 完全透明 transform: translateY(-100%); opacity: 0; // 状态二：移除平移 + 完全不透明 &amp;.show &#123; transition: all 0.3s linear; transform: none; opacity: 1; &#125; .container &#123; display: flex; align-items: center; &#125; .logo &#123; width: 200px; height: 80px; background: url(&quot;@/assets/images/logo.png&quot;) no-repeat right 2px; background-size: 160px auto; &#125; .right &#123; width: 220px; display: flex; text-align: center; padding-left: 40px; border-left: 2px solid $xtxColor; a &#123; width: 38px; margin-right: 40px; font-size: 16px; line-height: 1; &amp;:hover &#123; color: $xtxColor; &#125; &#125; &#125;&#125;.app-header-nav &#123; width: 820px; display: flex; padding-left: 40px; position: relative; z-index: 998; li &#123; margin-right: 40px; width: 38px; text-align: center; a &#123; font-size: 16px; line-height: 32px; height: 32px; display: inline-block; &amp;:hover &#123; color: $xtxColor; border-bottom: 1px solid $xtxColor; &#125; &#125; .active &#123; color: $xtxColor; border-bottom: 1px solid $xtxColor; &#125; &#125;&#125;&lt;/style&gt; Footer 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230&lt;template&gt; &lt;footer class=&quot;app_footer&quot;&gt; &lt;!-- 联系我们 --&gt; &lt;div class=&quot;contact&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;dl&gt; &lt;dt&gt;客户服务&lt;/dt&gt; &lt;dd&gt;&lt;i class=&quot;iconfont icon-kefu&quot;&gt;&lt;/i&gt; 在线客服&lt;/dd&gt; &lt;dd&gt;&lt;i class=&quot;iconfont icon-question&quot;&gt;&lt;/i&gt; 问题反馈&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;关注我们&lt;/dt&gt; &lt;dd&gt;&lt;i class=&quot;iconfont icon-weixin&quot;&gt;&lt;/i&gt; 公众号&lt;/dd&gt; &lt;dd&gt;&lt;i class=&quot;iconfont icon-weibo&quot;&gt;&lt;/i&gt; 微博&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;下载APP&lt;/dt&gt; &lt;dd class=&quot;qrcode&quot;&gt;&lt;img src=&quot;@/assets/images/qrcode.jpg&quot; /&gt;&lt;/dd&gt; &lt;dd class=&quot;download&quot;&gt; &lt;span&gt;扫描二维码&lt;/span&gt; &lt;span&gt;立马下载APP&lt;/span&gt; &lt;a href=&quot;javascript:;&quot;&gt;下载页面&lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;服务热线&lt;/dt&gt; &lt;dd class=&quot;hotline&quot;&gt; 400-0000-000 &lt;small&gt;周一至周日 8:00-18:00&lt;/small&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 其它 --&gt; &lt;div class=&quot;extra&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;slogan&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;iconfont icon-footer01&quot;&gt;&lt;/i&gt; &lt;span&gt;价格亲民&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;iconfont icon-footer02&quot;&gt;&lt;/i&gt; &lt;span&gt;物流快捷&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;iconfont icon-footer03&quot;&gt;&lt;/i&gt; &lt;span&gt;品质新鲜&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- 版权信息 --&gt; &lt;div class=&quot;copyright&quot;&gt; &lt;p&gt; &lt;a href=&quot;javascript:;&quot;&gt;关于我们&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;帮助中心&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;售后服务&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;配送与验收&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;商务合作&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;搜索推荐&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;友情链接&lt;/a&gt; &lt;/p&gt; &lt;p&gt;CopyRight © 小兔鲜儿&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/footer&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.app_footer &#123; overflow: hidden; background-color: #f5f5f5; padding-top: 20px; .contact &#123; background: #fff; .container &#123; padding: 60px 0 40px 25px; display: flex; &#125; dl &#123; height: 190px; text-align: center; padding: 0 72px; border-right: 1px solid #f2f2f2; color: #999; &amp;:first-child &#123; padding-left: 0; &#125; &amp;:last-child &#123; border-right: none; padding-right: 0; &#125; &#125; dt &#123; line-height: 1; font-size: 18px; &#125; dd &#123; margin: 36px 12px 0 0; float: left; width: 92px; height: 92px; padding-top: 10px; border: 1px solid #ededed; .iconfont &#123; font-size: 36px; display: block; color: #666; &#125; &amp;:hover &#123; .iconfont &#123; color: $xtxColor; &#125; &#125; &amp;:last-child &#123; margin-right: 0; &#125; &#125; .qrcode &#123; width: 92px; height: 92px; padding: 7px; border: 1px solid #ededed; &#125; .download &#123; padding-top: 5px; font-size: 14px; width: auto; height: auto; border: none; span &#123; display: block; &#125; a &#123; display: block; line-height: 1; padding: 10px 25px; margin-top: 5px; color: #fff; border-radius: 2px; background-color: $xtxColor; &#125; &#125; .hotline &#123; padding-top: 20px; font-size: 22px; color: #666; width: auto; height: auto; border: none; small &#123; display: block; font-size: 15px; color: #999; &#125; &#125; &#125; .extra &#123; background-color: #333; &#125; .slogan &#123; height: 178px; line-height: 58px; padding: 60px 100px; border-bottom: 1px solid #434343; display: flex; justify-content: space-between; a &#123; height: 58px; line-height: 58px; color: #fff; font-size: 28px; i &#123; font-size: 50px; vertical-align: middle; margin-right: 10px; font-weight: 100; &#125; span &#123; vertical-align: middle; text-shadow: 0 0 1px #333; &#125; &#125; &#125; .copyright &#123; height: 170px; padding-top: 40px; text-align: center; color: #999; font-size: 15px; p &#123; line-height: 1; margin-bottom: 20px; &#125; a &#123; color: #999; line-height: 1; padding: 0 10px; border-right: 1px solid #999; &amp;:last-child &#123; border-right: none; &#125; &#125; &#125;&#125;&lt;/style&gt; 2、吸顶交互效果实现吸顶交互效果的核心逻辑：根据滚动距离判断当前 show 类名是否显示，大于 78 显示，小于 78，不显示 这里我们使用@vueuse&#x2F;core 提供的 useScroll 方法可以很方便的实现获取页面滚动距离的目的 VueUse 是一个为 Vue 组合式 API 提供服务的工具库，也就是说在 Vue 选项式 API 中它将不能使用 VueUse 官网https://vueuse.org/ 3、Pinia 优化重复请求注意到获取商品的分类信息在多个模块中都会用到，为了避免重复请求，我们将其抽取成一个 store 模块 在 src&#x2F;stores 中新建 categoryStore.js 123456789101112131415import &#123; ref &#125; from &quot;vue&quot;;import &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; getCategoryAPI &#125; from &quot;@/apis/layout&quot;;export const useCategoryStore = defineStore(&quot;category&quot;, () =&gt; &#123; //分类列表数据 const isLoading = ref(true); const categoryList = ref([]); function getCategory() &#123; getCategoryAPI().then((res) =&gt; &#123; categoryList.value = res.data.result; isLoading.value = false; &#125;); &#125; return &#123; categoryList, getCategory, isLoading &#125;;&#125;); 四、Home 页1、总体架构Home 页整体结构如下 按照结构新增五个组件，并在 Home 模块的入口组件中引入 Home&#x2F;index.vue 123456789101112131415161718192021222324&lt;script setup&gt;import HomeCategory from &quot;./HomeCategory.vue&quot;;import HomeBanner from &quot;./HomeBanner.vue&quot;;import HomeHot from &quot;./HomeHot.vue&quot;;import HomeNew from &quot;./HomeNew.vue&quot;;import HomeProduct from &quot;./HomeProduct.vue&quot;;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 分类区域 --&gt; &lt;HomeCategory /&gt; &lt;!-- 轮播图区域 --&gt; &lt;HomeBanner /&gt; &lt;/div&gt; &lt;!-- 新鲜好物区域 --&gt; &lt;HomeNew /&gt; &lt;!-- 人气推荐区域 --&gt; &lt;HomeHot /&gt; &lt;!-- 产品列表区域 --&gt; &lt;HomeProduct /&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt; 其中 HomeCategory 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176&lt;script setup&gt;import &#123; toRefs &#125; from &quot;vue&quot;;import &#123; useCategoryStore &#125; from &quot;@/stores/category&quot;;const &#123; categoryList, isLoading &#125; = toRefs(useCategoryStore());&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;home-category&quot;&gt; &lt;ul class=&quot;menu&quot;&gt; &lt;li v-for=&quot;item in categoryList&quot; :key=&quot;item.id&quot;&gt; &lt;!-- 骨架屏 --&gt; &lt;el-skeleton style=&quot;width: 200px&quot; :loading=&quot;isLoading&quot; animated :throttle=&quot;10000&quot; &gt; &lt;template #template&gt; &lt;el-skeleton-item variant=&quot;p&quot; style=&quot;width: 32px; height: 20px&quot; /&gt; &lt;el-skeleton-item variant=&quot;p&quot; style=&quot;width: 100px; margin-left: 10px&quot; /&gt; &lt;/template&gt; &lt;template #default&gt; &lt;RouterLink :to=&quot;`/category/$&#123;item.id&#125;`&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/RouterLink&gt; &lt;RouterLink v-for=&quot;i in item.children.slice(0, 2)&quot; :key=&quot;i.id&quot; :to=&quot;`/category/sub/$&#123;i.id&#125;`&quot; &gt;&#123;&#123; i.name &#125;&#125;&lt;/RouterLink &gt; &lt;/template&gt; &lt;/el-skeleton&gt; &lt;!-- 弹层layer位置 --&gt; &lt;div class=&quot;layer&quot;&gt; &lt;h4&gt;分类推荐 &lt;small&gt;根据您的购买或浏览记录推荐&lt;/small&gt;&lt;/h4&gt; &lt;ul&gt; &lt;li v-for=&quot;i in item.goods&quot; :key=&quot;i.id&quot;&gt; &lt;RouterLink :to=&quot;`/goodsInfo/$&#123;i.id&#125;`&quot;&gt; &lt;img alt=&quot;&quot; :src=&quot;i.picture&quot; /&gt; &lt;div class=&quot;info&quot;&gt; &lt;p class=&quot;name ellipsis-2&quot;&gt;&#123;&#123; i.name &#125;&#125;&lt;/p&gt; &lt;p class=&quot;desc ellipsis&quot;&gt;&#123;&#123; i.desc &#125;&#125;&lt;/p&gt; &lt;p class=&quot;price&quot;&gt;&lt;i&gt;¥&lt;/i&gt;&#123;&#123; i.price &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/RouterLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.home-category &#123; width: 250px; height: 500px; background: rgba(0, 0, 0, 0.8); position: relative; z-index: 99; .menu &#123; li &#123; padding-left: 40px; height: 55px; line-height: 55px; &amp;:hover &#123; background: $xtxColor; &#125; a &#123; margin-right: 4px; color: #fff; &amp;:first-child &#123; font-size: 16px; &#125; &#125; .layer &#123; width: 990px; height: 500px; background: rgba(255, 255, 255, 0.8); position: absolute; left: 250px; top: 0; display: none; padding: 0 15px; h4 &#123; font-size: 20px; font-weight: normal; line-height: 80px; small &#123; font-size: 16px; color: #666; &#125; &#125; ul &#123; display: flex; flex-wrap: wrap; li &#123; width: 310px; height: 120px; margin-right: 15px; margin-bottom: 15px; border: 1px solid #eee; border-radius: 4px; background: #fff; &amp;:nth-child(3n) &#123; margin-right: 0; &#125; a &#123; display: flex; width: 100%; height: 100%; align-items: center; padding: 10px; &amp;:hover &#123; background: #e3f9f4; &#125; img &#123; width: 95px; height: 95px; &#125; .info &#123; padding-left: 10px; line-height: 24px; overflow: hidden; .name &#123; font-size: 16px; color: #666; &#125; .desc &#123; color: #999; &#125; .price &#123; font-size: 22px; color: $priceColor; i &#123; font-size: 16px; &#125; &#125; &#125; &#125; &#125; &#125; &#125; // 关键样式 hover状态下的layer盒子变成block &amp;:hover &#123; .layer &#123; display: block; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; HomeBanner 组件 12345678910111213141516171819202122232425262728293031323334&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;import &#123; getBannerAPI &#125; from &quot;@/apis/home&quot;;const bannerList = ref([]);getBannerAPI().then((res) =&gt; &#123; bannerList.value = res.data.result;&#125;);&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;home-banner&quot;&gt; &lt;el-carousel height=&quot;500px&quot;&gt; &lt;el-carousel-item v-for=&quot;item in bannerList&quot; :key=&quot;item.id&quot;&gt; &lt;img :src=&quot;item.imgUrl&quot; alt=&quot;&quot; /&gt; &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.home-banner &#123; width: 1240px; height: 500px; position: absolute; left: 0; top: 0; z-index: 98; img &#123; width: 100%; height: 500px; &#125;&#125;&lt;/style&gt; HomeNew 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;script setup&gt;import HomePanel from &quot;./HomePanel.vue&quot;;import &#123; getNewList &#125; from &quot;@/apis/home&quot;;import &#123; useRequestLazy &#125; from &quot;@/hooks/request-lazy&quot;;const &#123; target, list, isLoading &#125; = useRequestLazy(getNewList);&lt;/script&gt;&lt;template&gt; &lt;HomePanel title=&quot;新鲜好物&quot; sub-title=&quot;新鲜出炉 品质靠谱&quot; ref=&quot;target&quot;&gt; &lt;ul class=&quot;goods-list&quot;&gt; &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;!-- 骨架屏 --&gt; &lt;el-skeleton style=&quot;width: 306px&quot; animated :loading=&quot;isLoading&quot;&gt; &lt;template #template&gt; &lt;el-skeleton-item variant=&quot;image&quot; style=&quot;width: 306px; height: 306px&quot; /&gt; &lt;div style=&quot;padding: 14px; text-align: center&quot;&gt; &lt;el-skeleton-item variant=&quot;p&quot; style=&quot;width: 50%&quot; /&gt; &lt;div style=&quot;display: flex; align-items: center; justify-items: space-between&quot; &gt; &lt;el-skeleton-item variant=&quot;text&quot; style=&quot;margin-right: 16px&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;template #default&gt; &lt;RouterLink :to=&quot;`/goodsInfo/$&#123;item.id&#125;`&quot;&gt; &lt;img :src=&quot;item.picture&quot; alt=&quot;&quot; /&gt; &lt;p&gt;&#123;&#123; item.name &#125;&#125;&lt;/p&gt; &lt;p class=&quot;price&quot;&gt;&amp;yen;&#123;&#123; item.price &#125;&#125;&lt;/p&gt; &lt;/RouterLink&gt; &lt;/template&gt; &lt;/el-skeleton&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/HomePanel&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.goods-list &#123; display: flex; justify-content: space-between; height: 406px; li &#123; width: 306px; height: 406px; background: #f0f9f4; transition: all 0.5s; &amp;:hover &#123; transform: translate3d(0, -3px, 0); box-shadow: 0 3px 8px rgb(0 0 0 / 20%); &#125; img &#123; width: 306px; height: 306px; &#125; p &#123; font-size: 22px; padding-top: 12px; text-align: center; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; &#125; .price &#123; color: $priceColor; &#125; &#125;&#125;&lt;/style&gt; 这里由于几个模块结构类似，因此封装了一个 HomePanel 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;script setup lang=&quot;ts&quot;&gt;defineProps(&#123; title: &#123; type: String, require: true, &#125;, subTitle: &#123; type: String, require: true, &#125;,&#125;);&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;home-panel&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;!-- 主标题和副标题 --&gt; &lt;h3&gt; &#123;&#123; title &#125;&#125;&lt;small&gt;&#123;&#123; subTitle &#125;&#125;&lt;/small&gt; &lt;/h3&gt; &lt;/div&gt; &lt;!-- 主体内容区域 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.home-panel &#123; background-color: #fff; .head &#123; padding: 40px 0; display: flex; align-items: flex-end; h3 &#123; flex: 1; font-size: 32px; font-weight: normal; margin-left: 6px; height: 35px; line-height: 35px; small &#123; font-size: 16px; color: #999; margin-left: 20px; &#125; &#125; &#125;&#125;&lt;/style&gt; HomeHot 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;script setup&gt;import HomePanel from &quot;./HomePanel.vue&quot;;import &#123; getHotList &#125; from &quot;@/apis/home&quot;;import &#123; useRequestLazy &#125; from &quot;@/hooks/request-lazy&quot;;const &#123; target, list, isLoading &#125; = useRequestLazy(getHotList);&lt;/script&gt;&lt;template&gt; &lt;HomePanel title=&quot;人气推荐&quot; sub-title=&quot;人气爆款 不容错过&quot; ref=&quot;target&quot;&gt; &lt;ul class=&quot;goods-list&quot;&gt; &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;!-- 骨架屏 --&gt; &lt;el-skeleton style=&quot;width: 306px&quot; animated :loading=&quot;isLoading&quot;&gt; &lt;template #template&gt; &lt;el-skeleton-item variant=&quot;image&quot; style=&quot;width: 306px; height: 306px&quot; /&gt; &lt;div style=&quot;padding: 14px; text-align: center&quot;&gt; &lt;el-skeleton-item variant=&quot;p&quot; style=&quot;width: 50%&quot; /&gt; &lt;div style=&quot;display: flex; align-items: center; justify-items: space-between&quot; &gt; &lt;el-skeleton-item variant=&quot;text&quot; style=&quot;margin-right: 16px&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;template #default&gt; &lt;RouterLink to=&quot;/&quot;&gt; &lt;img :src=&quot;item.picture&quot; alt=&quot;&quot; /&gt; &lt;p class=&quot;name&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/p&gt; &lt;p class=&quot;alt&quot;&gt;&#123;&#123; item.alt &#125;&#125;&lt;/p&gt; &lt;/RouterLink&gt; &lt;/template&gt; &lt;/el-skeleton&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/HomePanel&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.goods-list &#123; display: flex; justify-content: space-between; height: 406px; li &#123; width: 306px; height: 406px; background: #f0f9f4; transition: all 0.5s; &amp;:hover &#123; transform: translate3d(0, -3px, 0); box-shadow: 0 3px 8px rgb(0 0 0 / 20%); &#125; img &#123; width: 306px; height: 306px; &#125; p &#123; font-size: 22px; padding-top: 12px; text-align: center; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; &#125; .alt &#123; font-size: 18px; color: #b5b5b5; &#125; &#125;&#125;&lt;/style&gt; HomeProduct 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;import HomePanel from &quot;./HomePanel.vue&quot;;import &#123; getGoods &#125; from &quot;@/apis/home&quot;;const goodsList = ref([]);getGoods().then((res) =&gt; &#123; goodsList.value = res.data.result;&#125;);&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;home-product&quot;&gt; &lt;HomePanel :title=&quot;cate.name&quot; v-for=&quot;cate in goodsList&quot; :key=&quot;cate.id&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;RouterLink class=&quot;cover&quot; :to=&quot;`/category/$&#123;cate.id&#125;`&quot;&gt; &lt;el-image lazy fit=&quot;fill&quot; :src=&quot;cate.picture&quot;&gt; &lt;template #error&gt; &lt;div class=&quot;image-slot&quot;&gt; &lt;el-image src=&quot;@/assets/images/200.png&quot;&gt;&lt;/el-image&gt; &lt;/div&gt; &lt;/template&gt; &lt;/el-image&gt; &lt;strong class=&quot;label&quot;&gt; &lt;span&gt;&#123;&#123; cate.name &#125;&#125;馆&lt;/span&gt; &lt;span&gt;&#123;&#123; cate.saleInfo &#125;&#125;&lt;/span&gt; &lt;/strong&gt; &lt;/RouterLink&gt; &lt;ul class=&quot;goods-list&quot;&gt; &lt;li v-for=&quot;good in cate.goods&quot; :key=&quot;good.id&quot;&gt; &lt;GoodsItem :goods=&quot;good&quot; /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/HomePanel&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.home-product &#123; background: #fff; margin-top: -20px; .sub &#123; margin-bottom: 2px; a &#123; padding: 2px 12px; font-size: 16px; border-radius: 4px; &amp;:hover &#123; background: $xtxColor; color: #fff; &#125; &amp;:last-child &#123; margin-right: 80px; &#125; &#125; &#125; .box &#123; display: flex; .cover &#123; width: 240px; height: 610px; margin-right: 10px; position: relative; img &#123; width: 100%; height: 100%; &#125; .label &#123; width: 188px; height: 66px; display: flex; font-size: 18px; color: #fff; line-height: 66px; font-weight: normal; position: absolute; left: 0; top: 50%; transform: translate3d(0, -50%, 0); span &#123; text-align: center; &amp;:first-child &#123; width: 76px; background: rgba(0, 0, 0, 0.9); &#125; &amp;:last-child &#123; flex: 1; background: rgba(0, 0, 0, 0.7); &#125; &#125; &#125; &#125; .goods-list &#123; width: 990px; display: flex; flex-wrap: wrap; li &#123; width: 240px; height: 300px; margin-right: 10px; margin-bottom: 10px; &amp;:nth-last-child(-n + 4) &#123; margin-bottom: 0; &#125; &amp;:nth-child(4n) &#123; margin-right: 0; &#125; &#125; &#125; .goods-item &#123; display: block; width: 220px; padding: 20px 30px; text-align: center; transition: all 0.5s; &amp;:hover &#123; transform: translate3d(0, -3px, 0); box-shadow: 0 3px 8px rgb(0 0 0 / 20%); &#125; img &#123; width: 160px; height: 160px; &#125; p &#123; padding-top: 10px; &#125; .name &#123; font-size: 16px; &#125; .desc &#123; color: #999; height: 29px; &#125; .price &#123; color: $priceColor; font-size: 20px; &#125; &#125; &#125;&#125;&lt;/style&gt; 同样的结构类似，并且在后面的模块中会多次用到。因此在 src&#x2F;components 下封装一个全局组件 GoodsItem 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;script setup&gt;import errorIMG from &quot;@/assets/images/200.png&quot;;defineProps(&#123; goods: &#123; type: Object, default: () =&gt; &#123;&#125;, &#125;,&#125;);&lt;/script&gt;&lt;template&gt; &lt;RouterLink :to=&quot;`/goodsInfo/$&#123;goods.id&#125;`&quot; class=&quot;goods-item&quot;&gt; &lt;el-image lazy :src=&quot;goods.picture&quot; alt=&quot;&quot;&gt; &lt;template #error&gt; &lt;div class=&quot;image-slot&quot;&gt; &lt;el-image :src=&quot;errorIMG&quot;&gt;&lt;/el-image&gt; &lt;/div&gt; &lt;/template&gt; &lt;/el-image&gt; &lt;p class=&quot;name ellipsis&quot;&gt;&#123;&#123; goods.name &#125;&#125;&lt;/p&gt; &lt;p class=&quot;desc ellipsis&quot;&gt;&#123;&#123; goods.desc &#125;&#125;&lt;/p&gt; &lt;p class=&quot;price&quot;&gt;&amp;yen;&#123;&#123; goods.price &#125;&#125;&lt;/p&gt; &lt;/RouterLink&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.goods-item &#123; display: block; width: 220px; padding: 20px 30px; text-align: center; transition: all 0.5s; &amp;:hover &#123; transform: translate3d(0, -3px, 0); box-shadow: 0 3px 8px rgb(0 0 0 / 20%); &#125; img &#123; width: 160px; height: 160px; &#125; p &#123; padding-top: 10px; &#125; .name &#123; font-size: 16px; &#125; .desc &#123; color: #999; height: 29px; &#125; .price &#123; color: $priceColor; font-size: 20px; &#125;&#125;&lt;/style&gt; 不要忘了全局注册它 在 src&#x2F;components&#x2F;index.js 1234567// 通用组件全局注册import GoodsItem from &quot;./GoodsItem.vue&quot;;export default &#123; install(app) &#123; app.component(&quot;GoodsItem&quot;, GoodsItem); &#125;,&#125;; main.js 中 1234// ...省略其他代码import Components from &quot;./components/index.js&quot;;app.use(Components);// ...省略其他代码 2、实现数据懒加载和图片懒加载对于这种页面较长的网页，可以使用数据懒加载来优化性能。 数据懒加载的核心逻辑：当页面滚动到当前模块，也即模块在可视区域时才发起请求加载数据。而不是一上来就将数据全部加载。问题的关键在于如何判断模块是否处于可视区域了呢。 这里同样使用@vueuse&#x2F;core 提供的 useIntersectionObserver 方法，它可以方便的检测模块是否处于可视区域 由于这是一个公共的方法，因此在 src 下新建 hooks&#x2F;request-lazy.js 123456789101112131415161718192021222324252627// 利用vueuse的useIntersectionObserver封装一个请求懒加载的方法import &#123; ref &#125; from &quot;vue&quot;;import &#123; useIntersectionObserver &#125; from &quot;@vueuse/core&quot;;export function useRequestLazy(apiFn) &#123; // 定义一个判断数据是否在加载的变量 const isLoading = ref(true); // 监视的目标ref对象容器，最后返回出去 const target = ref(null); // 发送请求得到的数据 const list = ref([]); const &#123; stop &#125; = useIntersectionObserver(target, ([&#123; isIntersecting &#125;]) =&gt; &#123; // 进入可视区域的逻辑 if (isIntersecting) &#123; stop(); apiFn().then((res) =&gt; &#123; list.value = res.data.result; isLoading.value = false; &#125;); &#125; &#125;); return &#123; target, list, isLoading, &#125;;&#125; 以后就可以在需要做数据懒加载的地方使用它了 图片懒加载我直接使用了 el-image 的 lazy 属性，当然也可以自己封装一个图片懒加载自定义指令来实现。图片懒加载自定义指令的核心逻辑与数据懒加载一样，因此它主要还是用到@vueuse&#x2F;core 提供的 useIntersectionObserver 方法 3、骨架屏效果为了优化用户体验，这种涉及图片较多、页面较长、加载速度可能较慢的网站，可以使用骨架屏效果 **但是，这个项目我用 Element-Plus 提供的骨架屏组件始终不生效，不知道哪里不对**😂😂😂 五、一级分类页1、总体架构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;script setup&gt;import &#123; getTopCategoryAPI &#125; from &quot;@/apis/category&quot;;import &#123; ref &#125; from &quot;vue&quot;;import &#123; useRoute, onBeforeRouteUpdate &#125; from &quot;vue-router&quot;;import &#123; getBannerAPI &#125; from &quot;@/apis/home&quot;;const route = useRoute();// 获取一级分类数据const categoryData = ref(&#123;&#125;);const getTopCategory = (id) =&gt; &#123; getTopCategoryAPI(id).then((res) =&gt; &#123; categoryData.value = res.data.result; &#125;);&#125;;getTopCategory(route.params.id);// 会有缓存问题：当路由path一样，参数不同的时候会优先复用路由对应的组件，而不是销毁重建,调用onBeforeRouteUpdate解决该问题，它能检测路由变化onBeforeRouteUpdate((to) =&gt; getTopCategory(to.params.id));// 获取轮播图数据const bannerList = ref([]);getBannerAPI(2).then((res) =&gt; &#123; bannerList.value = res.data.result;&#125;);&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;top-category&quot;&gt; &lt;div class=&quot;container m-top-20&quot;&gt; &lt;!-- 面包屑 --&gt; &lt;div class=&quot;bread-container&quot;&gt; &lt;el-breadcrumb separator=&quot;&gt;&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/&#x27; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;&#123;&#123; categoryData.name &#125;&#125;&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;/div&gt; &lt;!-- 轮播图 --&gt; &lt;el-carousel height=&quot;500px&quot; class=&quot;container&quot;&gt; &lt;el-carousel-item v-for=&quot;item in bannerList&quot; :key=&quot;item.id&quot;&gt; &lt;img :src=&quot;item.imgUrl&quot; alt=&quot;&quot; /&gt; &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;!-- 分类数据 --&gt; &lt;div class=&quot;sub-list&quot;&gt; &lt;h3&gt;全部分类&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=&quot;i in categoryData.children&quot; :key=&quot;i.id&quot;&gt; &lt;RouterLink :to=&quot;`/category/sub/$&#123;i.id&#125;`&quot;&gt; &lt;img :src=&quot;i.picture&quot; /&gt; &lt;p&gt;&#123;&#123; i.name &#125;&#125;&lt;/p&gt; &lt;/RouterLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;ref-goods&quot; v-for=&quot;item in categoryData.children&quot; :key=&quot;item.id&quot; &gt; &lt;div class=&quot;head&quot;&gt; &lt;h3&gt;- &#123;&#123; item.name &#125;&#125;-&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;body&quot;&gt; &lt;GoodsItem v-for=&quot;good in item.goods&quot; :goods=&quot;good&quot; :key=&quot;good.id&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.top-category &#123; h3 &#123; font-size: 28px; color: #666; font-weight: normal; text-align: center; line-height: 100px; &#125; .sub-list &#123; margin-top: 20px; background-color: #fff; ul &#123; display: flex; padding: 0 32px; flex-wrap: wrap; li &#123; width: 168px; height: 160px; a &#123; text-align: center; display: block; font-size: 16px; img &#123; width: 100px; height: 100px; &#125; p &#123; line-height: 40px; &#125; &amp;:hover &#123; color: $xtxColor; &#125; &#125; &#125; &#125; &#125; .ref-goods &#123; background-color: #fff; margin-top: 20px; position: relative; .head &#123; .xtx-more &#123; position: absolute; top: 20px; right: 20px; &#125; .tag &#123; text-align: center; color: #999; font-size: 20px; position: relative; top: -20px; &#125; &#125; .body &#123; display: flex; justify-content: space-around; padding: 0 40px 30px; &#125; &#125; .bread-container &#123; padding: 25px 0; &#125;&#125;&lt;/style&gt; 2、路由缓存问题解决使用带有参数的路由时需要注意的是，当路由 path 一样，参数不同的时候相同的组件实例将被重复使用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会被调用。因此当我们在不同分类间切换时会发现，路径确实发生了变化，但对应的页面并没有任何变化 解决方案：使用 onBeforeRouteUpdate 钩子函数，做精确更新 详情参考https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96 六、二级分类页1、整体架构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;script setup&gt;import &#123; getCategoryFilterAPI, getSubCategoryAPI &#125; from &quot;@/apis/sub-category&quot;;import &#123; useRoute &#125; from &quot;vue-router&quot;;import &#123; ref &#125; from &quot;vue&quot;;import GoodsItem from &quot;@/components/GoodsItem.vue&quot;;const route = useRoute();const subCategoryData = ref(&#123;&#125;);const activeName = ref(&quot;publishTime&quot;);getCategoryFilterAPI(route.params.id).then((res) =&gt; &#123; subCategoryData.value = res.data.result;&#125;);// 选项卡改变时const queryData = ref(&#123; categoryId: subCategoryData.value.parentId, page: 1, pageSize: 20, sortField: &quot;publishTime&quot;,&#125;);const goodsList = ref([]);const getSubCategory = () =&gt; &#123; getSubCategoryAPI(queryData.value).then((res) =&gt; &#123; goodsList.value = [...goodsList.value, ...res.data.result.items]; &#125;);&#125;;getSubCategory();const changeSelected = (val) =&gt; &#123; queryData.value.sortField = val; getSubCategory();&#125;;// 无限滚动加载const disabled = ref(false);const load = () =&gt; &#123; queryData.value.page++; getSubCategoryAPI(queryData.value).then((res) =&gt; &#123; goodsList.value = [...goodsList.value, ...res.data.result.items]; if (!res.data.result.items.length) disabled.value = true; &#125;);&#125;;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 面包屑 --&gt; &lt;div class=&quot;bread-container&quot;&gt; &lt;el-breadcrumb separator=&quot;&gt;&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/&#x27; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item :to=&quot;`/category/$&#123;subCategoryData.parentId&#125;`&quot;&gt;&#123;&#123; subCategoryData.parentName &#125;&#125;&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;&#123;&#123; subCategoryData.name &#125;&#125;&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;/div&gt; &lt;div class=&quot;sub-container&quot;&gt; &lt;el-tabs @tab-change=&quot;changeSelected&quot; v-model=&quot;activeName&quot;&gt; &lt;el-tab-pane label=&quot;最新商品&quot; name=&quot;publishTime&quot;&gt;&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;最高人气&quot; name=&quot;orderNum&quot;&gt;&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;评论最多&quot; name=&quot;evaluateNum&quot;&gt;&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;div class=&quot;body&quot; v-infinite-scroll=&quot;load&quot; :infinite-scroll-disabled=&quot;disabled&quot; &gt; &lt;!-- 商品列表--&gt; &lt;GoodsItem v-for=&quot;item in goodsList&quot; :key=&quot;item.id&quot; :goods=&quot;item&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.bread-container &#123; padding: 25px 0; color: #666;&#125;.sub-container &#123; padding: 20px 10px; background-color: #fff; .body &#123; display: flex; flex-wrap: wrap; padding: 0 10px; &#125; .goods-item &#123; display: block; width: 220px; margin-right: 20px; padding: 20px 30px; text-align: center; img &#123; width: 160px; height: 160px; &#125; p &#123; padding-top: 10px; &#125; .name &#123; font-size: 16px; &#125; .desc &#123; color: #999; height: 29px; &#125; .price &#123; color: $priceColor; font-size: 20px; &#125; &#125; .pagination-container &#123; margin-top: 20px; display: flex; justify-content: center; &#125;&#125;&lt;/style&gt; 七、商品详情1、整体架构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405&lt;script setup&gt;import &#123; getDetail &#125; from &quot;@/apis/goodsInfo&quot;;import &#123; ref, onMounted &#125; from &quot;vue&quot;;import &#123; useRoute &#125; from &quot;vue-router&quot;;import GoodsHot from &quot;./goodsHot.vue&quot;;import GoodsPreview from &quot;@/components/goodsPreview.vue&quot;;import GoodsSKU from &quot;@/XtxSku/index.vue&quot;;import &#123; useCartStore &#125; from &quot;@/stores/cart&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;const route = useRoute();const goodsInfo = ref(&#123;&#125;);const getGoodsInfo = async () =&gt; &#123; const &#123; data &#125; = await getDetail(route.params.id); goodsInfo.value = data.result;&#125;;onMounted(() =&gt; &#123; getGoodsInfo();&#125;);// 数量数据const count = ref(1);const countChange = (val) =&gt; &#123; count.value = val;&#125;;// SKU组件得到的数据const SKUData = ref(&#123;&#125;);const change = (data) =&gt; &#123; SKUData.value = data;&#125;;// 加入购物车const &#123; addCart &#125; = useCartStore();const addtocart = () =&gt; &#123; if (!SKUData.value.skuId) return ElMessage.warning(&quot;请选择规格&quot;); addCart(&#123; id: goodsInfo.value.id, name: goodsInfo.value.name, picture: goodsInfo.value.mainPictures[0], price: goodsInfo.value.price, count: count.value, skuId: SKUData.value.skuId, attrsText: SKUData.value.specsText, selected: true, &#125;); ElMessage.success(&quot;加入购物车成功&quot;);&#125;;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;xtx-goods-page&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;bread-container&quot;&gt; &lt;el-breadcrumb separator=&quot;&gt;&quot; v-if=&quot;goodsInfo.categories&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/&#x27; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item :to=&quot;`category/$&#123;goodsInfo.categories[1].id&#125;`&quot; &gt;&#123;&#123; goodsInfo.categories[1].name &#125;&#125; &lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item :to=&quot;`category/sub/$&#123;goodsInfo.categories[0].id&#125;`&quot; &gt;&#123;&#123; goodsInfo.categories[0].name &#125;&#125; &lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;&#123;&#123; goodsInfo.name &#125;&#125;&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;/div&gt; &lt;!-- 商品信息 --&gt; &lt;div class=&quot;info-container&quot;&gt; &lt;div&gt; &lt;div class=&quot;goods-info&quot;&gt; &lt;div class=&quot;media&quot;&gt; &lt;!-- 图片预览区 --&gt; &lt;GoodsPreview :mainPictures=&quot;goodsInfo.mainPictures&quot; /&gt; &lt;!-- 统计数量 --&gt; &lt;ul class=&quot;goods-sales&quot;&gt; &lt;li&gt; &lt;p&gt;销量人气&lt;/p&gt; &lt;p&gt;&#123;&#123; goodsInfo.salesCount &#125;&#125;+&lt;/p&gt; &lt;p&gt;&lt;i class=&quot;iconfont icon-task-filling&quot;&gt;&lt;/i&gt;销量人气&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;商品评价&lt;/p&gt; &lt;p&gt;&#123;&#123; goodsInfo.commentCount &#125;&#125;+&lt;/p&gt; &lt;p&gt;&lt;i class=&quot;iconfont icon-comment-filling&quot;&gt;&lt;/i&gt;查看评价&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;收藏人气&lt;/p&gt; &lt;p&gt;&#123;&#123; goodsInfo.collectCount &#125;&#125;+&lt;/p&gt; &lt;p&gt;&lt;i class=&quot;iconfont icon-favorite-filling&quot;&gt;&lt;/i&gt;收藏商品&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;品牌信息&lt;/p&gt; &lt;p v-if=&quot;goodsInfo.brand&quot;&gt;&#123;&#123; goodsInfo.brand.name &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;i class=&quot;iconfont icon-dynamic-filling&quot;&gt;&lt;/i&gt;品牌主页&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;spec&quot;&gt; &lt;!-- 商品信息区 --&gt; &lt;p class=&quot;g-name&quot;&gt;&#123;&#123; goodsInfo.name &#125;&#125;&lt;/p&gt; &lt;p class=&quot;g-desc&quot;&gt;&#123;&#123; goodsInfo.desc &#125;&#125;&lt;/p&gt; &lt;p class=&quot;g-price&quot;&gt; &lt;span&gt;&#123;&#123; goodsInfo.oldPrice &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; goodsInfo.price &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;div class=&quot;g-service&quot;&gt; &lt;dl&gt; &lt;dt&gt;促销&lt;/dt&gt; &lt;dd&gt;12月好物放送，App领券购买直降120元&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;服务&lt;/dt&gt; &lt;dd&gt; &lt;span&gt;无忧退货&lt;/span&gt; &lt;span&gt;快速退款&lt;/span&gt; &lt;span&gt;免费包邮&lt;/span&gt; &lt;a href=&quot;javascript:;&quot;&gt;了解详情&lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;!-- sku组件 --&gt; &lt;GoodsSKU :goods=&quot;goodsInfo&quot; @change=&quot;change&quot; /&gt; &lt;!-- 数据组件 --&gt; &lt;el-input-number v-model=&quot;count&quot; @change=&quot;countChange&quot; /&gt; &lt;!-- 按钮组件 --&gt; &lt;div&gt; &lt;el-button size=&quot;large&quot; class=&quot;btn&quot; @click=&quot;addtocart&quot;&gt; 加入购物车 &lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;goods-footer&quot;&gt; &lt;div class=&quot;goods-article&quot;&gt; &lt;!-- 商品详情 --&gt; &lt;div class=&quot;goods-tabs&quot;&gt; &lt;nav&gt; &lt;a&gt;商品详情&lt;/a&gt; &lt;/nav&gt; &lt;div class=&quot;goods-detail&quot; v-if=&quot;goodsInfo.details&quot;&gt; &lt;!-- 属性 --&gt; &lt;ul class=&quot;attrs&quot;&gt; &lt;li v-for=&quot;item in goodsInfo.details.properties&quot; :key=&quot;item.value&quot; &gt; &lt;span class=&quot;dt&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;span class=&quot;dd&quot;&gt;&#123;&#123; item.value &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 图片 --&gt; &lt;img v-for=&quot;img in goodsInfo.details.pictures&quot; :src=&quot;img&quot; :key=&quot;img&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 24热榜+专题推荐 --&gt; &lt;div class=&quot;goods-aside&quot;&gt; &lt;GoodsHot :type=&quot;1&quot; /&gt; &lt;GoodsHot :type=&quot;2&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.xtx-goods-page &#123; .goods-info &#123; min-height: 600px; background: #fff; display: flex; .media &#123; width: 580px; height: 600px; padding: 30px 50px; &#125; .spec &#123; flex: 1; padding: 30px 30px 30px 0; &#125; &#125; .goods-footer &#123; display: flex; margin-top: 20px; .goods-article &#123; width: 940px; margin-right: 20px; &#125; .goods-aside &#123; width: 280px; min-height: 1000px; &#125; &#125; .goods-tabs &#123; min-height: 600px; background: #fff; &#125; .goods-warn &#123; min-height: 600px; background: #fff; margin-top: 20px; &#125; .number-box &#123; display: flex; align-items: center; .label &#123; width: 60px; color: #999; padding-left: 10px; &#125; &#125; .g-name &#123; font-size: 22px; &#125; .g-desc &#123; color: #999; margin-top: 10px; &#125; .g-price &#123; margin-top: 10px; span &#123; &amp;::before &#123; content: &quot;¥&quot;; font-size: 14px; &#125; &amp;:first-child &#123; color: $priceColor; margin-right: 10px; font-size: 22px; &#125; &amp;:last-child &#123; color: #999; text-decoration: line-through; font-size: 16px; &#125; &#125; &#125; .g-service &#123; background: #f5f5f5; width: 500px; padding: 20px 10px 0 10px; margin-top: 10px; dl &#123; padding-bottom: 20px; display: flex; align-items: center; dt &#123; width: 50px; color: #999; &#125; dd &#123; color: #666; &amp;:last-child &#123; span &#123; margin-right: 10px; &amp;::before &#123; content: &quot;•&quot;; color: $xtxColor; margin-right: 2px; &#125; &#125; a &#123; color: $xtxColor; &#125; &#125; &#125; &#125; &#125; .goods-sales &#123; display: flex; width: 400px; align-items: center; text-align: center; height: 140px; li &#123; flex: 1; position: relative; ~ li::after &#123; position: absolute; top: 10px; left: 0; height: 60px; border-left: 1px solid #e4e4e4; content: &quot;&quot;; &#125; p &#123; &amp;:first-child &#123; color: #999; &#125; &amp;:nth-child(2) &#123; color: $priceColor; margin-top: 10px; &#125; &amp;:last-child &#123; color: #666; margin-top: 10px; i &#123; color: $xtxColor; font-size: 14px; margin-right: 2px; &#125; &amp;:hover &#123; color: $xtxColor; cursor: pointer; &#125; &#125; &#125; &#125; &#125;&#125;.goods-tabs &#123; min-height: 600px; background: #fff; nav &#123; height: 70px; line-height: 70px; display: flex; border-bottom: 1px solid #f5f5f5; a &#123; padding: 0 40px; font-size: 18px; position: relative; &gt; span &#123; color: $priceColor; font-size: 16px; margin-left: 10px; &#125; &#125; &#125;&#125;.goods-detail &#123; padding: 40px; .attrs &#123; display: flex; flex-wrap: wrap; margin-bottom: 30px; li &#123; display: flex; margin-bottom: 10px; width: 50%; .dt &#123; width: 100px; color: #999; &#125; .dd &#123; flex: 1; color: #666; &#125; &#125; &#125; &gt; img &#123; width: 100%; &#125;&#125;.btn &#123; margin-top: 20px;&#125;.bread-container &#123; padding: 25px 0;&#125;&lt;/style&gt; 其中热榜组件 goodsHot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;script setup&gt;import &#123; fetchHotGoodsAPI &#125; from &quot;@/apis/goodsInfo&quot;;import &#123; ref, onMounted &#125; from &quot;vue&quot;;import &#123; useRoute &#125; from &quot;vue-router&quot;;const route = useRoute();const queryData = defineProps([&quot;type&quot;]);const hotGoods = ref([]);const getHotGoods = async () =&gt; &#123; const &#123; data &#125; = await fetchHotGoodsAPI(&#123; id: route.params.id, type: queryData.type, &#125;); hotGoods.value = data.result;&#125;;onMounted(() =&gt; &#123; getHotGoods();&#125;);&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;goods-hot&quot;&gt; &lt;h3&gt;&#123;&#123; queryData.type === 1 ? &quot;24小时热销榜&quot; : &quot;周热销榜&quot; &#125;&#125;&lt;/h3&gt; &lt;!-- 商品区块 --&gt; &lt;RouterLink :to=&quot;`/goodsInfo/$&#123;item.id&#125;`&quot; class=&quot;goods-item&quot; v-for=&quot;item in hotGoods&quot; :key=&quot;item.id&quot; &gt; &lt;img :src=&quot;item.picture&quot; alt=&quot;&quot; /&gt; &lt;p class=&quot;name ellipsis&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/p&gt; &lt;p class=&quot;desc ellipsis&quot;&gt;&#123;&#123; item.desc &#125;&#125;&lt;/p&gt; &lt;p class=&quot;price&quot;&gt;&amp;yen;&#123;&#123; item.price &#125;&#125;&lt;/p&gt; &lt;/RouterLink&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.goods-hot &#123; h3 &#123; height: 70px; background: $helpColor; color: #fff; font-size: 18px; line-height: 70px; padding-left: 25px; margin-bottom: 10px; font-weight: normal; &#125; .goods-item &#123; display: block; padding: 20px 30px; text-align: center; background: #fff; img &#123; width: 160px; height: 160px; &#125; p &#123; padding-top: 10px; &#125; .name &#123; font-size: 16px; &#125; .desc &#123; color: #999; height: 29px; &#125; .price &#123; color: $priceColor; font-size: 20px; &#125; &#125;&#125;&lt;/style&gt; 图片预览组件 goodsPreview 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;script setup&gt;import &#123; ref, onMounted, watch, computed &#125; from &quot;vue&quot;;import &#123; useMouseInElement &#125; from &quot;@vueuse/core&quot;;// 图片列表defineProps(&#123; mainPictures: &#123; type: Array, default: () =&gt; [], &#125;,&#125;);// 当前选中的图片索引const currentIndex = ref(0);// 获取鼠标相对位置const target = ref(null);const &#123; elementX, elementY, isOutside &#125; = useMouseInElement(target);const X = ref(0);const Y = ref(0);// 监听鼠标相对位置的变化watch([elementX, elementY, isOutside], () =&gt; &#123; if (isOutside.value) &#123; return; &#125; if (elementX.value &gt; 100 &amp;&amp; elementX.value &lt; 300) &#123; X.value = elementX.value - 100; &#125; else if (elementX.value &lt;= 100) &#123; X.value = 0; &#125; else &#123; X.value = 200; &#125; if (elementY.value &gt; 100 &amp;&amp; elementY.value &lt; 300) &#123; Y.value = elementY.value - 100; &#125; else if (elementY.value &lt;= 100) &#123; Y.value = 0; &#125; else &#123; Y.value = 200; &#125;&#125;);const positionX = computed(() =&gt; -X.value * 2);const positionY = computed(() =&gt; -Y.value * 2);&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;goods-image&quot;&gt; &lt;!-- 左侧大图--&gt; &lt;div class=&quot;middle&quot; ref=&quot;target&quot;&gt; &lt;img :src=&quot;mainPictures[currentIndex]&quot; alt=&quot;&quot; /&gt; &lt;!-- 蒙层小滑块 --&gt; &lt;div class=&quot;layer&quot; v-show=&quot;!isOutside&quot; :style=&quot;&#123; left: `$&#123;X&#125;px`, top: `$&#123;Y&#125;px` &#125;&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 小图列表 --&gt; &lt;ul class=&quot;small&quot;&gt; &lt;li v-for=&quot;(img, i) in mainPictures&quot; :key=&quot;i&quot; @mouseenter=&quot;currentIndex = i&quot; :class=&quot;&#123; active: currentIndex === i &#125;&quot; &gt; &lt;img :src=&quot;img&quot; alt=&quot;&quot; /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 放大镜大图 --&gt; &lt;div class=&quot;large&quot; :style=&quot;[ &#123; backgroundImage: `url($&#123;mainPictures[currentIndex]&#125;)`, backgroundPositionX: `$&#123;positionX&#125;px`, backgroundPositionY: `$&#123;positionY&#125;px`, &#125;, ]&quot; v-show=&quot;!isOutside&quot; &gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.goods-image &#123; width: 480px; height: 400px; position: relative; display: flex; .middle &#123; width: 400px; height: 400px; background: #f5f5f5; &#125; .large &#123; position: absolute; top: 0; left: 412px; width: 400px; height: 400px; z-index: 500; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); background-repeat: no-repeat; // 背景图:盒子的大小 = 2:1 将来控制背景图的移动来实现放大的效果查看 background-position background-size: 800px 800px; background-color: #f8f8f8; &#125; .layer &#123; width: 200px; height: 200px; background: rgba(0, 0, 0, 0.2); // 绝对定位 然后跟随咱们鼠标控制left和top属性就可以让滑块移动起来 left: 0; top: 0; position: absolute; &#125; .small &#123; width: 80px; li &#123; width: 68px; height: 68px; margin-left: 12px; margin-bottom: 15px; cursor: pointer; &amp;:hover, &amp;.active &#123; border: 2px solid $xtxColor; &#125; &#125; &#125;&#125;&lt;/style&gt; 2、图片预览组件功能拆解： 通过小图切换大图显示 放大镜效果 小图切换大图实现起来比较简单，主要是放大镜效果有点复杂，我们再对其进行进一步分解： 左侧滑块跟随鼠标移动 右侧大图放大效果实现 鼠标移入控制滑块和大图显示隐藏 3、规格组件 SKU&amp;SPU SPU（Standard Product Unit）：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个 SPU。 SKU（Stock Keeping Unit）库存量单位，即库存进出计量的单位， 可以是以件、盒、托盘等为单位。SKU 是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理 即，spu 代表一个商品，拥有很多相同的属性。sku 代表该商品可选规格的任意组合，他是库存单位的唯一标识。 八、登录页1、整体架构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337&lt;script setup&gt;import &#123; ElMessage &#125; from &quot;element-plus&quot;;import &#123; ref, toRefs &#125; from &quot;vue&quot;;import &#123; useUserInfoStore &#125; from &quot;@/stores/userInfo&quot;;const ruleFormRef = ref(null);const ruleForm = ref(&#123; account: &quot;&quot;, password: &quot;&quot;, agreement: false,&#125;);// 单独校验是否同意条款const validateAgree = (rule, value, callback) =&gt; &#123; if (value) &#123; callback(); &#125; else &#123; callback(new Error(&quot;请同意条款&quot;)); &#125;&#125;;const rules = ref(&#123; account: [&#123; required: true, message: &quot;请输入账户&quot;, trigger: &quot;blur&quot; &#125;], password: [ &#123; required: true, message: &quot;请输入密码&quot;, trigger: &quot;blur&quot; &#125;, &#123; min: 6, max: 16, message: &quot;长度在 6 到 16 个字符&quot;, trigger: &quot;blur&quot; &#125;, ], agreement: [&#123; validator: validateAgree, trigger: &quot;change&quot; &#125;],&#125;);// 登录按钮const loginBtn = () =&gt; &#123; ruleFormRef.value.validate((valid) =&gt; &#123; if (valid) &#123; const &#123; getUserInfo &#125; = toRefs(useUserInfoStore()); getUserInfo.value(ruleForm.value); &#125; else &#123; ElMessage.error(&quot;验证失败&quot;); &#125; &#125;);&#125;;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;header class=&quot;login-header&quot;&gt; &lt;div class=&quot;container m-top-20&quot;&gt; &lt;h1 class=&quot;logo&quot;&gt; &lt;RouterLink to=&quot;/&quot;&gt;小兔鲜&lt;/RouterLink&gt; &lt;/h1&gt; &lt;RouterLink class=&quot;entry&quot; to=&quot;/&quot;&gt; 进入网站首页 &lt;i class=&quot;iconfont icon-angle-right&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-angle-right&quot;&gt;&lt;/i&gt; &lt;/RouterLink&gt; &lt;/div&gt; &lt;/header&gt; &lt;section class=&quot;login-section&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;nav&gt; &lt;a href=&quot;javascript:;&quot;&gt;账户登录&lt;/a&gt; &lt;/nav&gt; &lt;div class=&quot;account-box&quot;&gt; &lt;div class=&quot;form&quot;&gt; &lt;el-form label-position=&quot;right&quot; label-width=&quot;60px&quot; status-icon ref=&quot;ruleFormRef&quot; :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; &gt; &lt;el-form-item prop=&quot;account&quot; label=&quot;账户&quot;&gt; &lt;el-input v-model=&quot;ruleForm.account&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=&quot;password&quot; label=&quot;密码&quot;&gt; &lt;el-input type=&quot;password&quot; show-password v-model=&quot;ruleForm.password&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label-width=&quot;22px&quot; prop=&quot;agreement&quot;&gt; &lt;el-checkbox size=&quot;large&quot; v-model=&quot;ruleForm.agreement&quot;&gt; 我已同意隐私条款和服务条款 &lt;/el-checkbox&gt; &lt;/el-form-item&gt; &lt;el-button size=&quot;large&quot; class=&quot;subBtn&quot; @click=&quot;loginBtn&quot; &gt;点击登录&lt;/el-button &gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;footer class=&quot;login-footer&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt; &lt;a href=&quot;javascript:;&quot;&gt;关于我们&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;帮助中心&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;售后服务&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;配送与验收&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;商务合作&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;搜索推荐&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;友情链接&lt;/a&gt; &lt;/p&gt; &lt;p&gt;CopyRight &amp;copy; 小兔鲜儿&lt;/p&gt; &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.login-header &#123; background: #fff; border-bottom: 1px solid #e4e4e4; .container &#123; display: flex; align-items: flex-end; justify-content: space-between; &#125; .logo &#123; width: 200px; a &#123; display: block; height: 132px; width: 100%; text-indent: -9999px; background: url(&quot;@/assets/images/logo.png&quot;) no-repeat center 18px / contain; &#125; &#125; .sub &#123; flex: 1; font-size: 24px; font-weight: normal; margin-bottom: 38px; margin-left: 20px; color: #666; &#125; .entry &#123; width: 120px; margin-bottom: 38px; font-size: 16px; i &#123; font-size: 14px; color: $xtxColor; letter-spacing: -5px; &#125; &#125;&#125;.login-section &#123; background: url(&quot;@/assets/images/login-bg.png&quot;) no-repeat center / cover; height: 488px; position: relative; .wrapper &#123; width: 380px; background: #fff; position: absolute; left: 50%; top: 54px; transform: translate3d(100px, 0, 0); box-shadow: 0 0 10px rgba(0, 0, 0, 0.15); nav &#123; font-size: 14px; height: 55px; margin-bottom: 20px; border-bottom: 1px solid #f5f5f5; display: flex; padding: 0 40px; text-align: right; align-items: center; a &#123; flex: 1; line-height: 1; display: inline-block; font-size: 18px; position: relative; text-align: center; &#125; &#125; &#125;&#125;.login-footer &#123; padding: 30px 0 50px; background: #fff; p &#123; text-align: center; color: #999; padding-top: 20px; a &#123; line-height: 1; padding: 0 10px; color: #999; display: inline-block; ~ a &#123; border-left: 1px solid #ccc; &#125; &#125; &#125;&#125;.account-box &#123; .toggle &#123; padding: 15px 40px; text-align: right; a &#123; color: $xtxColor; i &#123; font-size: 14px; &#125; &#125; &#125; .form &#123; padding: 0 20px 20px 20px; &amp;-item &#123; margin-bottom: 28px; .input &#123; position: relative; height: 36px; &gt; i &#123; width: 34px; height: 34px; background: #cfcdcd; color: #fff; position: absolute; left: 1px; top: 1px; text-align: center; line-height: 34px; font-size: 18px; &#125; input &#123; padding-left: 44px; border: 1px solid #cfcdcd; height: 36px; line-height: 36px; width: 100%; &amp;.error &#123; border-color: $priceColor; &#125; &amp;.active, &amp;:focus &#123; border-color: $xtxColor; &#125; &#125; .code &#123; position: absolute; right: 1px; top: 1px; text-align: center; line-height: 34px; font-size: 14px; background: #f5f5f5; color: #666; width: 90px; height: 34px; cursor: pointer; &#125; &#125; &gt; .error &#123; position: absolute; font-size: 12px; line-height: 28px; color: $priceColor; i &#123; font-size: 14px; margin-right: 2px; &#125; &#125; &#125; .agree &#123; a &#123; color: #069; &#125; &#125; .btn &#123; display: block; width: 100%; height: 40px; color: #fff; text-align: center; line-height: 40px; background: $xtxColor; &amp;.disabled &#123; background: #cfcdcd; &#125; &#125; &#125; .action &#123; padding: 20px 40px; display: flex; justify-content: space-between; align-items: center; .url &#123; a &#123; color: #999; margin-left: 10px; &#125; &#125; &#125;&#125;.subBtn &#123; background: $xtxColor; width: 100%; color: #fff;&#125;&lt;/style&gt; 2、pinia 管理用户数据stores 下新建 userInfo.js 12345678910111213141516171819202122232425262728293031323334import &#123; ref &#125; from &quot;vue&quot;;import &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; loginAPI &#125; from &quot;@/apis/login&quot;;import router from &quot;@/router/index.js&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;import &#123; useCartStore &#125; from &quot;@/stores/cart&quot;;const &#123; mergeCart &#125; = useCartStore();export const useUserInfoStore = defineStore( &quot;userInfo&quot;, () =&gt; &#123; //用户数据 const userInfo = ref(&#123;&#125;); // 获取用户数据 async function getUserInfo(Data) &#123; try &#123; const &#123; data &#125; = await loginAPI(Data); userInfo.value = data.result; mergeCart(); ElMessage.success(&quot;登录成功&quot;); router.replace(&quot;/&quot;); &#125; catch &#123; ElMessage.error(&quot;登录失败&quot;); &#125; &#125; // 清除用户数据 function clearUserInfo() &#123; userInfo.value = &#123;&#125;; &#125; return &#123; userInfo, getUserInfo, clearUserInfo &#125;; &#125;, &#123; persist: true, &#125;); 3、请求拦截器统一注入 tokenutils&#x2F;request.js 1234567891011121314151617181920212223242526import axios from &quot;axios&quot;;import &#123; useUserInfoStore &#125; from &quot;@/stores/userInfo&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;const request = axios.create(&#123; baseURL: &quot;http://pcapi-xiaotuxian-front-devtest.itheima.net/&quot;, timeout: 5000, // 单位是毫秒&#125;);// 请求拦截器，统一注入tokenrequest.interceptors.request.use((config) =&gt; &#123; const &#123; userInfo &#125; = useUserInfoStore(); if (userInfo.token) &#123; config.headers.Authorization = `Bearer $&#123;userInfo.token&#125;`; &#125; return config;&#125;);// 响应拦截器,这里可以将axios默认添加的一层data剥离出来request.interceptors.response.use( (response) =&gt; response, (error) =&gt; &#123; if (error.response.status === 401) &#123; ElMessage.error(&quot;请先登录&quot;); &#125; return Promise.reject(error); &#125;);export default request; 九、购物车1、整体架构头部购物车 HeadCart 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226&lt;script setup&gt;import &#123; useCartStore &#125; from &quot;@/stores/cart&quot;;import &#123; toRefs &#125; from &quot;vue&quot;;const &#123; cartList, total, totalPrice, removeCart &#125; = toRefs(useCartStore());&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;cart&quot;&gt; &lt;a class=&quot;curr&quot; href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;iconfont icon-cart&quot;&gt;&lt;/i&gt;&lt;em&gt;&#123;&#123; cartList.length &#125;&#125;&lt;/em&gt; &lt;/a&gt; &lt;div class=&quot;layer&quot;&gt; &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;item&quot; v-for=&quot;i in cartList&quot; :key=&quot;i.id&quot;&gt; &lt;RouterLink to=&quot;&quot;&gt; &lt;img :src=&quot;i.picture&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;center&quot;&gt; &lt;p class=&quot;name ellipsis-2&quot;&gt; &#123;&#123; i.name &#125;&#125; &lt;/p&gt; &lt;p class=&quot;attr ellipsis&quot;&gt;&#123;&#123; i.attrsText &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p class=&quot;price&quot;&gt;&amp;yen;&#123;&#123; i.price &#125;&#125;&lt;/p&gt; &lt;p class=&quot;count&quot;&gt;x&#123;&#123; i.count &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/RouterLink&gt; &lt;i class=&quot;iconfont icon-close-new&quot; @click=&quot;removeCart(i)&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;foot&quot;&gt; &lt;div class=&quot;total&quot;&gt; &lt;p&gt;共 &#123;&#123; total &#125;&#125; 件商品&lt;/p&gt; &lt;p&gt;&amp;yen; &#123;&#123; totalPrice.toFixed(2) &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;el-button size=&quot;large&quot; type=&quot;primary&quot; @click=&quot;$router.push(&#x27;/cartList&#x27;)&quot; &gt;去购物车结算&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.cart &#123; width: 50px; position: relative; z-index: 600; .curr &#123; height: 32px; line-height: 32px; text-align: center; position: relative; display: block; .icon-cart &#123; font-size: 22px; &#125; em &#123; font-style: normal; position: absolute; right: 0; top: 0; padding: 1px 6px; line-height: 1; background: $helpColor; color: #fff; font-size: 12px; border-radius: 10px; font-family: Arial; &#125; &#125; &amp;:hover &#123; .layer &#123; opacity: 1; transform: none; &#125; &#125; .layer &#123; opacity: 0; transition: all 0.4s 0.2s; transform: translateY(-200px) scale(1, 0); width: 400px; height: 400px; position: absolute; top: 50px; right: 0; box-shadow: 0 0 10px rgba(0, 0, 0, 0.2); background: #fff; border-radius: 4px; padding-top: 10px; &amp;::before &#123; content: &quot;&quot;; position: absolute; right: 14px; top: -10px; width: 20px; height: 20px; background: #fff; transform: scale(0.6, 1) rotate(45deg); box-shadow: -3px -3px 5px rgba(0, 0, 0, 0.1); &#125; .foot &#123; position: absolute; left: 0; bottom: 0; height: 70px; width: 100%; padding: 10px; display: flex; justify-content: space-between; background: #f8f8f8; align-items: center; .total &#123; padding-left: 10px; color: #999; p &#123; &amp;:last-child &#123; font-size: 18px; color: $priceColor; &#125; &#125; &#125; &#125; &#125; .list &#123; height: 310px; overflow: auto; padding: 0 10px; &amp;::-webkit-scrollbar &#123; width: 10px; height: 10px; &#125; &amp;::-webkit-scrollbar-track &#123; background: #f8f8f8; border-radius: 2px; &#125; &amp;::-webkit-scrollbar-thumb &#123; background: #eee; border-radius: 10px; &#125; &amp;::-webkit-scrollbar-thumb:hover &#123; background: #ccc; &#125; .item &#123; border-bottom: 1px solid #f5f5f5; padding: 10px 0; position: relative; i &#123; position: absolute; bottom: 38px; right: 0; opacity: 0; color: #666; transition: all 0.5s; &#125; &amp;:hover &#123; i &#123; opacity: 1; cursor: pointer; &#125; &#125; a &#123; display: flex; align-items: center; img &#123; height: 80px; width: 80px; &#125; .center &#123; padding: 0 10px; width: 200px; .name &#123; font-size: 16px; &#125; .attr &#123; color: #999; padding-top: 5px; &#125; &#125; .right &#123; width: 100px; padding-right: 20px; text-align: center; .price &#123; font-size: 16px; color: $priceColor; &#125; .count &#123; color: #999; margin-top: 5px; font-size: 16px; &#125; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; 列表购物车 cartList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229&lt;script setup&gt;import &#123; useCartStore &#125; from &quot;@/stores/cart&quot;;import &#123; toRefs &#125; from &quot;vue&quot;;// 注意这里因为有点击选择框导致选择框状态的改变，选择框状态的改变需要同步到pinia中，解构会使响应式数据丢失响应性，所以这里使用toRefs解构const &#123; cartList, total, removeCart, isCheckAll, selectedCount, selectedTotalPrice,&#125; = toRefs(useCartStore());&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;xtx-cart-page&quot;&gt; &lt;div class=&quot;container m-top-20&quot;&gt; &lt;div class=&quot;cart&quot;&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th width=&quot;120&quot;&gt; &lt;el-checkbox v-model=&quot;isCheckAll&quot; /&gt; &lt;/th&gt; &lt;th width=&quot;400&quot;&gt;商品信息&lt;/th&gt; &lt;th width=&quot;220&quot;&gt;单价&lt;/th&gt; &lt;th width=&quot;180&quot;&gt;数量&lt;/th&gt; &lt;th width=&quot;180&quot;&gt;小计&lt;/th&gt; &lt;th width=&quot;140&quot;&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!-- 商品列表 --&gt; &lt;tbody&gt; &lt;tr v-for=&quot;i in cartList&quot; :key=&quot;i.id&quot;&gt; &lt;td&gt; &lt;el-checkbox v-model=&quot;i.selected&quot; /&gt; &lt;/td&gt; &lt;td&gt; &lt;div class=&quot;goods&quot;&gt; &lt;RouterLink to=&quot;/&quot; &gt;&lt;img :src=&quot;i.picture&quot; alt=&quot;&quot; /&gt;&lt;/RouterLink&gt; &lt;div&gt; &lt;p class=&quot;name ellipsis&quot;&gt; &#123;&#123; i.name &#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;td class=&quot;tc&quot;&gt; &lt;p&gt;&amp;yen;&#123;&#123; i.price &#125;&#125;&lt;/p&gt; &lt;/td&gt; &lt;td class=&quot;tc&quot;&gt; &lt;el-input-number v-model=&quot;i.count&quot; /&gt; &lt;/td&gt; &lt;td class=&quot;tc&quot;&gt; &lt;p class=&quot;f16 red&quot;&gt;&amp;yen;&#123;&#123; (i.price * i.count).toFixed(2) &#125;&#125;&lt;/p&gt; &lt;/td&gt; &lt;td class=&quot;tc&quot;&gt; &lt;p&gt; &lt;el-popconfirm title=&quot;确认删除吗?&quot; confirm-button-text=&quot;确认&quot; cancel-button-text=&quot;取消&quot; @confirm=&quot;removeCart(i)&quot; &gt; &lt;template #reference&gt; &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt; &lt;/template&gt; &lt;/el-popconfirm&gt; &lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr v-if=&quot;cartList.length === 0&quot;&gt; &lt;td colspan=&quot;6&quot;&gt; &lt;div class=&quot;cart-none&quot;&gt; &lt;el-empty description=&quot;购物车列表为空&quot;&gt; &lt;el-button type=&quot;primary&quot;&gt;随便逛逛&lt;/el-button&gt; &lt;/el-empty&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;!-- 操作栏 --&gt; &lt;div class=&quot;action&quot;&gt; &lt;div class=&quot;batch&quot;&gt; 共 &#123;&#123; total &#125;&#125; 件商品，已选择 &#123;&#123; selectedCount &#125;&#125; 件，商品合计： &lt;span class=&quot;red&quot;&gt;¥ &#123;&#123; selectedTotalPrice.toFixed(2) &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;total&quot;&gt; &lt;el-button size=&quot;large&quot; type=&quot;primary&quot; @click=&quot;$router.push(&#x27;/orders&#x27;)&quot; &gt;下单结算&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.xtx-cart-page &#123; margin-top: 20px; .cart &#123; background: #fff; color: #666; table &#123; border-spacing: 0; border-collapse: collapse; line-height: 24px; th, td &#123; padding: 10px; border-bottom: 1px solid #f5f5f5; &amp;:first-child &#123; text-align: left; padding-left: 30px; color: #999; &#125; &#125; th &#123; font-size: 16px; font-weight: normal; line-height: 50px; &#125; &#125; &#125; .cart-none &#123; text-align: center; padding: 120px 0; background: #fff; p &#123; color: #999; padding: 20px 0; &#125; &#125; .tc &#123; text-align: center; a &#123; color: $xtxColor; &#125; .xtx-numbox &#123; margin: 0 auto; width: 120px; &#125; &#125; .red &#123; color: $priceColor; &#125; .green &#123; color: $xtxColor; &#125; .f16 &#123; font-size: 16px; &#125; .goods &#123; display: flex; align-items: center; img &#123; width: 100px; height: 100px; &#125; &gt; div &#123; width: 280px; font-size: 16px; padding-left: 10px; .attr &#123; font-size: 14px; color: #999; &#125; &#125; &#125; .action &#123; display: flex; background: #fff; margin-top: 20px; height: 80px; align-items: center; font-size: 16px; justify-content: space-between; padding: 0 30px; .xtx-checkbox &#123; color: #999; &#125; .batch &#123; a &#123; margin-left: 20px; &#125; &#125; .red &#123; font-size: 18px; margin-right: 20px; font-weight: bold; &#125; &#125; .tit &#123; color: #666; font-size: 16px; font-weight: normal; line-height: 50px; &#125;&#125;&lt;/style&gt; 接下来需要分两条路：一是未登录状态下操作购物车存储到本地，二是登录状态下操作购物车存储到数据库（调用接口） 2、pinia 管理购物车数据由于购物车数据多个模块都需要用到，因此在 stores 新建 cart.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; ref, computed &#125; from &quot;vue&quot;;import &#123; insertCartAPI, delCartAPI, getCartListAPI &#125; from &quot;@/apis/cartList.js&quot;;import &#123; mergeCartAPI &#125; from &quot;@/apis/login.js&quot;;import &#123; useUserInfoStore &#125; from &quot;@/stores/userInfo.js&quot;;export const useCartStore = defineStore( &quot;useCartStore&quot;, () =&gt; &#123; //购物车列表 const cartList = ref([]); //商品总数量 const total = computed(() =&gt; cartList.value.reduce((total, item) =&gt; total + item.count, 0) ); //商品总价格 const totalPrice = computed(() =&gt; cartList.value.reduce((total, item) =&gt; total + item.count * item.price, 0) ); //已选件数 const selectedCount = computed(() =&gt; &#123; const selectedGoods = cartList.value.filter((item) =&gt; item.selected); return selectedGoods.reduce((total, item) =&gt; total + item.count, 0); &#125;); // 已选商品总价 const selectedTotalPrice = computed(() =&gt; &#123; const selectedGoods = cartList.value.filter((item) =&gt; item.selected); return selectedGoods.reduce( (total, item) =&gt; total + item.count * item.price, 0 ); &#125;); // 全选状态 const isCheckAll = computed(&#123; get() &#123; return cartList.value.every((item) =&gt; item.selected === true); &#125;, set(val) &#123; cartList.value.forEach((item) =&gt; (item.selected = val)); &#125;, &#125;); // 获取购物车列表 const getCartList = async () =&gt; &#123; const &#123; data &#125; = await getCartListAPI(); cartList.value = data.result; &#125;; // 添加购物车 const addCart = async (goods) =&gt; &#123; //如果用户已登录，则调用接口，否则走本地购物车流程 const &#123; userInfo &#125; = useUserInfoStore(); if (userInfo.token) &#123; await insertCartAPI(&#123; skuId: goods.skuId, count: goods.count, &#125;); // 调用添加接口后，重新获取购物车列表以覆盖本地购物车 getCartList(); &#125; else &#123; //如果购物车中有该商品，数量加1，否则添加该商品 const index = cartList.value.findIndex( (item) =&gt; item.skuId === goods.skuId ); if (index === -1) &#123; cartList.value.push(goods); &#125; else &#123; cartList.value[index].count++; &#125; &#125; &#125;; //删除购物车的数据 const removeCart = (goods) =&gt; &#123; //如果用户已登录，则调用接口，否则走本地购物车流程 const &#123; userInfo &#125; = useUserInfoStore(); if (userInfo.token) &#123; delCartAPI([goods.skuId]); // 调用删除接口后，重新获取购物车列表以覆盖本地购物车 getCartList(); &#125; else &#123; const index = cartList.value.findIndex( (item) =&gt; item.skuId === goods.skuId ); cartList.value.splice(index, 1); &#125; &#125;; // 合并购物车 const mergeCart = async () =&gt; &#123; await mergeCartAPI(cartList.value); &#125;; return &#123; cartList, total, totalPrice, addCart, removeCart, isCheckAll, selectedCount, selectedTotalPrice, getCartList, mergeCart, &#125;; &#125;, &#123; persist: true, &#125;); 注意，这里有一个合并购物车的方法，主要是为了将用户未登录时的购物车操作在登录时合并到服务器 十、订单页1、整体架构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550&lt;script setup&gt;import &#123; useRouter &#125; from &quot;vue-router&quot;;import &#123; ref, onMounted, computed &#125; from &quot;vue&quot;;import &#123; getCheckoutInfoAPI, addAddressAPI, getAddressAPI, deleteAddressAPI, submitOrderAPI,&#125; from &quot;@/apis/orders&quot;;import &#123; regionData, codeToText &#125; from &quot;element-china-area-data&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;import &#123; useCartStore &#125; from &quot;@/stores/cart&quot;;const checkInfo = ref(&#123;&#125;); // 订单对象const curAddress = ref(&#123;&#125;); // 地址对象const newAddressList = ref([]); // 地址列表getCheckoutInfoAPI().then((res) =&gt; &#123; checkInfo.value = res.data.result;&#125;);const getAddress = async () =&gt; &#123; const &#123; data &#125; = await getAddressAPI(); curAddress.value = data.result.find((item) =&gt; item.isDefault === 0); newAddressList.value = data.result.map((ele) =&gt; &#123; ele.isSelected = false; return ele; &#125;);&#125;;onMounted(() =&gt; getAddress());// 控制切换地址弹窗显示隐藏const dialogVisible = ref(false);const toggle = () =&gt; &#123; dialogVisible.value = true; getAddress();&#125;;// 存放临时地址const tempAddress = ref(&#123;&#125;);// 选中地址时高亮效果const confirmAddrsss = (item) =&gt; &#123; newAddressList.value .filter((element) =&gt; element.id != item.id) .forEach((element) =&gt; (element.isSelected = false)); item.isSelected = !item.isSelected; if (item.isSelected) &#123; tempAddress.value = item; &#125;&#125;;// 确定切换地址const toggleAddress = () =&gt; &#123; if (tempAddress.value.id) &#123; curAddress.value = tempAddress.value; tempAddress.value = &#123;&#125;; &#125; dialogVisible.value = false;&#125;;// 删除地址const removeAddress = async (item) =&gt; &#123; try &#123; await deleteAddressAPI(item.id); ElMessage.success(&quot;删除成功&quot;); getAddress(); &#125; catch &#123; ElMessage.error(&quot;删除失败&quot;); &#125;&#125;;// 添加地址// 添加地址显示隐藏const addDialogVisible = ref(false);// 表单数据const formData = ref(&#123; receiver: &quot;&quot;, contact: &quot;&quot;, region: [], address: &quot;&quot;, postalCode: &quot;&quot;, addressTags: &quot;&quot;, isDefault: 1,&#125;);// 取消按钮const cancel = () =&gt; &#123; addDialogVisible.value = false; formData.value = &#123; receiver: &quot;&quot;, contact: &quot;&quot;, region: [], address: &quot;&quot;, postalCode: &quot;&quot;, addressTags: &quot;&quot;, isDefault: 1, &#125;;&#125;;// 确认按钮const confirm = async () =&gt; &#123; try &#123; await addAddressAPI(&#123; ...formData.value, provinceCode: formData.value.region[0], cityCode: formData.value.region[1], countyCode: formData.value.region[2], fullLocation: codeToText[formData.value.region[0]] + codeToText[formData.value.region[1]] + codeToText[formData.value.region[2]] + formData.value.address, &#125;); ElMessage.success(&quot;添加成功&quot;); &#125; catch &#123; ElMessage.error(&quot;添加失败&quot;); &#125; cancel();&#125;;// 提交订单// 订单数据const orderData = ref(&#123; deliveryTimeType: 1, payType: 1, payChannel: 1, buyerMessage: &quot;&quot;, goods: computed(() =&gt; checkInfo.value.goods), addressId: computed(() =&gt; curAddress.value.id),&#125;);const router = useRouter();const submitOrders = async () =&gt; &#123; const &#123; data &#125; = await submitOrderAPI(orderData.value); // 更新购物车数据 const &#123; removeCart &#125; = useCartStore(); removeCart(orderData.value); router.push(`/payPage/$&#123;data.result.id&#125;`);&#125;;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;xtx-pay-checkout-page&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;!-- 收货地址 --&gt; &lt;h3 class=&quot;box-title&quot;&gt;收货地址&lt;/h3&gt; &lt;div class=&quot;box-body&quot;&gt; &lt;div class=&quot;address&quot;&gt; &lt;div class=&quot;text&quot;&gt; &lt;div class=&quot;none&quot; v-if=&quot;!curAddress&quot;&gt; 您需要先添加收货地址才可提交订单。 &lt;/div&gt; &lt;ul v-else&gt; &lt;li&gt; &lt;span&gt;收&lt;i /&gt;货&lt;i /&gt;人：&lt;/span&gt;&#123;&#123; curAddress.receiver &#125;&#125; &lt;/li&gt; &lt;li&gt;&lt;span&gt;联系方式：&lt;/span&gt;&#123;&#123; curAddress.contact &#125;&#125;&lt;/li&gt; &lt;li&gt; &lt;span&gt;收货地址：&lt;/span&gt;&#123;&#123; curAddress.fullLocation &#125;&#125; &#123;&#123; curAddress.address &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;action&quot;&gt; &lt;el-button size=&quot;large&quot; @click=&quot;toggle&quot;&gt;切换地址&lt;/el-button&gt; &lt;el-button size=&quot;large&quot; @click=&quot;addDialogVisible = true&quot; &gt;添加地址&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 商品信息 --&gt; &lt;h3 class=&quot;box-title&quot;&gt;商品信息&lt;/h3&gt; &lt;div class=&quot;box-body&quot;&gt; &lt;table class=&quot;goods&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th width=&quot;520&quot;&gt;商品信息&lt;/th&gt; &lt;th width=&quot;170&quot;&gt;单价&lt;/th&gt; &lt;th width=&quot;170&quot;&gt;数量&lt;/th&gt; &lt;th width=&quot;170&quot;&gt;小计&lt;/th&gt; &lt;th width=&quot;170&quot;&gt;实付&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;i in checkInfo.goods&quot; :key=&quot;i.id&quot;&gt; &lt;td&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;info&quot;&gt; &lt;img :src=&quot;i.picture&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;&#123;&#123; i.name &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; i.attrsText &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;/td&gt; &lt;td&gt;&amp;yen;&#123;&#123; i.price &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; i.count &#125;&#125;&lt;/td&gt; &lt;td&gt;&amp;yen;&#123;&#123; i.totalPrice &#125;&#125;&lt;/td&gt; &lt;td&gt;&amp;yen;&#123;&#123; i.totalPayPrice &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;!-- 配送时间 --&gt; &lt;h3 class=&quot;box-title&quot;&gt;配送时间&lt;/h3&gt; &lt;div class=&quot;box-body&quot;&gt; &lt;a class=&quot;my-btn active&quot; href=&quot;javascript:;&quot; &gt;不限送货时间：周一至周日&lt;/a &gt; &lt;a class=&quot;my-btn&quot; href=&quot;javascript:;&quot;&gt;工作日送货：周一至周五&lt;/a&gt; &lt;a class=&quot;my-btn&quot; href=&quot;javascript:;&quot;&gt;双休日、假日送货：周六至周日&lt;/a&gt; &lt;/div&gt; &lt;!-- 支付方式 --&gt; &lt;h3 class=&quot;box-title&quot;&gt;支付方式&lt;/h3&gt; &lt;div class=&quot;box-body&quot;&gt; &lt;a class=&quot;my-btn active&quot; href=&quot;javascript:;&quot;&gt;在线支付&lt;/a&gt; &lt;a class=&quot;my-btn&quot; href=&quot;javascript:;&quot;&gt;货到付款&lt;/a&gt; &lt;span style=&quot;color: #999&quot;&gt;货到付款需付5元手续费&lt;/span&gt; &lt;/div&gt; &lt;!-- 金额明细 --&gt; &lt;h3 class=&quot;box-title&quot;&gt;金额明细&lt;/h3&gt; &lt;div class=&quot;box-body&quot;&gt; &lt;div class=&quot;total&quot;&gt; &lt;dl&gt; &lt;dt&gt;商品件数：&lt;/dt&gt; &lt;dd&gt;&#123;&#123; checkInfo.summary?.goodsCount &#125;&#125;件&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;商品总价：&lt;/dt&gt; &lt;dd&gt;¥&#123;&#123; checkInfo.summary?.totalPrice.toFixed(2) &#125;&#125;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;运&lt;i&gt;&lt;/i&gt;费：&lt;/dt&gt; &lt;dd&gt;¥&#123;&#123; checkInfo.summary?.postFee.toFixed(2) &#125;&#125;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;应付总额：&lt;/dt&gt; &lt;dd class=&quot;price&quot;&gt; &#123;&#123; checkInfo.summary?.totalPayPrice.toFixed(2) &#125;&#125; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 提交订单 --&gt; &lt;div class=&quot;submit&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;large&quot; @click=&quot;submitOrders&quot; &gt;提交订单&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 切换地址 --&gt; &lt;el-dialog title=&quot;切换收货地址&quot; width=&quot;30%&quot; center v-model=&quot;dialogVisible&quot;&gt; &lt;div class=&quot;addressWrapper&quot;&gt; &lt;div class=&quot;text item&quot; v-for=&quot;item in newAddressList&quot; :key=&quot;item.id&quot; @click=&quot;confirmAddrsss(item)&quot; :class=&quot;&#123; active: item.isSelected &#125;&quot; &gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;收&lt;i /&gt;货&lt;i /&gt;人：&lt;/span&gt;&#123;&#123; item.receiver &#125;&#125; &lt;/li&gt; &lt;li&gt;&lt;span&gt;联系方式：&lt;/span&gt;&#123;&#123; item.contact &#125;&#125;&lt;/li&gt; &lt;li&gt;&lt;span&gt;收货地址：&lt;/span&gt;&#123;&#123; item.fullLocation + item.address &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;i class=&quot;iconfont icon-close-new close&quot; @click=&quot;removeAddress(item)&quot; &gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;template #footer&gt; &lt;span class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;toggleAddress&quot;&gt;确定&lt;/el-button&gt; &lt;/span&gt; &lt;/template&gt; &lt;/el-dialog&gt; &lt;!-- 添加地址 --&gt; &lt;el-dialog title=&quot;添加收货地址&quot; width=&quot;30%&quot; center v-model=&quot;addDialogVisible&quot;&gt; &lt;div class=&quot;addressWrapper&quot;&gt; &lt;el-form label-width=&quot;100px&quot; :model=&quot;formData&quot; style=&quot;max-width: 460px&quot;&gt; &lt;el-form-item label=&quot;收货人&quot; required&gt; &lt;el-input placeholder=&quot;请输入收货人&quot; v-model=&quot;formData.receiver&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;手机号&quot; required&gt; &lt;el-input placeholder=&quot;请输入手机号&quot; v-model=&quot;formData.contact&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;地区&quot; required&gt; &lt;el-cascader placeholder=&quot;请选择所在地区&quot; v-model=&quot;formData.region&quot; :options=&quot;regionData&quot; @change=&quot;handleChange&quot; required /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;详细地址&quot; required&gt; &lt;el-input placeholder=&quot;请输入详细地址&quot; v-model=&quot;formData.address&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;邮政编码&quot; required&gt; &lt;el-input placeholder=&quot;请输入邮政编码&quot; v-model=&quot;formData.postalCode&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;地址标签&quot; required&gt; &lt;el-input placeholder=&quot;请输入地址标签&quot; v-model=&quot;formData.addressTags&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;设为默认地址&quot; required&gt; &lt;el-switch v-model=&quot;formData.isDefault&quot; :active-value=&quot;0&quot; :inactive-value=&quot;1&quot; /&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;template #footer&gt; &lt;span class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;cancel&quot;&gt;取消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;confirm&quot;&gt;确定&lt;/el-button&gt; &lt;/span&gt; &lt;/template&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.xtx-pay-checkout-page &#123; margin-top: 20px; .wrapper &#123; background: #fff; padding: 0 20px; .box-title &#123; font-size: 16px; font-weight: normal; padding-left: 10px; line-height: 70px; border-bottom: 1px solid #f5f5f5; &#125; .box-body &#123; padding: 20px 0; &#125; &#125;&#125;.address &#123; border: 1px solid #f5f5f5; display: flex; align-items: center; .text &#123; flex: 1; min-height: 90px; display: flex; align-items: center; .none &#123; line-height: 90px; color: #999; text-align: center; width: 100%; &#125; &gt; ul &#123; flex: 1; padding: 20px; li &#123; line-height: 30px; span &#123; color: #999; margin-right: 5px; &gt; i &#123; width: 0.5em; display: inline-block; &#125; &#125; &#125; &#125; &gt; a &#123; color: $xtxColor; width: 160px; text-align: center; height: 90px; line-height: 90px; border-right: 1px solid #f5f5f5; &#125; &#125; .action &#123; width: 420px; text-align: center; .btn &#123; width: 140px; height: 46px; line-height: 44px; font-size: 14px; &amp;:first-child &#123; margin-right: 10px; &#125; &#125; &#125;&#125;.goods &#123; width: 100%; border-collapse: collapse; border-spacing: 0; .info &#123; display: flex; text-align: left; img &#123; width: 70px; height: 70px; margin-right: 20px; &#125; .right &#123; line-height: 24px; p &#123; &amp;:last-child &#123; color: #999; &#125; &#125; &#125; &#125; tr &#123; th &#123; background: #f5f5f5; font-weight: normal; &#125; td, th &#123; text-align: center; padding: 20px; border-bottom: 1px solid #f5f5f5; &amp;:first-child &#123; border-left: 1px solid #f5f5f5; &#125; &amp;:last-child &#123; border-right: 1px solid #f5f5f5; &#125; &#125; &#125;&#125;.my-btn &#123; width: 228px; height: 50px; border: 1px solid #e4e4e4; text-align: center; line-height: 48px; margin-right: 25px; color: #666666; display: inline-block; &amp;.active, &amp;:hover &#123; border-color: $xtxColor; &#125;&#125;.total &#123; dl &#123; display: flex; justify-content: flex-end; line-height: 50px; dt &#123; i &#123; display: inline-block; width: 2em; &#125; &#125; dd &#123; width: 240px; text-align: right; padding-right: 70px; &amp;.price &#123; font-size: 20px; color: $priceColor; &#125; &#125; &#125;&#125;.submit &#123; text-align: right; padding: 60px; border-top: 1px solid #f5f5f5;&#125;.addressWrapper &#123; max-height: 500px; overflow-y: auto; :deep(.el-form-item__label) &#123; width: 120px !important; &#125;&#125;.text &#123; flex: 1; position: relative; min-height: 90px; display: flex; align-items: center; &amp;.item &#123; border: 1px solid #f5f5f5; margin-bottom: 10px; cursor: pointer; &amp;.active, &amp;:hover &#123; border-color: $xtxColor; background: lighten($xtxColor, 50%); &#125; &amp;:hover .close &#123; opacity: 1; &#125; &gt; ul &#123; padding: 10px; font-size: 14px; line-height: 30px; &#125; .close &#123; position: absolute; top: 10px; right: 10px; opacity: 0; &#125; &#125;&#125;&lt;/style&gt; 十一、支付页1、整体结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;script setup&gt;import &#123; getOrderAPI &#125; from &quot;@/apis/payPage&quot;;import &#123; useRoute &#125; from &quot;vue-router&quot;;import &#123; ref, computed &#125; from &quot;vue&quot;;import &#123; onMounted &#125; from &quot;vue&quot;;import dayjs from &quot;dayjs&quot;;import &#123; onUnmounted &#125; from &quot;vue&quot;;const route = useRoute();const payInfo = ref(&#123;&#125;);const time = ref(0);let timer = null;const getPayInfo = async () =&gt; &#123; const &#123; data &#125; = await getOrderAPI(route.params.id); payInfo.value = data.result; time.value = data.result.countdown; timer = setInterval(() =&gt; &#123; time.value--; &#125;, 1000);&#125;;const formateTime = computed(() =&gt; dayjs.unix(time.value).format(&quot;mm分ss秒&quot;));onMounted(() =&gt; getPayInfo());// 点击支付宝付款const baseURL = &quot;http://pcapi-xiaotuxian-front-devtest.itheima.net/&quot;;const backURL = &quot;http://localhost:5173/paycallback&quot;;const redirectUrl = encodeURIComponent(backURL);const payUrl = `$&#123;baseURL&#125;pay/aliPay?orderId=$&#123;route.params.id&#125;&amp;redirect=$&#123;redirectUrl&#125;`;// 别忘了组件销毁时手动清除定时器，因为浏览器在组件销毁后并不会自动清除定时器onUnmounted(() =&gt; clearInterval(timer));&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;xtx-pay-page&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 付款信息 --&gt; &lt;div class=&quot;pay-info&quot;&gt; &lt;span class=&quot;icon iconfont icon-queren2&quot;&gt;&lt;/span&gt; &lt;div class=&quot;tip&quot;&gt; &lt;p&gt;订单提交成功！请尽快完成支付。&lt;/p&gt; &lt;p&gt; 支付还剩 &lt;span&gt;&#123;&#123; formateTime &#125;&#125;&lt;/span &gt;, 超时后将取消订单 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;amount&quot;&gt; &lt;span&gt;应付总额：&lt;/span&gt; &lt;span&gt;¥&#123;&#123; payInfo.payMoney?.toFixed(2) &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 付款方式 --&gt; &lt;div class=&quot;pay-type&quot;&gt; &lt;p class=&quot;head&quot;&gt;选择以下支付方式付款&lt;/p&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;支付平台&lt;/p&gt; &lt;a class=&quot;btn wx&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a class=&quot;btn alipay&quot; :href=&quot;payUrl&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;支付方式&lt;/p&gt; &lt;a class=&quot;btn&quot; href=&quot;javascript:;&quot;&gt;招商银行&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;javascript:;&quot;&gt;工商银行&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;javascript:;&quot;&gt;建设银行&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;javascript:;&quot;&gt;农业银行&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;javascript:;&quot;&gt;交通银行&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.xtx-pay-page &#123; margin-top: 20px;&#125;.pay-info &#123; background: #fff; display: flex; align-items: center; height: 240px; padding: 0 80px; .icon &#123; font-size: 80px; color: #1dc779; &#125; .tip &#123; padding-left: 10px; flex: 1; p &#123; &amp;:first-child &#123; font-size: 20px; margin-bottom: 5px; &#125; &amp;:last-child &#123; color: #999; font-size: 16px; &#125; &#125; &#125; .amount &#123; span &#123; &amp;:first-child &#123; font-size: 16px; color: #999; &#125; &amp;:last-child &#123; color: $priceColor; font-size: 20px; &#125; &#125; &#125;&#125;.pay-type &#123; margin-top: 20px; background-color: #fff; padding-bottom: 70px; p &#123; line-height: 70px; height: 70px; padding-left: 30px; font-size: 16px; &amp;.head &#123; border-bottom: 1px solid #f5f5f5; &#125; &#125; .btn &#123; width: 150px; height: 50px; border: 1px solid #e4e4e4; text-align: center; line-height: 48px; margin-left: 30px; color: #666666; display: inline-block; &amp;.active, &amp;:hover &#123; border-color: $xtxColor; &#125; &amp;.alipay &#123; background: url(https://cdn.cnbj1.fds.api.mi-img.com/mi-mall/7b6b02396368c9314528c0bbd85a2e06.png) no-repeat center / contain; &#125; &amp;.wx &#123; background: url(https://cdn.cnbj1.fds.api.mi-img.com/mi-mall/c66f98cff8649bd5ba722c2e8067c6ca.jpg) no-repeat center / contain; &#125; &#125;&#125;&lt;/style&gt; 2、支付业务流程 因此，在前端我们只需要给点击支付一个 URL 地址，并携带 orderId 参数和 redirect 参数（用于指定支付完成后的回跳地址）即可。支付完成后，页面会携带订单 id 和支付状态的参数自动跳转到我们给定的这个回跳地址 3、支付结果展示paycallback 组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;script setup&gt;import &#123; getOrderAPI &#125; from &quot;@/apis/payPage&quot;;import &#123; onMounted, ref &#125; from &quot;vue&quot;;import &#123; useRoute &#125; from &quot;vue-router&quot;;const route = useRoute();const orderInfo = ref(&#123;&#125;);const getOrderInfo = async () =&gt; &#123; const &#123; data &#125; = await getOrderAPI(route.query.orderId); orderInfo.value = data.result;&#125;;onMounted(() =&gt; getOrderInfo());&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;xtx-pay-page&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 支付结果 --&gt; &lt;div class=&quot;pay-result&quot;&gt; &lt;span class=&quot;iconfont icon-queren2 green&quot; v-if=&quot;$route.query.payResult === &#x27;true&#x27;&quot; &gt;&lt;/span&gt; &lt;span class=&quot;iconfont icon-shanchu red&quot; v-else&gt;&lt;/span&gt; &lt;p class=&quot;tit&quot;&gt; 支付&#123;&#123; $route.query.payResult === &quot;true&quot; ? &quot;成功&quot; : &quot;失败&quot; &#125;&#125; &lt;/p&gt; &lt;p class=&quot;tip&quot;&gt;我们将尽快为您发货，收货期间请保持手机畅通&lt;/p&gt; &lt;p&gt;支付方式：&lt;span&gt;支付宝&lt;/span&gt;&lt;/p&gt; &lt;p&gt; 支付金额：&lt;span&gt;¥&#123;&#123; orderInfo.payMoney?.toFixed(2) &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;div class=&quot;btn&quot;&gt; &lt;el-button type=&quot;primary&quot; style=&quot;margin-right: 20px&quot; @click=&quot;$router.push(&#x27;/VIP&#x27;)&quot; &gt;查看订单&lt;/el-button &gt; &lt;el-button @click=&quot;$router.push(&#x27;/&#x27;)&quot;&gt;进入首页&lt;/el-button&gt; &lt;/div&gt; &lt;p class=&quot;alert&quot;&gt; &lt;span class=&quot;iconfont icon-tip&quot;&gt;&lt;/span&gt; 温馨提示：小兔鲜儿不会以订单异常、系统升级为由要求您点击任何网址链接进行退款操作，保护资产、谨慎操作。 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.pay-result &#123; padding: 100px 0; background: #fff; text-align: center; margin-top: 20px; &gt; .iconfont &#123; font-size: 100px; &#125; .green &#123; color: #1dc779; &#125; .red &#123; color: $priceColor; &#125; .tit &#123; font-size: 24px; &#125; .tip &#123; color: #999; &#125; p &#123; line-height: 40px; font-size: 16px; &#125; .btn &#123; margin-top: 50px; &#125; .alert &#123; font-size: 12px; color: #999; margin-top: 50px; &#125;&#125;&lt;/style&gt; 十二、会员中心1、整体结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;xtx-member-aside&quot;&gt; &lt;div class=&quot;user-manage&quot;&gt; &lt;h4&gt;我的账户&lt;/h4&gt; &lt;div class=&quot;links&quot;&gt; &lt;RouterLink to=&quot;/VIP&quot;&gt;个人中心&lt;/RouterLink&gt; &lt;/div&gt; &lt;h4&gt;交易管理&lt;/h4&gt; &lt;div class=&quot;links&quot;&gt; &lt;RouterLink to=&quot;/VIP/myOrders&quot;&gt;我的订单&lt;/RouterLink&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;article&quot;&gt; &lt;!-- 三级路由的挂载点 --&gt; &lt;RouterView /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.container &#123; display: flex; padding-top: 20px; .xtx-member-aside &#123; width: 220px; margin-right: 20px; border-radius: 2px; background-color: #fff; .user-manage &#123; background-color: #fff; h4 &#123; font-size: 18px; font-weight: 400; padding: 20px 52px 5px; border-top: 1px solid #f6f6f6; &#125; .links &#123; padding: 0 52px 10px; &#125; a &#123; display: block; line-height: 1; padding: 15px 0; font-size: 14px; color: #666; position: relative; &amp;:hover &#123; color: $xtxColor; &#125; &amp;.active, &amp;.router-link-exact-active &#123; color: $xtxColor; &amp;:before &#123; display: block; &#125; &#125; &amp;:before &#123; content: &quot;&quot;; display: none; width: 6px; height: 6px; border-radius: 50%; position: absolute; top: 19px; left: -16px; background-color: $xtxColor; &#125; &#125; &#125; &#125; .article &#123; width: 1000px; background-color: #fff; &#125;&#125;&lt;/style&gt; 我的订单 myOrders 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318&lt;script setup&gt;import &#123; getUserOrder &#125; from &quot;@/apis/vip&quot;;import &#123; onMounted &#125; from &quot;vue&quot;;import &#123; ref &#125; from &quot;vue&quot;;// 订单列表const orderList = ref([]);const queryList = ref(&#123; orderState: 0, page: 1, pageSize: 2, totalCount: 0,&#125;);const getOrders = async () =&gt; &#123; const &#123; data &#125; = await getUserOrder(queryList.value); orderList.value = data.result.items; queryList.value.totalCount = data.result.counts;&#125;;onMounted(() =&gt; getOrders());// tab列表const tabTypes = [ &#123; name: &quot;all&quot;, label: &quot;全部订单&quot; &#125;, &#123; name: &quot;unpay&quot;, label: &quot;待付款&quot; &#125;, &#123; name: &quot;deliver&quot;, label: &quot;待发货&quot; &#125;, &#123; name: &quot;receive&quot;, label: &quot;待收货&quot; &#125;, &#123; name: &quot;comment&quot;, label: &quot;待评价&quot; &#125;, &#123; name: &quot;complete&quot;, label: &quot;已完成&quot; &#125;, &#123; name: &quot;cancel&quot;, label: &quot;已取消&quot; &#125;,];// 页码改变时const pageChange = async (val) =&gt; &#123; queryList.value.page = val; getOrders();&#125;;// tab栏切换const change = (value) =&gt; &#123; queryList.value.orderState = value; getOrders();&#125;;// 格式化订单状态显示const stateMap = &#123; 1: &quot;待付款&quot;, 2: &quot;待发货&quot;, 3: &quot;待收货&quot;, 4: &quot;待评价&quot;, 5: &quot;已完成&quot;, 6: &quot;已取消&quot;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;order-container&quot;&gt; &lt;el-tabs @tab-change=&quot;change&quot;&gt; &lt;!-- tab切换 --&gt; &lt;el-tab-pane v-for=&quot;item in tabTypes&quot; :key=&quot;item.name&quot; :label=&quot;item.label&quot; /&gt; &lt;div class=&quot;main-container&quot;&gt; &lt;div class=&quot;holder-container&quot; v-if=&quot;orderList.length === 0&quot;&gt; &lt;el-empty description=&quot;暂无订单数据&quot; /&gt; &lt;/div&gt; &lt;div v-else&gt; &lt;!-- 订单列表 --&gt; &lt;div class=&quot;order-item&quot; v-for=&quot;order in orderList&quot; :key=&quot;order.id&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;span&gt;下单时间：&#123;&#123; order.createTime &#125;&#125;&lt;/span&gt; &lt;span&gt;订单编号：&#123;&#123; order.id &#125;&#125;&lt;/span&gt; &lt;!-- 未付款，倒计时时间还有 --&gt; &lt;span class=&quot;down-time&quot; v-if=&quot;order.orderState === 1&quot;&gt; &lt;i class=&quot;iconfont icon-down-time&quot;&gt;&lt;/i&gt; &lt;b&gt;付款截止: &#123;&#123; order.countdown &#125;&#125;&lt;/b&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;body&quot;&gt; &lt;div class=&quot;column goods&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in order.skus&quot; :key=&quot;item.id&quot;&gt; &lt;a class=&quot;image&quot; href=&quot;javascript:;&quot;&gt; &lt;img :src=&quot;item.image&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;div class=&quot;info&quot;&gt; &lt;p class=&quot;name ellipsis-2&quot;&gt; &#123;&#123; item.name &#125;&#125; &lt;/p&gt; &lt;p class=&quot;attr ellipsis&quot;&gt; &lt;span&gt;&#123;&#123; item.attrsText &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;price&quot;&gt;¥&#123;&#123; item.realPay?.toFixed(2) &#125;&#125;&lt;/div&gt; &lt;div class=&quot;count&quot;&gt;x&#123;&#123; item.quantity &#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;column state&quot;&gt; &lt;p&gt;&#123;&#123; stateMap[order.orderState] &#125;&#125;&lt;/p&gt; &lt;p v-if=&quot;order.orderState === 3&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;green&quot;&gt;查看物流&lt;/a&gt; &lt;/p&gt; &lt;p v-if=&quot;order.orderState === 4&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;green&quot;&gt;评价商品&lt;/a&gt; &lt;/p&gt; &lt;p v-if=&quot;order.orderState === 5&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;green&quot;&gt;查看评价&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column amount&quot;&gt; &lt;p class=&quot;red&quot;&gt;¥&#123;&#123; order.payMoney?.toFixed(2) &#125;&#125;&lt;/p&gt; &lt;p&gt;（含运费：¥&#123;&#123; order.postFee?.toFixed(2) &#125;&#125;）&lt;/p&gt; &lt;p&gt;在线支付&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;column action&quot;&gt; &lt;el-button v-if=&quot;order.orderState === 1&quot; type=&quot;primary&quot; size=&quot;small&quot; &gt; 立即付款 &lt;/el-button&gt; &lt;el-button v-if=&quot;order.orderState === 3&quot; type=&quot;primary&quot; size=&quot;small&quot; &gt; 确认收货 &lt;/el-button&gt; &lt;p&gt;&lt;a href=&quot;javascript:;&quot;&gt;查看详情&lt;/a&gt;&lt;/p&gt; &lt;p v-if=&quot;[2, 3, 4, 5].includes(order.orderState)&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;再次购买&lt;/a&gt; &lt;/p&gt; &lt;p v-if=&quot;[4, 5].includes(order.orderState)&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;申请售后&lt;/a&gt; &lt;/p&gt; &lt;p v-if=&quot;order.orderState === 1&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;取消订单&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 分页 --&gt; &lt;div class=&quot;pagination-container&quot;&gt; &lt;el-pagination background layout=&quot;prev, pager, next&quot; :total=&quot;queryList.totalCount&quot; :page-size=&quot;queryList.pageSize&quot; :current-page=&quot;queryList.page&quot; @current-change=&quot;pageChange&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-tabs&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.order-container &#123; padding: 10px 20px; .pagination-container &#123; display: flex; justify-content: center; &#125; .main-container &#123; min-height: 500px; .holder-container &#123; min-height: 500px; display: flex; justify-content: center; align-items: center; &#125; &#125;&#125;.order-item &#123; margin-bottom: 20px; border: 1px solid #f5f5f5; .head &#123; height: 50px; line-height: 50px; background: #f5f5f5; padding: 0 20px; overflow: hidden; span &#123; margin-right: 20px; &amp;.down-time &#123; margin-right: 0; float: right; i &#123; vertical-align: middle; margin-right: 3px; &#125; b &#123; vertical-align: middle; font-weight: normal; &#125; &#125; &#125; .del &#123; margin-right: 0; float: right; color: #999; &#125; &#125; .body &#123; display: flex; align-items: stretch; .column &#123; border-left: 1px solid #f5f5f5; text-align: center; padding: 20px; &gt; p &#123; padding-top: 10px; &#125; &amp;:first-child &#123; border-left: none; &#125; &amp;.goods &#123; flex: 1; padding: 0; align-self: center; ul &#123; li &#123; border-bottom: 1px solid #f5f5f5; padding: 10px; display: flex; &amp;:last-child &#123; border-bottom: none; &#125; .image &#123; width: 70px; height: 70px; border: 1px solid #f5f5f5; &#125; .info &#123; width: 220px; text-align: left; padding: 0 10px; p &#123; margin-bottom: 5px; &amp;.name &#123; height: 38px; &#125; &amp;.attr &#123; color: #999; font-size: 12px; span &#123; margin-right: 5px; &#125; &#125; &#125; &#125; .price &#123; width: 100px; &#125; .count &#123; width: 80px; &#125; &#125; &#125; &#125; &amp;.state &#123; width: 120px; .green &#123; color: $xtxColor; &#125; &#125; &amp;.amount &#123; width: 200px; .red &#123; color: $priceColor; &#125; &#125; &amp;.action &#123; width: 140px; a &#123; display: block; &amp;:hover &#123; color: $xtxColor; &#125; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; 个人中心 userInfo 组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;script setup&gt;import &#123; useUserInfoStore &#125; from &quot;@/stores/userInfo&quot;;import &#123; getLikeListAPI &#125; from &quot;@/apis/vip&quot;;import &#123; ref, onMounted &#125; from &quot;vue&quot;;const &#123; userInfo &#125; = useUserInfoStore();const likeList = ref([]);const getLikeList = async () =&gt; &#123; const &#123; data &#125; = await getLikeListAPI(&#123; limit: 4 &#125;); likeList.value = data.result;&#125;;onMounted(() =&gt; getLikeList());&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;home-overview&quot;&gt; &lt;!-- 用户信息 --&gt; &lt;div class=&quot;user-meta&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img :src=&quot;userInfo?.avatar&quot; /&gt; &lt;/div&gt; &lt;h4&gt;&#123;&#123; userInfo?.account &#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;span class=&quot;iconfont icon-hy&quot;&gt;&lt;/span&gt; &lt;p&gt;会员中心&lt;/p&gt; &lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;span class=&quot;iconfont icon-aq&quot;&gt;&lt;/span&gt; &lt;p&gt;安全设置&lt;/p&gt; &lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;span class=&quot;iconfont icon-dw&quot;&gt;&lt;/span&gt; &lt;p&gt;地址管理&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;like-container&quot;&gt; &lt;div class=&quot;home-panel&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;h4 data-v-bcb266e0=&quot;&quot;&gt;猜你喜欢&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;goods-list&quot;&gt; &lt;GoodsItem v-for=&quot;good in likeList&quot; :key=&quot;good.id&quot; :goods=&quot;good&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.home-overview &#123; height: 132px; background: url(@/assets/images/center-bg.png) no-repeat center / cover; display: flex; .user-meta &#123; flex: 1; display: flex; align-items: center; .avatar &#123; width: 85px; height: 85px; border-radius: 50%; overflow: hidden; margin-left: 60px; img &#123; width: 100%; height: 100%; &#125; &#125; h4 &#123; padding-left: 26px; font-size: 18px; font-weight: normal; color: white; &#125; &#125; .item &#123; flex: 1; display: flex; align-items: center; justify-content: space-around; &amp;:first-child &#123; border-right: 1px solid #f4f4f4; &#125; a &#123; color: white; font-size: 16px; text-align: center; .iconfont &#123; font-size: 32px; &#125; p &#123; line-height: 32px; &#125; &#125; &#125;&#125;.like-container &#123; margin-top: 20px; border-radius: 4px; background-color: #fff;&#125;.home-panel &#123; background-color: #fff; padding: 0 20px; margin-top: 20px; height: 400px; .header &#123; height: 66px; border-bottom: 1px solid #f5f5f5; padding: 18px 0; display: flex; justify-content: space-between; align-items: baseline; h4 &#123; font-size: 22px; font-weight: 400; &#125; &#125; .goods-list &#123; display: flex; justify-content: space-around; &#125;&#125;&lt;/style&gt; 这样一个基本的电商类项目就开发完成了，源码见https://github.com/congtianfeng/xtx-pc/","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"配合腾讯云Cos封装一个上传图片组件","slug":"配合腾讯云Cos封装一个上传图片组件","date":"2022-12-03T12:12:01.000Z","updated":"2024-03-15T08:46:42.339Z","comments":true,"path":"2022/12/03/配合腾讯云Cos封装一个上传图片组件/","link":"","permalink":"https://congtf.top/2022/12/03/%E9%85%8D%E5%90%88%E8%85%BE%E8%AE%AF%E4%BA%91Cos%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%BB%84%E4%BB%B6/","excerpt":"","text":"一、需求分析该组件需要满足以下要求： 可以显示传入的图片地址 可以删除传入的图片地址 可以上传图片到云服务器 上传到腾讯云之后，可以返回图片地址，显示 上传成功之后，可以回调成功函数 从上图中，我们可以看到，实际上是有两种场景的，本地场景和已经上传的场景 二、安装 JavaScript SDK1$ npm i cos-js-sdk-v5 --save 三、实例化上传 sdk 名称 描述 SecretId 开发者拥有的项目身份识别 ID，用以身份认证，可在 API 密钥管理 页面获取 SecretKey 开发者拥有的项目身份密钥，可在 API 密钥管理 页面获取 注意，为了方便，这里直接将参数放置在前端代码中存储，但是腾讯云本身是不建议这么做的，因为**敏感信息**放在前端很容易被捕获。 正确的做法应该是，通过网站调用接口换取敏感信息 相关文档 1234var cos = new COS(&#123; SecretId: &quot;COS_SECRETID&quot;, // 身份识别 ID SecretKey: &quot;COS_SECRETKEY&quot;, // 身份密钥&#125;); 四、准备组件并注册新建上传图片组件 src/components/ImageUpload/index.vue 上传组件，我们可以沿用 element 的 el-upload 组件,并且采用照片墙的模式 list-type=&quot;picture-card&quot; 放置 el-upload 组件 12345&lt;template&gt; &lt;el-upload list-type=&quot;picture-card&quot;&gt; &lt;i class=&quot;el-icon-plus&quot; /&gt; &lt;/el-upload&gt;&lt;/template&gt; 全局注册组件 123456import ImageUpload from &quot;./ImageUpload&quot;;export default &#123; install(Vue) &#123; Vue.component(&quot;ImageUpload&quot;, ImageUpload); // 注册导入上传组件 &#125;,&#125;; 五、上传动作调用上传腾讯云腾讯云文档地址 1、上传123456789101112131415161718// 进行上传操作upload(params) &#123;// console.log(params.file) if (params.file) &#123; // 执行上传操作 cos.putObject(&#123; Bucket: &#x27;shuiruohanyu-106-1302806742&#x27;, // 存储桶 Region: &#x27;ap-beijing&#x27;, // 地域 Key: params.file.name, // 文件名 Body: params.file, // 要上传的文件对象 StorageClass: &#x27;STANDARD&#x27; // 上传的模式类型 直接默认 标准模式即可 // 上传到腾讯云 =》 哪个存储桶 哪个地域的存储桶 文件 格式 名称 回调 &#125;, function(err, data) &#123; // data返回数据之后 应该如何处理 console.log(err || data) &#125;) &#125;&#125; 2、上传成功后处理返回数据确定要上传记录 id 12345678910111213141516171819beforeUpload(file) &#123; // 先检查文件类型 const types = [&#x27;image/jpeg&#x27;, &#x27;image/gif&#x27;, &#x27;image/bmp&#x27;, &#x27;image/png&#x27;] if (!types.some(item =&gt; item === file.type)) &#123; // 如果不存在 this.$message.error(&#x27;上传图片只能是 JPG、GIF、BMP、PNG 格式!&#x27;) return false // 上传终止 &#125; // 检查文件大小 5M 1M = 1024KB 1KB = 1024B const maxSize = 5 * 1024 * 1024 if (file.size &gt; maxSize) &#123; // 超过了限制的文件大小 this.$message.error(&#x27;上传的图片大小不能大于5M&#x27;) return false &#125; // 已经确定当前上传的就是当前的这个file了 this.currentFileUid = file.uid return true // 最后一定要return true &#125;, 处理返回的数据 123456789101112131415161718192021222324252627282930313233343536// 进行上传操作upload(params) &#123;// console.log(params.file) if (params.file) &#123; // 执行上传操作 cos.putObject(&#123; Bucket: &#x27;shuiruohanyu-106-1302806742&#x27;, // 存储桶 Region: &#x27;ap-beijing&#x27;, // 地域 Key: params.file.name, // 文件名 Body: params.file, // 要上传的文件对象 StorageClass: &#x27;STANDARD&#x27; // 上传的模式类型 直接默认 标准模式即可 // 上传到腾讯云 =》 哪个存储桶 哪个地域的存储桶 文件 格式 名称 回调 &#125;, (err, data) =&gt; &#123; // data返回数据之后 应该如何处理 console.log(err || data) // data中有一个statusCode === 200 的时候说明上传成功 if (!err &amp;&amp; data.statusCode === 200) &#123; // 此时说明文件上传成功 要获取成功的返回地址 // fileList才能显示到上传组件上 此时我们要将fileList中的数据的url地址变成 现在上传成功的地址 // 目前虽然是一张图片 但是请注意 我们的fileList是一个数组 // 需要知道当前上传成功的是哪一张图片 this.fileList = this.fileList.map(item =&gt; &#123; // 去找谁的uid等于刚刚记录下来的id if (item.uid === this.currentFileUid) &#123; // 将成功的地址赋值给原来的url属性 return &#123; url: &#x27;http://&#x27; + data.Location, upload: true &#125; // upload 为true 表示这张图片已经上传完毕 这个属性要为我们后期应用的时候做标记 // 保存 =&gt; 图片有大有小 =&gt; 上传速度有快又慢 =&gt;要根据有没有upload这个标记来决定是否去保存 &#125; return item &#125;) // 将上传成功的地址 回写到了fileList中 fileList变化 =》 upload组件 就会根据fileList的变化而去渲染视图 &#125; &#125;) &#125;&#125; 我们在 fileList 中设置了属性为 upload 为 true 的属性，表示该图片已经上传成功了，如果 fileList 还有 upload 不为 true 的数据，那就表示该图片还没有上传完毕 六、上传的进度条显示放置进度条 1&lt;el-progress v-if=&quot;showPercent&quot; style=&quot;width: 180px&quot; :percentage=&quot;percent&quot; /&gt; 通过腾讯云 sdk 监听上传进度 123456789101112cos.putObject(&#123; // 配置 Bucket: &#x27;laogao-1302806742&#x27;, // 存储桶名称 Region: &#x27;ap-guangzhou&#x27;, // 存储桶地域 Key: params.file.name, // 文件名作为key StorageClass: &#x27;STANDARD&#x27;, // 此类写死 Body: params.file, // 将本地的文件赋值给腾讯云配置 // 进度条 onProgress: (params) =&gt; &#123; this.percent = params.percent * 100 &#125; &#125; 七、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;template&gt; &lt;!-- 上传组件 --&gt; &lt;div&gt; &lt;!-- :class=&quot;&#123; class名称：布尔值 &#125;&quot; --&gt; &lt;!-- el-upload之所以能够显示图片 是因为 fileList中有值 --&gt; &lt;el-upload list-type=&quot;picture-card&quot; :file-list=&quot;fileList&quot; :on-preview=&quot;preview&quot; :on-remove=&quot;handleRemove&quot; :on-change=&quot;changeFile&quot; :before-upload=&quot;beforeUpload&quot; :http-request=&quot;upload&quot; action=&quot;#&quot; :class=&quot;&#123; disabled: fileComputed &#125;&quot; &gt; &lt;i class=&quot;el-icon-plus&quot; /&gt; &lt;/el-upload&gt; &lt;el-progress v-if=&quot;showPercent&quot; :percentage=&quot;percent&quot; style=&quot;width: 180px&quot; /&gt; &lt;!-- 预览图片 --&gt; &lt;el-dialog :visible.sync=&quot;showDialog&quot; title=&quot;图片预览&quot;&gt; &lt;img :src=&quot;imgUrl&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import COS from &quot;cos-js-sdk-v5&quot;;const cos = new COS(&#123; SecretId: &quot;AKID0mqfEWqlUzIbeSkGRL6c7ML6c0B93To9&quot;, // 身份识别 ID SecretKey: &quot;JFwNZdeRF2iOp03FFsGNDm44vWFitmNF&quot;, // 身份密钥&#125;);export default &#123; props: &#123; limit: &#123; type: Number, default: 1, &#125;, &#125;, data() &#123; return &#123; showPercent: false, // 控制进度条的显示和隐藏 percent: 0, // 当前的进度 showDialog: false, // 默认隐藏 imgUrl: &quot;&quot;, fileList: [], &#125;; &#125;, computed: &#123; // 只要该计算属性为true 就表示 我们需要隐藏上传按钮 fileComputed() &#123; return this.fileList.length === this.limit; &#125;, &#125;, methods: &#123; preview(file) &#123; this.imgUrl = file.url; this.showDialog = true; &#125;, // file就是要删除的file handleRemove(file) &#123; // 根据file中uid将当前的fileList中的数据进行移除 this.fileList = this.fileList.filter((item) =&gt; item.uid !== file.uid); // filter方法会得到一个新的数组 &#125;, // 不能够一味 的进行push 因为该函数会被多次调用 fileList其实就是当前最新的文件列表 changeFile(file, fileList) &#123; // this.fileList = [...fileList] this.fileList = fileList.map((item) =&gt; item); &#125;, // 上传之前检查 beforeUpload(file) &#123; // console.log(file) // 要开始做文件上传的检查了 // 文件类型 文件大小 const types = [&quot;image/jpeg&quot;, &quot;image/gif&quot;, &quot;image/bmp&quot;, &quot;image/png&quot;]; if (!types.includes(file.type)) &#123; this.$message.error(&quot;上传图片只能是 JPG、GIF、BMP、PNG 格式!&quot;); return false; &#125; // 文件大小 const maxSize = 25 * 1024 * 1024; if (maxSize &lt; file.size) &#123; this.$message.error(&quot;图片最大的大小为5M&quot;); return false; &#125; return true; // 要返回true &#125;, // 上传到腾讯云 // 自定义上传动作 upload(params) &#123; // params中的file就是要上传的图片文件 // console.log(params.file) if (params.file) &#123; this.showPercent = true; // 显示进度条 // 上传对象到腾讯云 cos.putObject( &#123; Bucket: &quot;shuiruohanyu-1302806742&quot; /* 每个人的存储桶名称 */, Region: &quot;ap-nanjing&quot; /* 存储桶所在地域，必须字段 */, Key: params.file.name /* 文件名称 */, StorageClass: &quot;STANDARD&quot;, // 固定值 Body: params.file, // 上传文件对象 onProgress: (progressData) =&gt; &#123; // console.log(progressData.percent * 100) this.percent = progressData.percent * 100; &#125;, &#125;, (err, data) =&gt; &#123; console.log(err); if (data.statusCode === 200 &amp;&amp; data.Location) &#123; // 认为此时上传成功 // 需要知道当前的这个地址是谁的url地址 // params.file.uid =&gt; 当前上传文件的标识 如果找到了一一样的uid 就表示他们是一张图片 console.log(this.fileList); // 这样相当于将原来的旧本地地址换成了新地址 this.fileList = this.fileList.map((item) =&gt; &#123; // 将本地的地址替换成线上已经放在腾讯云之后的地址 if (item.uid === params.file.uid) &#123; // upload 为true的意思是 表示这张图片 已经上传过了 已经不是本地图片了 return &#123; url: &quot;http://&quot; + data.Location, upload: true &#125;; &#125; return item; &#125;); this.showPercent = false; // 关闭进度条 this.percent = 0; // 将进度归0 &#125; &#125; ); &#125; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style&gt;.disabled .el-upload--picture-card &#123; display: none;&#125;&lt;/style&gt; *通过上面的代码，我们会发现，我们把上传之后的图片信息都给了**fileList数据，那么在应用时，就可以直接获取该实例的fileList数据即可*** 八、使用12345678&lt;el-row class=&quot;inline-info&quot;&gt; &lt;el-col :span=&quot;12&quot;&gt; &lt;el-form-item label=&quot;员工头像&quot;&gt; &lt;!-- 放置上传图片 --&gt; &lt;image-upload ref=&quot;staffPhoto&quot; /&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; 1、读取时赋值1234567async getUserDetailById() &#123; this.userInfo = await getUserDetailById(this.userId) if (this.userInfo.staffPhoto) &#123; // 这里我们赋值，同时需要给赋值的地址一个标记 upload: true this.$refs.staffPhoto.fileList = [&#123; url: this.userInfo.staffPhoto, upload: true &#125;] &#125; &#125;, 2、更新图片时获取图片内容123456789101112async saveUser() &#123; // 去读取 员工上传的头像 const fileList = this.$refs.staffPhoto.fileList // 读取上传组件的数据 if (fileList.some(item =&gt; !item.upload)) &#123; // 如果此时去找 upload为false的图片 找到了说明 有图片还没有上传完成 this.$message.warning(&#x27;您当前还有图片没有上传完成！&#x27;) return &#125; // 通过合并 得到一个新对象 await saveUserDetailById(&#123; ...this.userInfo, staffPhoto: fileList &amp;&amp; fileList.length ? fileList[0].url : &#x27;&#x27; &#125;) this.$message.success(&#x27;保存基本信息成功&#x27;) &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"axios二次封装","slug":"axios二次封装","date":"2022-07-28T11:59:46.000Z","updated":"2024-03-15T08:50:05.917Z","comments":true,"path":"2022/07/28/axios二次封装/","link":"","permalink":"https://congtf.top/2022/07/28/axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/","excerpt":"","text":"axios 作为网络请求的第三方工具, 可以进行请求和响应的拦截 一般我们可以在请求拦截器中处理 token 的统一注入问题、token 超时拦截问题。响应拦截器则主要处理数据结构和数据异常 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import axios from &quot;axios&quot;;import &#123; Message &#125; from &quot;element-ui&quot;;import &#123; getTimeStamp &#125; from &quot;@/utils/auth&quot;;import store from &quot;@/store&quot;;import router from &quot;@/router&quot;;const TimeOut = 5400; // 定义超时时间const service = axios.create(&#123; // 设置基础地址 // 环境变量 npm run dev /api /生产环境 npm run build /prod-api baseURL: process.env.VUE_APP_BASE_API, timeout: 5000, // 认为只要超过5秒钟不响应 就超时&#125;);// 请求拦截器service.interceptors.request.use( async (config) =&gt; &#123; // 请求接口 config是请求配置 // 取token if (store.getters.token) &#123; // 只要有token 就要检查token时效性 if (CheckIsTimeOut()) &#123; // 继续？ await store.dispatch(&quot;user/lgout&quot;); router.push(&quot;/login&quot;); // 跳到登录 return Promise.reject(new Error(&quot;您的token已经失效&quot;)); &#125; // 如果存在token config.headers.Authorization = `Bearer $&#123;store.getters.token&#125;`; // return config &#125; // 这里一定要注意 // 一定要return config return config; &#125;, (error) =&gt; &#123; return Promise.reject(error); &#125;);// 响应拦截器service.interceptors.response.use( (response) =&gt; &#123; // 成功执行 // axios默认加了一层data的包裹 const &#123; success, message, data &#125; = response.data; if (success) &#123; // 此时认为业务执行成功了 return data; // 返回用户所需要的数据 &#125; else &#123; // 当业务失败的时候 Message.error(message); // 提示消息 return Promise.reject(new Error(message)); &#125; &#125;, async (error) =&gt; &#123; // error 有response对象 config if ( error.response &amp;&amp; error.response.data &amp;&amp; error.response.data.code === 10002 ) &#123; // 后端告诉前端token超时了 await store.dispatch(&quot;user/lgout&quot;); // 调用登出action router.push(&quot;/login&quot;); // 跳到登录页 &#125; // 失败 // Message等同于 this.$message Message.error(error.message); // 提示错误 // reject return Promise.reject(error); // 传入一个错误的对象 就认为promise执行链 进入了catch &#125;);// 检查token是否过期function CheckIsTimeOut() &#123; // 当前时间 - 存储的时间戳 &gt; 时效性 false tr return (Date.now() - getTimeStamp()) / 1000 &gt; TimeOut;&#125;export default service;","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"组件、自定义指令和自定义过滤器的注册","slug":"组件、自定义指令和自定义过滤器的注册","date":"2022-06-11T11:31:05.000Z","updated":"2024-03-15T08:49:10.821Z","comments":true,"path":"2022/06/11/组件、自定义指令和自定义过滤器的注册/","link":"","permalink":"https://congtf.top/2022/06/11/%E7%BB%84%E4%BB%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%B3%A8%E5%86%8C/","excerpt":"","text":"一、组件的注册1、全局注册12import DemoComponent from &quot;@/components/Democomponent&quot;;Vue.component(&quot;my-component-name&quot;, DemoComponent); 第一个参数是组件名，第二个参数是导入的组件对象实例 定义组件名有两种方式 第一种使用短横线分隔命名。字母全小写，就像上面的例子一样。但是使用这种方式命名，在引用这个自定义元素时也必须使用使用短横线分隔命名，字母全小写的方式，就像这样 &lt;my-component-name&gt;。 第二种使用大驼峰命名 (首字母大写命名) 。这种方式，在引用这个自定义元素时两种命名法都可以使用。也就是说 &lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有第一种方式是有效的。 给予组件的名字可能依赖于打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，vue 官方强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。 2、局部注册局部注册只需在组件中配置一个 components 配置项即可 12import DemoComponent from &#x27;./Democomponent&#x27; export default &#123; components: &#123;DemoComponent &#125; &#125; 3、批量全局注册如果有大量的通用组件需要全局注册，那么我们的 main.js 文件很可能会变成这样 12345678910import DemoComponentA from &quot;@/components/DemocomponentA&quot;;import DemoComponentB from &quot;@/components/DemocomponentB&quot;;import DemoComponentC from &quot;@/components/DemocomponentC&quot;;import DemoComponentD from &quot;@/components/DemocomponentD&quot;;import DemoComponentE from &quot;@/components/DemocomponentE&quot;;Vue.component(&quot;my-component-nameA&quot;, DemoComponentA);Vue.component(&quot;my-component-nameB&quot;, DemoComponentB);Vue.component(&quot;my-component-nameC&quot;, DemoComponentC);Vue.component(&quot;my-component-nameD&quot;, DemoComponentD);Vue.component(&quot;my-component-nameE&quot;, DemoComponentE); 为了保持 main.js 文件的简洁，我们可以将需要全局注册的通用组件统统放在一个单独的文件夹中，&#x2F;src&#x2F;components，在其中的 index.js 文件中将这些组件统一导入注册，再暴露出去交给 main.js 给 Vue 使用 12345678910111213141516171819import PageTools from &quot;./PageTools&quot;;import UploadExcel from &quot;./UploadExcel&quot;;import ImageUpload from &quot;./ImageUpload&quot;;import ScreenFull from &quot;./ScreenFull&quot;;import ThemePicker from &quot;./ThemePicker&quot;;import Lang from &quot;./Lang&quot;;import TagsView from &quot;./TagsView&quot;;export default &#123; install(Vue) &#123; Vue.component(&quot;PageTools&quot;, PageTools); Vue.component(&quot;UploadExcel&quot;, UploadExcel); Vue.component(&quot;ImageUpload&quot;, ImageUpload); Vue.component(&quot;ScreenFull&quot;, ScreenFull); Vue.component(&quot;ThemePicker&quot;, ThemePicker); Vue.component(&quot;Lang&quot;, Lang); Vue.component(&quot;TagsView&quot;, TagsView); &#125;,&#125;; 12import Components from &quot;@/components&quot;;Vue.use(Components); // 注册自己的自定义组件 二、自定义指令1、全局注册12345678// 注册一个全局自定义指令 `v-focus`Vue.directive(&#x27;focus&#x27;, &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 第一个参数是指令名，注意这里不需要带 v- 第二个参数是一个配置项。可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。 vnode：Vue 编译生成的虚拟节点。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 注意，除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 2、局部注册同样局部注册，只需配置组件中的一个 directives 配置项即可 12export default &#123; directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123;el.focus() &#125; &#125; &#125; &#125; 3、批量全局注册同样如果有很多自定义指令需要全局注册，我们可以从 main.js 中分离出来单独处理。新建 src&#x2F;directives&#x2F;index.js 123456789101112131415161718192021222324// 负责管理所有的自定义指令// 只负责导出指令对象// 变量名称就是指令名称export const imageerror = &#123; // 指令内容 // 指令作用在 图片上的 dom是图片对象 // inserted 在Vue3中也改名 =&gt; mounted inserted(dom, options) &#123; // inserted执行的之后 此时 并没有对 src赋值 // 图片有地址 但是地址加载图片失败的时候 会执行一个函数 onerror dom.src = dom.src || options.value; dom.onerror = function () &#123; // 监听onerror事件 // options.value就是指令传过来的值 dom.src = options.value; // 当图片异常的时候 接收指令传过来的值 让这个值作为头像的备选 &#125;; // 只有src有值 并且加载失败才会触发onerror &#125;, // 此钩子会在给image赋值之后执行 // 这个钩子函数在Vue3中改名了 =&gt; updated componentUpdated(dom, options) &#123; dom.src = dom.src || options.value; &#125;,&#125;; 再在 main.js 中批量注册即可 123456import * as directives from &quot;@/directives&quot;;// directives是所有指令的一个集合Object.keys(directives).forEach((key) =&gt; &#123; // key就是指令名称 Vue.directive(key, directives[key]);&#125;); 三、过滤器1、全局注册12345Vue.filter(&quot;capitalize&quot;, function (value) &#123; if (!value) return &quot;&quot;; value = value.toString(); return value.charAt(0).toUpperCase() + value.slice(1);&#125;); 第一个参数是过滤器的名称，第二个参数是一个函数，通常是一些处理文本格式化的操作。 2、局部注册同样局部注册，只需配置组件中的一个 filters 配置项即可 123export default &#123; filters: &#123; capitalize: function (value) &#123; if (!value) return &#x27;&#x27;value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125; &#125; 使用时放在 JavaScript 表达式的尾部，由“管道”符号指示即可 3、全局批量注册同样如果有很多过滤器需要全局注册，我们可以从 main.js 中分离出来单独处理。新建 src&#x2F;filters&#x2F;index.js 12345678910111213141516171819202122232425262728293031323334353637function pluralize(time, label) &#123; if (time === 1) &#123; return time + label; &#125; return time + label + &quot;s&quot;;&#125;export function timeAgo(time) &#123; const between = Date.now() / 1000 - Number(time); if (between &lt; 3600) &#123; return pluralize(~~(between / 60), &quot; minute&quot;); &#125; else if (between &lt; 86400) &#123; return pluralize(~~(between / 3600), &quot; hour&quot;); &#125; else &#123; return pluralize(~~(between / 86400), &quot; day&quot;); &#125;&#125;export function numberFormatter(num, digits) &#123; const si = [ &#123; value: 1e18, symbol: &quot;E&quot; &#125;, &#123; value: 1e15, symbol: &quot;P&quot; &#125;, &#123; value: 1e12, symbol: &quot;T&quot; &#125;, &#123; value: 1e9, symbol: &quot;G&quot; &#125;, &#123; value: 1e6, symbol: &quot;M&quot; &#125;, &#123; value: 1e3, symbol: &quot;k&quot; &#125;, ]; for (let i = 0; i &lt; si.length; i++) &#123; if (num &gt;= si[i].value) &#123; return ( (num / si[i].value) .toFixed(digits) .replace(/\\.0+$|(\\.[0-9]*[1-9])0+$/, &quot;$1&quot;) + si[i].symbol ); &#125; &#125; return num.toString();&#125; 在 main.js 中批量注册 1234import * as filters from &quot;@/filters&quot;;Object.keys(filters).forEach((key) =&gt; &#123; Vue.filter(key, filters[key]);&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"AJAX","slug":"AJAX","date":"2022-05-04T10:14:49.000Z","updated":"2024-03-12T08:27:27.885Z","comments":true,"path":"2022/05/04/AJAX/","link":"","permalink":"https://congtf.top/2022/05/04/AJAX/","excerpt":"","text":"一、Ajax 基本介绍Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML） 通过 AJAX 可以在浏览器中向服务器发送异步请求，进行数据交互 最大的优势：无刷新获取数据 AJAX 的优点 可以无需刷新页面而与服务器端进行通信（实现局部刷新） 允许根据用户事件来更新部分页面内容 AJAX 的缺点 没有浏览历史，不能回退 存在跨域问题(同源) SEO 不友好 Ajax 的典型应用场景 用户名检测：注册用户时，通过 ajax 的形式，动态检测用户名是否被占用 搜索提示：当输入搜索关键字时，通过 ajax 的形式，动态加载搜索提示列 表 数据分页显示：当点击页码值的时候，通过 ajax 的形式，根据页码值动态 刷新表格的数据 数据的增删改查：数据的添加、删除、修改、查询操作，都需要通过 ajax 的 形式，来实现数据的交互 1、XMLXML 是一种可扩展标记语，被设计用来传输和存储数据。XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。 XML 格式臃肿，和数据无关的代码多，体积大，传输效率低。在 Javascript 中解析 XML 比较麻烦。现已被 JSON 代替 2、JSONJSON 的英文全称是 JavaScript Object Notation，即“JavaScript 对象。表示法”。简单来讲，JSON 就是 Javascript 对象和数组的字符串表示法，它使用文本表示一个 JS 对象或数组的信息，因此，JSON 的本质是字符 作用：JSON 是一种轻量级的文本数据交换格式，在作用上类似于 XML，专 门用于存储和传输数据，但是 JSON 比 XML 更小、更快、更易解析 现状：JSON 是在 2001 年开始被推广和使用的数据格式，到现今为止，JSON 已经成为了主流的数据交换格式 JSON 的两种结构 JSON 就是用字符串来表示 Javascript 的对象和数组。所以，JSON 中包含 对象和数组两种结构，通过这两种结构的相互嵌套，可以表示各种复杂的数据结构 对象结构：对象结构在 JSON 中表示为 { } 括起来的内容。数据结构为 { key: value, key: value, … } 的键值对结构。其中，key 必须是使用英文 的双引号包裹的字符串，value 的数据类型可以是数字、字符串、布尔值、null、 数组、对象 6 种类型 数组结构：数组结构在 JSON 中表示为 [ ] 括起来的内容。数据结构为 [ “java”, “javascript”, 30, true … ] 。数组中数据的类型同样可以是数字、 字符串、布尔值、null、数组、对象 6 种类型 JSON 语法注意事项 属性名必须使用双引号包裹 字符串类型的值必须使用双引号包裹 JSON 中不允许使用单引号表示字符串 JSON 中不能写注释 JSON 的最外层必须是对象或数组格式 不能使用 undefined 或函数作为 JSON 的值 JSON 和 JS 对象的关系 JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息， 本质是一个字符串 JSON 和 JS 对象的互转 可以使用 JSON.parse()和 JSON.stringify()方法 二、AJAX 的使用核心对象 XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的 使用步骤 创建 XMLHttpRequest 对象 1const xhr = new XMLHttpRequest(); 2.设置请求信息 123xhr.open(method, url);//可以设置请求头，一般不设置xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); 发送请求 1xhr.send(body); //get 请求不传 body 参数，只有 post 请求 4.接收响应 12345678//xhr.responseXML 接收 xml 格式的响应数据//xhr.responseText 接收文本格式的响应数据xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; const text = xhr.responseText; console.log(text); &#125;&#125;; xhr.readyState 可以用来查看请求当前的状态 0: 表示 XMLHttpRequest 实例已经生成，但是 open()方法还没有被调用。 1: 表示 send()方法还没有被调用，仍然可以使用 setRequestHeader()，设定 HTTP 请求的头信息 2: 表示 send()方法已经执行，并且头信息和状态码已经收到。 3: 表示正在接收服务器传来的 body 4: 表示服务器数据已经完全接收，或者本次接收已经失败了 使用 xhr 对象发起带参数的 GET 请求时，只需在调用 xhr.open 期间，为 URL 地址指定参数即可： 1xhr.open(&#x27;GET&#x27;,&#x27;http://congtf.top/tags?id=1&amp;title=技术&#x27;) 这种在 URL 地址后面拼接的参数，叫做查询字符串 GET 请求携带参数的本质 无论使用 $.ajax()，还是使用 $.get()，又或者直接使用 xhr 对象发起 GET 请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形 式，追加到 URL 地址的后面，发送到服务器的 123$.get(url, &#123; name: &quot;zs&quot;, age: 20 &#125;, function () &#123;&#125;);// 等价于$.get(url + &quot;?name=zs&amp;age=20&quot;, function () &#123;&#125;); 三、XMLHttpRequest Level2 的新特性旧版 XMLHttpRequest 的缺点： 只支持文本数据的传输，无法用来读取和上传文件 传送和接收数据时，没有进度信息，只能提示有没有完成 XMLHttpRequest Level2 的新功能 可以设置 HTTP 请求的时限 可以使用 FormData 可以上传文件 可以获得数据传输的进度信息 1、设置 HTTP 请求时限有时，Ajax 操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的 XMLHttpRequest 对象，增加了 timeout 属性，可 以设置 HTTP 请求的时限： 1xhr.timeout = 3000; 上面的语句，将最长等待时间设为 3000 毫秒。过了这个时限，就自动停止 HTTP 请求。与之配套的还有一个 timeout 事件，用来指定回调函数： 123xhr.ontimeout = function () &#123; alert(&quot;请求超时&quot;);&#125;; 2、FormData 对象管理表单数据Ajax 操作往往用来提交表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单操作： 1234567891011// 1.新建FormData对象const fd = new FormData();// 2.为FormData添加表单项fd.append(&quot;uname&quot;, &quot;zs&quot;);fd.append(&quot;upwd&quot;, &quot;123456&quot;);// 3.创建XHR对象const xhr = new XMLHttpRequest();// 4.发请求xhr.open(&quot;POST&quot;, &quot;http://congtf.top&quot;);// 5.直接提交FormData对象，这与提交网页表单效果完全一样xhr.send(fd); FormData 对象也可以用来获取网页表单的值，示例代码如下： 123456789101112// 获取表单元素const form = document.querySelector(&quot;#form1&quot;);// 监听表单元素的submit事件form.addEventListener(&quot;submit&quot;, function (e) &#123; e.preventDefault(); // 根据form表单创建FormData对象，会自动将表单数据填充到FormData对象中 const fd = new FormData(form); const xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;, &quot;http://congtf.top&quot;); xhr.send(fd); xhr.onreadystatechange = function () &#123;&#125;;&#125;); 3、上传文件新版 XMLHttpRequest 对象，不仅可以发送文本信息，还可以上传文件 实现步骤 定义 UI 结构 1234567&lt;!-- 文件选择框 --&gt;&lt;input type=&quot;file&quot; id=&quot;file1&quot; /&gt;&lt;!-- 上传按钮 --&gt;&lt;button id=&quot;btnUpload&quot;&gt;上传文件&lt;/button&gt;&lt;br /&gt;&lt;!-- 显示上传到服务器上的图片 --&gt;&lt;img src=&quot;&quot; id=&quot;img&quot; width=&quot;800&quot; /&gt; 验证是否选择了文件 12345678910111213141516171819202122232425262728const btnUpload = document.querySelector(&quot;#btnUpload&quot;);btn.addEventListener(&quot;click&quot;, function () &#123; const files = document.querySelector(&quot;#file1&quot;); if (files.length &lt;= 0) &#123; return alert(&quot;请选择要上传的文件！&quot;); &#125; // 创建FormData对象 const fd = new FormData(); // 追加文件 fd.append(&quot;avatar&quot;, files[0]); // 创建xhr对象 const xhr = new XMLHttpRequest(); // 发请求 xhr.open(&quot;POST&quot;, &quot;http://congtf.top&quot;); xhr.send(fd); xhr.onreadystatechange = function () &#123; if (xhr.state === 4 &amp;&amp; xhr.status === 200) &#123; const data = JSON.parse(xhr.responseText); if (data.status === 200) &#123; // 将服务器返回的图片地址设置为img标签的src属性 document.querySelector(&quot;#img&quot;).src = &quot;http://congtf.top&quot; + data.url; &#125; else &#123; // 文件上传失败 console.log(&quot;data.message&quot;); &#125; &#125; &#125;;&#125;); 向 FormData 中追加文件 使用 xhr 发起上传文件的请求 监听 onreadystatechange 事件 4、显示文件上传进度新版本的 XMLHttpRequest 对象中，可以通过监听 xhr.upload.onprogress 事件，来获取到文件的上传进度。语法格式如下： 12345678910const xhr = new XMLHttpRequest();// 监听xhr.upload的onprogress事件xhr.upload.onprogress = function (e) &#123; // e.lengthComputable是一个布尔值，表示当前上传的资源是否具有可计算的长度 if (e.lengthComputable) &#123; // e.loaded 表示已传输的字节 // e.total 表示需要传输的总字节 const percentComplete = Math.ceil((e.loaded / e.total) * 100); &#125;&#125;; 四、axiosaxios 是专注于网络数据请求的库 相比于原生的 XMLHttpRequest 对象，axios 简单易用 相比于 jQuery，axios 更加轻量化，只专注于网络数据请求 axios 发起 GET 请求 1234567axios .get(url, &#123; params: &#123; /*参数*/ &#125;, &#125;) .then(callback); 示例如下： 12345const paramsObj = &#123; name: &quot;zs&quot;, age: 20 &#125;;axios.get(&quot;http:congtf.top&quot;, &#123; params: paramsObj &#125;).then(function (res) &#123; // axios默认包了一层data，res.data才是服务器返回的数据 const result = res.data;&#125;); axios 发起 POST 请求示例如下： 12345const dataObj = &#123; name: &quot;zs&quot;, age: 20 &#125;;axios.post(&quot;http:congtf.top&quot;, dataObj).then(function (res) &#123; // axios默认包了一层data，res.data才是服务器返回的数据 const result = res.data;&#125;); 直接使用 axios 发起请求: 12345678910axios(&#123; method: &quot;请求类型&quot;, url: &quot;请求的url地址&quot;, data: &#123; /*POST数据*/ &#125;, params: &#123; /*GET参数*/ &#125;,&#125;).then(callback); 五、同源与跨域、防抖与节流1、同源策略如果两个页面的协议，域名和端口都相同，则两个页面具有相同的源 例如，下表给出了相对于 http://www.test.com/index.html （没写端口号默认 是 80）页面的同源检测 同源策略（英文全称 Same origin policy）是浏览器提供的一个安全功能 MDN 官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自 另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制 通俗的理解：浏览器规定，A 网站的 JavaScript 不允许和非同源的网站 C 之间进行资源的交互，例如： 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB 无法接触非同源网页的 DOM 无法向非同源地址发送 Ajax 请求 同源指的是两个 URL 的协议、域名、端口一致，反之，则是跨域 出现跨域的根本原因：浏览器的同源策略不允许非同源的 URL 之间进行资源的交互 浏览器对跨域请求的拦截 注意：浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器 拦截，无法被页面获取到！ 如何实现跨域数据请求 2、JSONP出现的早，兼容性好（兼容低版本 IE）。是前端程序员为了解决跨域问题， 被迫想出来的一种临时解决方案。缺点是只支持 GET 请求，不支持 POST 请求。 JSONP (JSON with Padding) 是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。 JSONP 的实现原理 由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。 但是在网页中有一些标签天生具有跨域能力，比如：img link iframe script。因此，JSONP 的实现原理，就是通过 script 标签的 src 属性，请求跨域的数据接口，并通过函数调用的形式，接收跨域接口响应回来的数据。 JSONP 的使用 12345678910111213141516171819// 动态的创建一个script标签const script document.createElement(&#x27;script&#x27;)// 设置script的src，设置回调函数script.src=&#x27;http://loacalhost:3000/testAJAX?callback=abc&#x27;function abc(data) &#123; alert(data.name)&#125;// 将script添加到body中document.body.appendChild(script)// 服务器中路由的处理router.get(&#x27;/testAJAX&#x27;,function(req,res) &#123; console.log(&#x27;收到请求&#x27;) const callback = req.query.callback const obj = &#123; name:&#x27;zs&#x27;, age:20 &#125; res.send(callback+&quot;(&quot;+JSON.stringfy(obj)+&quot;)&quot;)&#125;) 3、CORSCORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源 CORS 怎么工作的？ CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行 CORS 的使用 主要是服务器端的设置： 12345router.get(&quot;/testAJAX&quot;, function (req, res) &#123; // res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;) res.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.send(&quot;返回的相应&quot;);&#125;); 4、防抖防抖策略（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果 在这 n 秒内事件又被触发，则重新计时 防抖的应用场景 用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后， 才执行查询的请求，这样可以有效减少请求次数，节约请求资源 防抖的基本原理是在一定时间内，将多次触发的函数调用合并为一次调用执行。当用户连续触发事件时，防抖函数会清空之前设定的定时器，并重新设定一个新的定时器来延迟函数的执行。只有当用户停止操作后，在设定的时间内没有再次触发事件，则函数才会被真正地执行一次 实现一个基本的防抖函数步骤如下： 在函数外部设置一个计时器变量（例如 timeoutId）和函数执行的延迟时间（例如 delay） 当函数被触发时，清除之前设定的计时器 重新设定一个计时器，并用它来延迟函数的执行 如果在设定的延迟时间内再次触发了函数，则回到步骤 2 如果在设定的延迟时间内没有再次触发函数，计时器会触发执行原始函数 以下是一个基本的防抖函数 1234567891011function debounce(func, delay) &#123; let timeoutId; return function () &#123; const context = this; const args = arguments; clearTimeout(timeoutId); timeoutId = setTimeout(function () &#123; func.apply(context, args); &#125;, delay); &#125;;&#125; 该函数接受两个参数：要执行的函数以及防抖延迟时间。它返回一个新函数，该函数会在防抖延迟时间内被多次调用时只执行一次原始函数 5、节流节流策略（throttle），顾名思义，可以减少一段时间内事件的触发频率。 节流的应用场景 鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次 懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算 的频率，而不必去浪费 CPU 资源 节流阀的概念 高铁卫生间是否被占用，由红绿灯控制，红灯表示被占用，绿灯表示可使用 假设每个人上卫生间都需要花费 5 分钟，则五分钟之内，被占用的卫生间无法被 其他人使用 上一个人使用完毕后，需要将红灯重置为绿灯，表示下一个人可以使用卫生 间 下一个人在上卫生间之前，需要先判断控制灯是否为绿色，来知晓能否上卫 生间 类似的 节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作 当前操作执行完，必须将节流阀重置为空，表示可以执行下次操作了 每次执行操作前，必须先判断节流阀是否为空 一个基本的节流函数示例如下： 1234567891011function throttle(func, delay) &#123; let last = 0; return function (...args) &#123; const now = +new Date(); if (now - last &lt; delay) &#123; return; &#125; last = now; func.apply(this, args); &#125;;&#125; 总结防抖和节流的区别 防抖：如果事件被频繁触发，防抖能保证只有最有一次触发生效！前面 N 多 次的触发都会被忽略！当事件被触发时，函数在固定时间间隔内不被执行，只有事件停止触发后，函数才会执行一次。适用于处理一些不需要连续响应的事件（如输入框输入、按钮点击等），可以避免函数被频繁调用，提高性能和稳定性。 节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是 有选择性地执行一部分事件！当事件被触发时，函数在固定时间间隔内最多只执行一次。适用于高频率事件（如滚动、窗口调整等），可以防止函数被频繁调用，减少不必要的计算，提高性能和响应速度","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"使用自定义指令解决图片异常情况","slug":"使用自定义指令解决图片异常情况","date":"2022-04-03T11:21:22.000Z","updated":"2024-03-15T08:48:21.903Z","comments":true,"path":"2022/04/03/使用自定义指令解决图片异常情况/","link":"","permalink":"https://congtf.top/2022/04/03/%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/","excerpt":"","text":"项目中有时图片显示异常，我们可以使用自定义指令来指定默认图片 自定义指令可以采用统一的文件来管理 src/directives/index.js,这个文件负责管理所有的自定义指令 123456789101112131415161718192021222324// 负责管理所有的自定义指令// 只负责导出指令对象// 变量名称就是指令名称export const imageerror = &#123; // 指令内容 // 指令作用在 图片上的 dom是图片对象 // inserted 在Vue3中也改名 =&gt; mounted inserted(dom, options) &#123; // inserted执行的之后 此时 并没有对 src赋值 // 图片有地址 但是地址加载图片失败的时候 会执行一个函数 onerror dom.src = dom.src || options.value; dom.onerror = function () &#123; // 监听onerror事件 // options.value就是指令传过来的值 dom.src = options.value; // 当图片异常的时候 接收指令传过来的值 让这个值作为头像的备选 &#125;; // 只有src有值 并且加载失败才会触发onerror &#125;, // 此钩子会在给image赋值之后执行 // 这个钩子函数在Vue3中改名了 =&gt; updated componentUpdated(dom, options) &#123; dom.src = dom.src || options.value; &#125;,&#125;; 在 main.js 完成自定义指令全局注册 如果自定义的指令较多，可以采用批量注册的方式 1234567import * as directives from &quot;@/directives&quot;;// 注册自定义指令// 遍历所有的导出的指令对象 完成自定义全局注册Object.keys(directives).forEach((key) =&gt; &#123; // 注册自定义指令 Vue.directive(key, directives[key]);&#125;); 指令注册成功后，可以在组件中直接使用了 123456789101112&lt;template&gt; &lt;img v-imageerror=&quot;defaultImg&quot; :src=&quot;staffPhoto&quot; class=&quot;user-avatar&quot; /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; defaultImg: require(&quot;@/assets/common/head.jpg&quot;), &#125;; &#125;,&#125;;&lt;/script&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"前端学习路线","slug":"前端学习路线","date":"2022-03-27T11:07:19.000Z","updated":"2024-03-12T08:26:50.621Z","comments":true,"path":"2022/03/27/前端学习路线/","link":"","permalink":"https://congtf.top/2022/03/27/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"本篇文章列出我的前端学习路线，当然后面有很多其实我还没有掌握。前面的知识当入门后面的知识当进阶吧。我也计划将此路线当做一个题纲，后期会将每一块知识展开后形成单独文章。 一、前端入门1、HTML描述：用于定义一个网页结构的基本技术 各种标签： h 系列标签 p 标签 换行标签 水平分割线标签 文本格式化标签（加粗标签 b 和 strong、下划线标签 u 和 ins、倾斜标签 i 和 em、删除线 s 和 del） 图片标签 img 音频标签 audio 视频标签 video a 链接标签 无序列表标签 ul 搭配 li 有序列表标签 ol 搭配 li 自定义列表标签 dl 搭配 dt 和 dd 表格标签 table 搭配 tr、th、td 等 表单标签 input 系列、button、select、textarea、label 等 标签语义化 HTML5 特性： 语义化标签 浏览器支持 多媒体标签 Canvas 画布 本地存储 localStorage sessionStorage Web Workers 应用缓存（Cache Manifest） 无障碍 2、CSS描述：层叠样式表，用于设计风格和布局 引入方式：内嵌式、外联式、行内式 基础选择器： 标签选择器 类选择器 id 选择器 通配符选择器 复合选择器： 后代选择器 子代选择器 并集选择器 交集选择器 伪类选择器 字体和文本样式： font-size font-weight font-style font-family text-indent text-align text-decoration line-height 背景相关样式 background-color background-image background-repeat background-position background-size 元素显示模式：块级元素、行内元素、行内块元素 CSS 特性：继承性、层叠性、优先级 文档流 标准流 浮动流 定位流 伪元素 浮动：浮动和清除浮动、BFC 机制 定位：静态定位、相对定位、绝对定位、子绝父相、固定定位 其他：对齐方式问题 vertical-align、光标类型 cursor、边框圆角 border-radius、溢出部分显示效果、元素隐藏、元素透明度、边框合并、精灵图、字体图标、文字阴影 text-shadow、盒子阴影 box-shadow、过渡、图片模糊处理 filter:blur()、SEO 优化、网站 icon 图标、CSS 书写规范 平面转换（2D）：位移、旋转、缩放 渐变 空间转换（3D）：位移、透视、旋转、立体呈现、缩放 动画 移动端适配：屏幕尺寸和分辨率、百分比布局（流式布局）、Flex 布局（弹性布局）、媒体查询 3、JavaScript描述：具有函数优先的轻量级，解释型或即时编译型的编程语言。 JavaScript 组成： ECMAScript：规定了 js 基础语法 Web APIs：JavaScript 暴露的一些接口，用于操作文档和浏览器 数据类型 值类型 字符串 String 数组 Number 布尔 Boolean 空值 Null 未定义 Undefined Symbol 引用类型 对象 Object 数组 Array 函数 Function 数据类型转换：显式转换、隐式转换 运算符：算术运算符、赋值运算符、一元运算符、比较运算符、逻辑运算符 流程控制语句： 分支语句：if 分支语句、三元运算符、switch 语句 循环语句：while 循环、for 循环 函数：匿名函数（函数表达式）、函数调用、函数传参 对象：内置对象 DOM 操作：DOM 树、DOM 对象、设置修改 DOM 元素内容、属性、样式、定时器-间歇函数、事件、回调函数、高阶函数、环境对象 this、事件对象 e、节点操作（查找、增加、删除）、事件委托、重绘回流、滚动事件、加载事件 BOM 操作：window 对象、定时器-延时函数、location 对象、navigator 对象、histroy 对象、本地存储、正则表达式 ES6：不再说了，阮一峰老师都讲到了。ES6 入门教程 https://es6.ruanyifeng.com/ 二、AJAXXMLHttpRequest、axios http 基础知识：浏览器的同源策略、跨域及如何解决跨域、URL、防抖、节流、http 协议 三、git 和 github使用版本控制软件，将代码托管到远程仓库 四、Node.js这个我还没有系统的学过，也列出来以后学习 五、框架前置ES6 的模块化：导入导出 Promise：回调地狱、.then、.catch、async&#x2F;await 事件循环 EventLoop 六、前端工程化Vue2 框架 Vue 的几大板块：声明式渲染、组件系统、客户端路由、大规模状态管理、构建工具 Vue 基础语法： 插值表达式 MVVM 设计模式 v-bind v-on v-model v-text 和 v-html v-show 和 v-if v-for 虚拟 dom 和 diff 算法 动态 class 和动态 style 过滤器 计算属性 侦听器 watch Vue 组件： 组件通信 Vue 生命周期与钩子函数 $refs和$nextTick 动态组件与组件缓存 keep-alive 组件插槽（默认插槽、具名插槽、作用域插槽） Vue 路由系统： 声明式导航 编程式导航 重定向与路由模式 路由嵌套和路由守卫 Vuex： state mutations actions getters vuex 模块化 CSS 预编译： LESS SASS 开发框架： Express Koa Egg 组件库 ElementUI（Vue） VantUI（Vue） 数据可视化 Apache ECharts（echarts） HighCharts 数据 Mock 描述：通过随机数据，模拟各种场景，增加单元测试的真实性。 Mock.js 代码检查： ESLint StyleLint 代码风格： Prettier 包管理工具： npm yarn 打包工具： Webpack Vite 部署 Web 服务器 Nginx 描述：高性能的 HTTP 和反向代理 web 服务器。 资源：腾讯云动手实验室 https://cloud.tencent.com/developer/labs/gallery 反向代理 解决跨域 改写请求 Apache 容器 Docker 描述：容器是一个标准化的软件单元，它将代码及其所有依赖关系打包，以便应用程序从一个计算环境可靠快速地运行到另一个计算环境。Docker 容器镜像是一个轻量的独立的可执行的软件包。包含程序运行的时候所需的一切：代码，运行时间，系统工具，系统库和设置。 资源：Docker 从入门到实践 https://vuepress.mirror.docker-practice.com/ Dockerfile 七、性能优化 路由懒加载 组件懒加载 JS 异步加载 Tree shaking 骨架屏 分页加载 长列表虚拟滚动 Web Worker 优化长任务 图片优化（动态裁剪、懒加载、图片压缩、使用字体图标、图片转 base64 格式） CDN 分发","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"普通数据转化为树形结构","slug":"普通数据转化为树形结构","date":"2022-03-01T08:41:11.000Z","updated":"2024-03-15T08:47:32.297Z","comments":true,"path":"2022/03/01/普通数据转化为树形结构/","link":"","permalink":"https://congtf.top/2022/03/01/%E6%99%AE%E9%80%9A%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/","excerpt":"","text":"有时候我们需要用到树形结构的数据便于我们展示像组织架构、地区这种有层级结构的信息。那么我们就需要将普通平铺的数据转化为树形结构的数据。主要是使用递归算法。 观察这种数据不难发现，每条数据一般至少包含 id 和 pid 两个属性，id 是每条数据独一无二的身份标识，pid 则表示与其他数据的从属关系。如果当前数据的 pid 等于另外一条数据的 id，那当前数据就是另外一条数据的子数据。 封装一个工具方法，**src/utils/index.js** 1234567891011121314151617181920/** * * * 将列表型的数据转化成树形数据 =&gt; 递归算法 =&gt; 自身调用自身 =&gt; 递归的关键在于要有一个入口和一个出口，入口 * 表示递归开始，出口则标识递归的结束。没有出口会造成死循环 * 遍历树形 有一个重点 要先找一个头儿 * ***/export function tranListToTreeData(list, rootValue) &#123; var arr = []; list.forEach((item) =&gt; &#123; if (item.pid === rootValue) &#123; // 找到之后 就要去找 item 下面有没有子节点 const children = tranListToTreeData(list, item.id); if (children.length) &#123; // 如果children的长度大于0 说明找到了子节点 item.children = children; &#125; arr.push(item); // 将内容加入到数组中 &#125; &#125;); return arr;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]}]}