{"meta":{"title":"hasCat","subtitle":"","description":"记录前端知识学习，经验积累，记录生活","author":"congtianfeng","url":"https://congtf.top","root":"/"},"pages":[{"title":"categories","date":"2023-03-25T07:06:38.732Z","updated":"2021-09-06T03:42:32.000Z","comments":true,"path":"categories/index.html","permalink":"https://congtf.top/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-03-27T08:21:32.101Z","updated":"2023-03-27T08:21:32.101Z","comments":true,"path":"about/index.html","permalink":"https://congtf.top/about/index.html","excerpt":"","text":"前端技术小白一枚，想要在此记录学习的过程。想要一起学习的小伙伴可以加 QQ：1311783259"},{"title":"friends","date":"2023-03-25T07:06:38.732Z","updated":"2021-09-06T03:42:32.000Z","comments":true,"path":"friends/index.html","permalink":"https://congtf.top/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-25T07:06:38.748Z","updated":"2021-09-06T03:42:32.000Z","comments":true,"path":"tags/index.html","permalink":"https://congtf.top/tags/index.html","excerpt":"","text":""},{"title":"影音播放","date":"2023-03-25T07:06:38.740Z","updated":"2021-09-06T03:42:32.000Z","comments":true,"path":"player/index.html","permalink":"https://congtf.top/player/index.html","excerpt":"","text":"aplayer演示： dplayer演示：(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"video\":{\"url\":\"https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/mp4/mp4_demo.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() bilibili： acfun："}],"posts":[{"title":"ES6补充","slug":"ES6补充","date":"2023-05-11T07:48:05.000Z","updated":"2023-05-12T01:42:02.040Z","comments":true,"path":"2023/05/11/ES6补充/","link":"","permalink":"https://congtf.top/2023/05/11/ES6%E8%A1%A5%E5%85%85/","excerpt":"","text":"更多请参考 阮一峰老师 ES6 入门教程https://es6.ruanyifeng.com/ MDN 官方文档https://developer.mozilla.org/zh-CN/ 一、作用域1、作用域链作用域链本质上是底层的变量查找机制。在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域。这种嵌套关系的作用域串联起来就形成了作用域链 2、JS 垃圾回收机制垃圾回收机制(Garbage Collection) 简称 GC JS 中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收 虽然垃圾回收器会帮我们自动回收内存，但我们仍有必要了解 JS 的内存管理机制。它可以帮助我们理解内存泄漏（内存无法被回收） 不再用到的内存，没有及时释放，就叫做内存泄漏 内存的生命周期 JS 环境中分配的内存, 一般有如下生命周期： 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 说明： 全局变量一般不会回收(关闭页面回收)； 一般情况下局部变量的值, 不用了, 会被自动回收掉 两种常见的浏览器垃圾回收算法 引用计数法 IE 采用的引用计数算法, 定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象 具体步骤： 跟踪记录被引用的次数 如果被引用了一次，那么就记录次数 1,多次引用会累加 如果减少一个引用就减 1 当引用次数是 0 时 ，则释放内存 它存在一个致命的问题：嵌套引用（循环引用） 如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。 12345678function fn() &#123; let o1 = &#123;&#125;; let o2 = &#123;&#125;; o1.a = o2; o2.a = o1; return &quot;引用计数无法回收&quot;;&#125;fn(); 正常情况下，上述代码中的变量 o1、o2 在函数 fn 执行完毕之后就应该被回收掉，但是根据引用计数法，虽然函数 fn 已经执行完成，但是由于 o1、o2 中存在着相互引用的关系，因此实际上并不会被回收，这就造成了内存泄漏。于是就有了标记清除法 标记清除法 现代的浏览器已经不再使用引用计数算法了 现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。 核心： 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 就是从根部（在 JS 中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 同样上述的代码，如果用标记清除法，在函数 fn 执行完毕之后，函数作用域里面的变量，从全局对象开始已经访问不到了，因此会被回收掉 3、闭包MDN 官方解释：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域 从代码结构上看，闭包 &#x3D; 内层函数 + 外层函数的变量。 12345678function outer() &#123; const a = 100; function inner() &#123; console.log(a); &#125; inner();&#125;outer(); 闭包作用：封闭数据，提供操作，外部也可以访问函数内部的变量 闭包的基本形式 12345678function outer() &#123; const a = 100; return function inner() &#123; console.log(a); &#125;;&#125;const fun = outer();fun(); 闭包应用：实现数据的私有 比如，我们要做个统计函数调用次数，函数调用一次，就++ 1234567let i = 1;function count() &#123; i++; console.log(`函数被调用了$&#123;i&#125;次`);&#125;count(); // 2count(); // 3 但是这样定义的全局变量 i 很容易被修改，一旦修改，统计的函数调用次数就不准确了。可以通过闭包解决这个问题 12345678910function count() &#123; let i = 1; return function fn() &#123; i++; console.log(`函数被调用了$&#123;i&#125;次`); &#125;;&#125;const fun = count();fun(); // 2fun(); // 3 这样实现了数据私有，无法直接修改 count 二、深入对象创建对象的三种方式 利用对象字面量创建对象 利用 new Object 创建对象 利用构造函数创建对象 1、构造函数构造函数 ：是一种特殊的函数，主要用来初始化对象 使用场景：常规的 {…} 语法允许创建一个对象。比如我们创建了佩奇的对象，继续创建乔治的对象还需要重新写一 遍。此时可以通过构造函数，它就像一个模子一样，能帮助我们快速创建多个类似的对象。 1234567891011121314151617181920const xiaoming = &#123; name: &#x27;小明&#x27;, age: 18, gender: &#x27;男&#x27;&#125;const xiaohong = &#123; name: &#x27;小红&#x27;, age: 17, gender: &#x27;女&#x27;&#125;// 这种类似的结构，我们可以通过构造函数来创建// 声明一个&quot;人类&quot;的构造函数function Person(name,age,gender) &#123; this.name = name this.age = age this.gender = gender&#125;// 通过实例化来批量生产“人类”const xiaoming = new Person(&#x27;小明&#x27;，18，&#x27;男&#x27;)const xiaohong = new Person(&#x27;小红&#x27;，18，&#x27;女&#x27;) 构造函数本质上也函数，不过一般情况下： 它们的命名以大写字母开头，以表明这是一个构造函数 它们只能由 “new” 操作符来执行 new Object()、new Date()这些都是内置的构造函数 构造函数的实例化执行过程 创建新对象 2.构造函数 this 指向新对象 3.执行构造函数代码，修改 this，添加新的属性 4.返回新对象 实例成员&amp;静态成员 实例成员：通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。 1234567891011function Person(name, age, gender) &#123; // 构造函数中直接声明的这些方法和属性就是实例成员 this.name = name; this.age = age; this.gender = gender;&#125;// 直接为构造函数添加的这些方法和属性就是静态成员Person.eyes = 2;Person.say = function () &#123; console.log(&quot;会说话&quot;);&#125;; 请注意： 构造函数创建的实例对象彼此独立互不影响 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 2、内置构造函数引用类型：Object，Array，RegExp，Date 等 包装类型：String，Number，Boolean 等 数组常见实例方法-核心方法 reduce 语法 求和 12const arr = [1, 2, 3, 4, 5];const result = arr.reduce((prev, current) =&gt; prev + current); 数组常见实例方法-其他方法 实例方法 join 数组元素拼接为字符串，返回字符串(重点) 实例方法 find 查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点) 实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点) 实例方法some 检测数组中的元素是否满足指定条件 如果数组中有元素满足条件返回 true，否则返回 false 实例方法 concat 合并两个数组，返回生成新数组 实例方法 sort 对原数组单元值排序 实例方法 splice 删除或替换原数组单元 实例方法slice返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括 end）（此截取方法字符串也有） 实例方法 reverse 反转数组 实例方法 findIndex 返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回 -1 实例方法includes用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false 实例方法push添加元素到数组末尾 实例方法pop（弹出）删除数组末尾的元素 实例方法shift删除数组头部元素 实例方法unshift添加元素到数组的头部 实例方法indexOf返回数组中第一次出现给定元素的下标，如果不存在则返回 -1 实例方法fill用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引 数组常见静态方法 Array.from()：对一个伪数组或可迭代对象创建一个新的，浅拷贝的数组实例 Array.isArray()：用于确定传递的值是否是一个 Array String 常见实例方法 在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法。这是因为它们是 JavaScript 底层使用 Object 构造函数“包装”来的 String 常见实例方法 实例属性 length 用来获取字符串的度长(重点) 实例方法 split(&#39;分隔符&#39;) 用来将字符串拆分成数组(重点) 实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点) 实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点) 实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点) 实例方法 toUpperCase 用于将字母转换成大写 实例方法 toLowerCase 用于将就转换成小写 实例方法 indexOf 检测是否包含某字符 实例方法 endsWith 检测是否以某字符结尾 实例方法 replace 用于替换字符串，支持正则匹配 实例方法 match 用于查找字符串，支持正则匹配 实例方法trim从字符串的两端清除空格，返回一个新的字符串，而不修改原始字符串 实例方法slice 方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串 Number 常见方法 实例方法toFixed设置保留小数位的长度 静态方法 Number.parseInt() 方法依据指定基数，解析字符串并返回一个整数。 静态方法Number.parseFloat() 方法可以把一个字符串解析成浮点数 Date 常见方法 实例方法toLocaleString方法返回该日期对象的字符串 实例方法toLocaleDateString 方法返回指定日期对象日期部分的字符串 实例方法getDate根据本地时间，返回一个指定的 Date 对象为一个月中的哪一日（1-31） 实例方法getDay根据本地时间，返回一个指定的 Date 对象是在一周中的第几天（0-6），0 表示星期天 实例方法getFullYear根据本地时间，返回一个指定的 Date 对象的完整年份（四位数年份） 实例方法getHours根据本地时间，返回一个指定的 Date 对象的小时（0–23） 实例方法getMinutes根据本地时间，返回一个指定的 Date 对象的分钟数（0–59） 实例方法getMonth根据本地时间，返回一个指定的 Date 对象的月份（0–11），0 表示一年中的第一月 实例方法getSeconds根据本地时间，返回一个指定的 Date 对象的秒数（0–59） 实例方法getTime返回一个数值，表示从 1970 年 1 月 1 日 0 时 0 分 0 秒（UTC，即协调世界时）距离该 Date 对象所代表时间的毫秒数（时间戳） 静态方法Date.now()返回自 1970-1-1 00:00:00 UTC（世界标准时间）至今所经过的毫秒数(时间戳) Math 常见方法 静态方法Math.floor(x)返回小于一个数的最大整数，即一个数向下取整后的值 静态方法Math.ceil(x)返回大于一个数的最大整数，即一个数向上取整后的值 静态方法Math.max(x,y,...)返回零到多个数值中最大值 静态方法Math.min(x,y,...)返回零到多个数值中最小值 静态方法Math.pow(x,y)返回一个数的 y 次幂 静态方法Math.random()返回一个 0 到 1 之间的伪随机数 静态方法Math.round(x)返回四舍五入后的整数 三、面向对象1、面向对象的编程思想面向过程编程 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程 缺点：没有面向对象易维护、易复用、易扩展 面向对象编程 (oop) 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。 面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目 面向对象的特性： 封装性 继承性 多态性 优点：易维护、易复用、易扩展，由于面向对象有封装 、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点：性能比面向过程低 2、封装JavaScript 中可以通过构造函数实现面向对象的封装 将相同的结构封装在构造函数中，通过 this 指向实现数据的共享。并且通过构造函数创造出来的实例对象之间彼此独立、互不影响 1234567891011function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; this.sing = function () &#123; console.log(&quot;说话&quot;); &#125;;&#125;const ldh = new Person(&quot;刘德华&quot;, 18, &quot;男&quot;);const zxy = new Person(&quot;张学友&quot;, 20, &quot;男&quot;);console.log(ldh.sing === zxy.sing); // false 然而，由于构造函数创造出来的实例对象之间彼此独立、互不影响。我们会发现ldh.sing和zxy.sing并不相等，这不是我们想要的，因为实际上每个实例对象（比如ldh和zxy）之间的sing方法应该是相同的，他们实现的是相同的功能，因此没必要单独给它们各自分配内存。 原型 使用原型对象就可以实现方法的共享 构造函数通过原型分配的函数是所有实例对象所共享的 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象 这个对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法 构造函数和原型对象中的 this 都指向实例化的对象 1234567891011function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Person.prototype.sing = function () &#123; console.log(&quot;说话&quot;);&#125;;const ldh = new Person(&quot;刘德华&quot;, 18, &quot;男&quot;);const zxy = new Person(&quot;张学友&quot;, 20, &quot;男&quot;);console.log(ldh.sing === zxy.sing); // true constructor 属性 每个原型对象里面都有个 constructor 属性（constructor 构造函数） 该属性指向该原型对象的构造函数 使用场景： 如果有多个对象的方法，我们可以给原型对象采取对象形式赋值. 但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了 。也就是说正常情况下，原型对象上是存在着 constructor 属性的，现在我们想往原型对象上挂载多个方法，我们不想一个一个的添加，于是我们采用直接赋值的方式。但是我们通过赋值的形式往原型对象上挂载方法后，把原来的原型对象上的 constructor 属性覆盖掉了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 1234567891011121314151617181920212223242526272829303132333435function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;// 多个方法挂载到原型对象上，为了方便不想一个一个的挂载Person.prototype.sing = function () &#123; console.log(&quot;说话&quot;);&#125;;Person.prototype.dance = function () &#123; console.log(&quot;跳舞&quot;);&#125;;// 于是直接给prototype属性赋值Person.prototype = &#123; sing: function () &#123; console.log(&quot;说话&quot;); &#125;, dance: function () &#123; console.log(&quot;跳舞&quot;); &#125;,&#125;;// 但是这样，原本原型对象prototype上的constructor 属性就被赋值给覆盖掉了Person.prototype = &#123; // 因此利用constructor，手动指回Person构造函数 constructor: Person, sing: function () &#123; console.log(&quot;说话&quot;); &#125;, dance: function () &#123; console.log(&quot;跳舞&quot;); &#125;,&#125;;const ldh = new Person(&quot;刘德华&quot;, 18, &quot;男&quot;);const zxy = new Person(&quot;张学友&quot;, 20, &quot;男&quot;);console.log(ldh.sing === zxy.sing); // true 但是当我们把原本放在构造函数上的一些公共属性或方法放到原型对象上后，实例对象如何访问到原型对象上的公共属性或方法呢？ proto 对象都会有一个属性 proto 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 proto 原型的存在 3、原型继承继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性 123456789101112// 定义一个中国人的构造函数function Chinese() &#123; this.header = 1; this.eyes = 2; this.language = &quot;chinese&quot;;&#125;// 定义一个日本人的构造函数function Japanese() &#123; this.header = 1; this.eyes = 2; this.language = &quot;japanese&quot;;&#125; 我们发现，不管是中国人还是日本人，他们都属于人类。因此可以将人类的一些公共特征抽取出来，单独封装成一个人类的构造函数，让中国人和日本人共享这个构造函数的属性和方法 1234567891011121314151617181920// 封装一个人类的构造函数function Human() &#123; this.header = 1; this.eyes = 2;&#125;// 中国人的构造函数function Chinese() &#123; this.language = &quot;chinese&quot;;&#125;// 日本人的构造函数function Japanese() &#123; this.language = &quot;japanese&quot;;&#125;// 通过改变中国人和日本人的原型对象指向到Human，以此继承Human上的方法和属性Chinese.prototype = Human;// 不要忘了constructor 指回ChineseChinese.prototype.constructor = Chinese;// 同理日本人Japanese.prototype = Human;Japanese.prototype.constructor = Japanese; 但是此时会有一个问题，当我们向单独给 Chinese 添加一个属性或者方法时，我们会发现 Japanese 也被自动添加了这个属性或方法。并且由于Japanese.prototype.constructor是后来定义的，它将Chinese.prototype.constructor = Chinese覆盖掉了，因此Chinese.prototype.constructor竟然也指向了Japanese！ 1234567891011121314151617181920212223242526// 封装一个人类的构造函数function Human() &#123; this.header = 1; this.eyes = 2;&#125;// 中国人的构造函数function Chinese() &#123; this.language = &quot;chinese&quot;;&#125;// 日本人的构造函数function Japanese() &#123; this.language = &quot;japanese&quot;;&#125;// 通过改变中国人和日本人的原型对象指向到Human，以此继承Human上的方法和属性Chinese.prototype = Human;// 不要忘了constructor 指回ChineseChinese.prototype.constructor = Chinese;// 同理日本人Japanese.prototype = Human;Japanese.prototype.constructor = Japanese;Chinese.prototype.smoking = function () &#123; console.log(&quot;抽烟&quot;);&#125;;const xiaoming = new Chinese();const guitian = new Japanese();console.log(xiaoming, guitian); 这是因为Chinese.prototype和Japanese.prototype都是一个指向了构造函数Human的地址，通过Chinese.prototype.smoking修改了Human的值，Japanese.prototype也会受到影响。因此我们可以将Chinese.prototype和Japanese.prototype各自指向一个 Human 的实例对象，这样它们就互不影响了！ 1234567891011121314151617181920212223242526// 封装一个人类的构造函数function Human() &#123; this.header = 1; this.eyes = 2;&#125;// 中国人的构造函数function Chinese() &#123; this.language = &quot;chinese&quot;;&#125;// 日本人的构造函数function Japanese() &#123; this.language = &quot;japanese&quot;;&#125;// 通过改变中国人和日本人的原型对象指向到Human，以此继承Human上的方法和属性Chinese.prototype = new Human();// 不要忘了constructor 指回ChineseChinese.prototype.constructor = Chinese;// 同理日本人Japanese.prototype = new Human();Japanese.prototype.constructor = Japanese;Chinese.prototype.smoking = function () &#123; console.log(&quot;抽烟&quot;);&#125;;const xiaoming = new Chinese();const guitian = new Japanese();console.log(xiaoming, guitian); 原型链 基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对 象的链状结构关系称为原型链 原型链-查找规则 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型（也就是 proto指向的 prototype 原型对象） 如果还没有就查找原型对象的原型（Object 的原型对象） 依此类推一直找到 Object 为止（null） proto对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线 可以使用 instanceof 运算符检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 4、深浅拷贝开发中我们经常需要复制一个引用类型。如果直接赋值，当我们修改一个值时，另一个值也变了 浅拷贝和深拷贝只针对引用类型 浅拷贝常见方法： 拷贝对象：Object.assgin() &#x2F; 展开运算符 拷贝数组：Array.prototype.concat() 或者展开运算符 但是如果引用数据类型里面出现了嵌套引用数据类型的情况，深拷贝就又会出现上述问题，这时需要深拷贝 深拷贝常见方法： 通过递归实现深拷贝 lodash 库 cloneDeep 函数 通过 JSON.stringify()实现 递归 如果一个函数在内部调用其本身，那么这个函数就是递归函数 由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return 利用递归函数实现 setTimeout 模拟 setInterval 效果 12345function getTime() &#123; console.log(new Date().toLocaleString()); setTimeout(getTime, 1000);&#125;getTime(); 利用递归函数实现基本的深拷贝 1234567891011121314151617function deepCopy(newData, oldData) &#123; // 遍历原对象 for (let k in oldData) &#123; // 如果是数组 if (oldData[k] instanceof Array) &#123; newData[k] = []; deepCopy(newData[k], oldData[k]); &#125; else if (oldData[k] instanceof Object) &#123; // 如果是对象 newData[k] = &#123;&#125;; deepCopy(newData[k], oldData[k]); &#125; else &#123; // 基本数据类型直接赋值 newData[k] = oldData[k]; &#125; &#125;&#125; 通过 JSON.stringify()实现深拷贝 1234567891011const obj = &#123; name: &quot;佩奇&quot;, age: 18, hobby: [&quot;抽烟&quot;, &quot;喝酒&quot;, &quot;烫头&quot;], family: &#123; sister: &quot;乔治&quot;, father: &quot;猪爸爸&quot;, mother: &quot;猪妈妈&quot;, &#125;,&#125;;const obj2 = JSON.parse(JSON.stringify(obj)); JSON.stringify()可以将 JS 对象转化为 JSON 字符串，JSON 字符串就是一个字符串，就不存在所谓的地址引用了 5、异常处理throw 抛异常 异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行 1234567891011function counter(x, y) &#123; if (!x || !y) &#123; // throw &#x27;参数不能为空！&#x27; throw new Error(&quot;参数不能为空！&quot;); console.log(111); &#125; console.log(222); return x + y;&#125;counter();console.log(333); throw 抛出异常信息，整个程序也会终止执行 throw 后面跟的是错误提示信息,可以直接跟字符串 Error 对象配合 throw 使用，能够设置更详细的错误信息 try &#x2F;catch 捕获异常 可以通过 try &#x2F; catch 捕获错误信息（浏览器提供的错误信息） 12345678910111213function fn() &#123; try &#123; const p = document.querySelector(&quot;.p&quot;); p.style.color = &quot;red&quot;; &#125; catch (error) &#123; console.log(error.message); &#125; finally &#123; console.log(&quot;finally执行了！&quot;); &#125; console.log(&quot;我是函数fn中的最后打印&quot;);&#125;fn();console.log(&quot;我是函数fn外的打印&quot;); 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 finally 不管是否有错误，都会执行 使用 try &#x2F; catch 捕获错误信息，发生异常后程序不会终止执行 debugger 可以在代码中用 debugger 打断点调试程序，它和我们在控制台打断点的效果是一样的 6、thisthis 指向 普通函数中的 this：指向 window 构造函数、原型对象中的 this：指向实例化对象 对象中的方法中的 this：指向该对象 定时器、延时器中的 this：指向 window 事件处理函数中的 this：指向事件源 箭头函数中的 this：实际上箭头函数中并不存在 this，箭头函数中的 this 指向上层作用域的 this，如果上层作用域也没有 this，则一级一级向上查找 简单来说，this 总是指向调用者。我们所说的 this 指向是按作用域划分的 改变 this 指向 JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向 call() 语法： thisArg：在 fun 函数运行时指定的 this 值 arg1，arg2：函数 fun 正常的参数 返回值就是函数的返回值，因为它就是调用函数（当一个函数调用了 call 方法时，这个函数也被调用执行了） apply() 语法： thisArg：在 fun 函数运行时指定的 this 值 argsArray：函数 fun 正常的参数，但是在 apply 中必须包含在数组里面 因为 apply 的参数主要跟数组有关系，因此在涉及到数组处理时，应该想到 apply 比如使用 Math.max() 求数组的最大值 返回值就是函数的返回值，因为它就是调用函数当一个函数调用了 apply 方法时，这个函数也被调用执行了） 1234// 求数组最大值const arr = [1, 3, 5, 7, 9];// console.log(Math.max(...arr))console.log(Math.max.apply(null, arr)); bind() 语法： thisArg：在 fun 函数运行时指定的 this 值 arg1，arg2：函数 fun 具体的参数 返回由指定的 this 值和初始化参数改造的原函数拷贝 （新函数），并不调用原函数 因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind，比如改变定时器内部的 this 指向","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"AJAX","slug":"AJAX","date":"2023-05-04T06:14:49.000Z","updated":"2023-05-12T01:41:08.891Z","comments":true,"path":"2023/05/04/AJAX/","link":"","permalink":"https://congtf.top/2023/05/04/AJAX/","excerpt":"","text":"一、Ajax 基本介绍Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML） 通过 AJAX 可以在浏览器中向服务器发送异步请求，进行数据交互 最大的优势：无刷新获取数据 AJAX 的优点 可以无需刷新页面而与服务器端进行通信（实现局部刷新） 允许根据用户事件来更新部分页面内容 AJAX 的缺点 没有浏览历史，不能回退 存在跨域问题(同源) SEO 不友好 Ajax 的典型应用场景 用户名检测：注册用户时，通过 ajax 的形式，动态检测用户名是否被占用 搜索提示：当输入搜索关键字时，通过 ajax 的形式，动态加载搜索提示列 表 数据分页显示：当点击页码值的时候，通过 ajax 的形式，根据页码值动态 刷新表格的数据 数据的增删改查：数据的添加、删除、修改、查询操作，都需要通过 ajax 的 形式，来实现数据的交互 1、XMLXML 是一种可扩展标记语，被设计用来传输和存储数据。XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。 XML 格式臃肿，和数据无关的代码多，体积大，传输效率低。在 Javascript 中解析 XML 比较麻烦。现已被 JSON 代替 2、JSONJSON 的英文全称是 JavaScript Object Notation，即“JavaScript 对象。表示法”。简单来讲，JSON 就是 Javascript 对象和数组的字符串表示法，它使用文本表示一个 JS 对象或数组的信息，因此，JSON 的本质是字符 作用：JSON 是一种轻量级的文本数据交换格式，在作用上类似于 XML，专 门用于存储和传输数据，但是 JSON 比 XML 更小、更快、更易解析 现状：JSON 是在 2001 年开始被推广和使用的数据格式，到现今为止，JSON 已经成为了主流的数据交换格式 JSON 的两种结构 JSON 就是用字符串来表示 Javascript 的对象和数组。所以，JSON 中包含 对象和数组两种结构，通过这两种结构的相互嵌套，可以表示各种复杂的数据结构 对象结构：对象结构在 JSON 中表示为 { } 括起来的内容。数据结构为 { key: value, key: value, … } 的键值对结构。其中，key 必须是使用英文 的双引号包裹的字符串，value 的数据类型可以是数字、字符串、布尔值、null、 数组、对象 6 种类型 数组结构：数组结构在 JSON 中表示为 [ ] 括起来的内容。数据结构为 [ “java”, “javascript”, 30, true … ] 。数组中数据的类型同样可以是数字、 字符串、布尔值、null、数组、对象 6 种类型 JSON 语法注意事项 属性名必须使用双引号包裹 字符串类型的值必须使用双引号包裹 JSON 中不允许使用单引号表示字符串 JSON 中不能写注释 JSON 的最外层必须是对象或数组格式 不能使用 undefined 或函数作为 JSON 的值 JSON 和 JS 对象的关系 JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息， 本质是一个字符串 JSON 和 JS 对象的互转 可以使用 JSON.parse()和 JSON.stringify()方法 二、AJAX 的使用核心对象 XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的 使用步骤 创建 XMLHttpRequest 对象 1const xhr = new XMLHttpRequest(); 2.设置请求信息 123xhr.open(method, url);//可以设置请求头，一般不设置xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); 发送请求 1xhr.send(body); //get 请求不传 body 参数，只有 post 请求 4.接收响应 12345678//xhr.responseXML 接收 xml 格式的响应数据//xhr.responseText 接收文本格式的响应数据xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; const text = xhr.responseText; console.log(text); &#125;&#125;; xhr.readyState 可以用来查看请求当前的状态 0: 表示 XMLHttpRequest 实例已经生成，但是 open()方法还没有被调用。 1: 表示 send()方法还没有被调用，仍然可以使用 setRequestHeader()，设定 HTTP 请求的头信息 2: 表示 send()方法已经执行，并且头信息和状态码已经收到。 3: 表示正在接收服务器传来的 body 4: 表示服务器数据已经完全接收，或者本次接收已经失败了 使用 xhr 对象发起带参数的 GET 请求时，只需在调用 xhr.open 期间，为 URL 地址指定参数即可： 1xhr.open(&#x27;GET&#x27;,&#x27;http://congtf.top/tags?id=1&amp;title=技术&#x27;) 这种在 URL 地址后面拼接的参数，叫做查询字符串 GET 请求携带参数的本质 无论使用 $.ajax()，还是使用 $.get()，又或者直接使用 xhr 对象发起 GET 请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形 式，追加到 URL 地址的后面，发送到服务器的 123$.get(url, &#123; name: &quot;zs&quot;, age: 20 &#125;, function () &#123;&#125;);// 等价于$.get(url + &quot;?name=zs&amp;age=20&quot;, function () &#123;&#125;); 三、XMLHttpRequest Level2 的新特性旧版 XMLHttpRequest 的缺点： 只支持文本数据的传输，无法用来读取和上传文件 传送和接收数据时，没有进度信息，只能提示有没有完成 XMLHttpRequest Level2 的新功能 可以设置 HTTP 请求的时限 可以使用 FormData 可以上传文件 可以获得数据传输的进度信息 1、设置 HTTP 请求时限有时，Ajax 操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的 XMLHttpRequest 对象，增加了 timeout 属性，可 以设置 HTTP 请求的时限： 1xhr.timeout = 3000; 上面的语句，将最长等待时间设为 3000 毫秒。过了这个时限，就自动停止 HTTP 请求。与之配套的还有一个 timeout 事件，用来指定回调函数： 123xhr.ontimeout = function () &#123; alert(&quot;请求超时&quot;);&#125;; 2、FormData 对象管理表单数据Ajax 操作往往用来提交表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单操作： 1234567891011// 1.新建FormData对象const fd = new FormData();// 2.为FormData添加表单项fd.append(&quot;uname&quot;, &quot;zs&quot;);fd.append(&quot;upwd&quot;, &quot;123456&quot;);// 3.创建XHR对象const xhr = new XMLHttpRequest();// 4.发请求xhr.open(&quot;POST&quot;, &quot;http://congtf.top&quot;);// 5.直接提交FormData对象，这与提交网页表单效果完全一样xhr.send(fd); FormData 对象也可以用来获取网页表单的值，示例代码如下： 123456789101112// 获取表单元素const form = document.querySelector(&quot;#form1&quot;);// 监听表单元素的submit事件form.addEventListener(&quot;submit&quot;, function (e) &#123; e.preventDefault(); // 根据form表单创建FormData对象，会自动将表单数据填充到FormData对象中 const fd = new FormData(form); const xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;, &quot;http://congtf.top&quot;); xhr.send(fd); xhr.onreadystatechange = function () &#123;&#125;;&#125;); 3、上传文件新版 XMLHttpRequest 对象，不仅可以发送文本信息，还可以上传文件 实现步骤 定义 UI 结构 1234567&lt;!-- 文件选择框 --&gt;&lt;input type=&quot;file&quot; id=&quot;file1&quot; /&gt;&lt;!-- 上传按钮 --&gt;&lt;button id=&quot;btnUpload&quot;&gt;上传文件&lt;/button&gt;&lt;br /&gt;&lt;!-- 显示上传到服务器上的图片 --&gt;&lt;img src=&quot;&quot; id=&quot;img&quot; width=&quot;800&quot; /&gt; 验证是否选择了文件 12345678910111213141516171819202122232425262728const btnUpload = document.querySelector(&quot;#btnUpload&quot;);btn.addEventListener(&quot;click&quot;, function () &#123; const files = document.querySelector(&quot;#file1&quot;); if (files.length &lt;= 0) &#123; return alert(&quot;请选择要上传的文件！&quot;); &#125; // 创建FormData对象 const fd = new FormData(); // 追加文件 fd.append(&quot;avatar&quot;, files[0]); // 创建xhr对象 const xhr = new XMLHttpRequest(); // 发请求 xhr.open(&quot;POST&quot;, &quot;http://congtf.top&quot;); xhr.send(fd); xhr.onreadystatechange = function () &#123; if (xhr.state === 4 &amp;&amp; xhr.status === 200) &#123; const data = JSON.parse(xhr.responseText); if (data.status === 200) &#123; // 将服务器返回的图片地址设置为img标签的src属性 document.querySelector(&quot;#img&quot;).src = &quot;http://congtf.top&quot; + data.url; &#125; else &#123; // 文件上传失败 console.log(&quot;data.message&quot;); &#125; &#125; &#125;;&#125;); 向 FormData 中追加文件 使用 xhr 发起上传文件的请求 监听 onreadystatechange 事件 4、显示文件上传进度新版本的 XMLHttpRequest 对象中，可以通过监听 xhr.upload.onprogress 事件，来获取到文件的上传进度。语法格式如下： 12345678910const xhr = new XMLHttpRequest();// 监听xhr.upload的onprogress事件xhr.upload.onprogress = function (e) &#123; // e.lengthComputable是一个布尔值，表示当前上传的资源是否具有可计算的长度 if (e.lengthComputable) &#123; // e.loaded 表示已传输的字节 // e.total 表示需要传输的总字节 const percentComplete = Math.ceil((e.loaded / e.total) * 100); &#125;&#125;; 四、axiosaxios 是专注于网络数据请求的库 相比于原生的 XMLHttpRequest 对象，axios 简单易用 相比于 jQuery，axios 更加轻量化，只专注于网络数据请求 axios 发起 GET 请求 1234567axios .get(url, &#123; params: &#123; /*参数*/ &#125;, &#125;) .then(callback); 示例如下： 12345const paramsObj = &#123; name: &quot;zs&quot;, age: 20 &#125;;axios.get(&quot;http:congtf.top&quot;, &#123; params: paramsObj &#125;).then(function (res) &#123; // axios默认包了一层data，res.data才是服务器返回的数据 const result = res.data;&#125;); axios 发起 POST 请求示例如下： 12345const dataObj = &#123; name: &quot;zs&quot;, age: 20 &#125;;axios.post(&quot;http:congtf.top&quot;, dataObj).then(function (res) &#123; // axios默认包了一层data，res.data才是服务器返回的数据 const result = res.data;&#125;); 直接使用 axios 发起请求: 12345678910axios(&#123; method: &quot;请求类型&quot;, url: &quot;请求的url地址&quot;, data: &#123; /*POST数据*/ &#125;, params: &#123; /*GET参数*/ &#125;,&#125;).then(callback); 五、同源与跨域、防抖与节流1、同源策略如果两个页面的协议，域名和端口都相同，则两个页面具有相同的源 例如，下表给出了相对于 http://www.test.com/index.html （没写端口号默认 是 80）页面的同源检测 同源策略（英文全称 Same origin policy）是浏览器提供的一个安全功能 MDN 官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自 另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制 通俗的理解：浏览器规定，A 网站的 JavaScript 不允许和非同源的网站 C 之间进行资源的交互，例如： 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB 无法接触非同源网页的 DOM 无法向非同源地址发送 Ajax 请求 同源指的是两个 URL 的协议、域名、端口一致，反之，则是跨域 出现跨域的根本原因：浏览器的同源策略不允许非同源的 URL 之间进行资源的交互 浏览器对跨域请求的拦截 注意：浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器 拦截，无法被页面获取到！ 如何实现跨域数据请求 2、JSONP出现的早，兼容性好（兼容低版本 IE）。是前端程序员为了解决跨域问题， 被迫想出来的一种临时解决方案。缺点是只支持 GET 请求，不支持 POST 请求。 JSONP (JSON with Padding) 是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。 JSONP 的实现原理 由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。 但是在网页中有一些标签天生具有跨域能力，比如：img link iframe script。因此，JSONP 的实现原理，就是通过 script 标签的 src 属性，请求跨域的数据接口，并通过函数调用的形式，接收跨域接口响应回来的数据。 JSONP 的使用 12345678910111213141516171819// 动态的创建一个script标签const script document.createElement(&#x27;script&#x27;)// 设置script的src，设置回调函数script.src=&#x27;http://loacalhost:3000/testAJAX?callback=abc&#x27;function abc(data) &#123; alert(data.name)&#125;// 将script添加到body中document.body.appendChild(script)// 服务器中路由的处理router.get(&#x27;/testAJAX&#x27;,function(req,res) &#123; console.log(&#x27;收到请求&#x27;) const callback = req.query.callback const obj = &#123; name:&#x27;zs&#x27;, age:20 &#125; res.send(callback+&quot;(&quot;+JSON.stringfy(obj)+&quot;)&quot;)&#125;) 3、CORSCORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源 CORS 怎么工作的？ CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行 CORS 的使用 主要是服务器端的设置： 12345router.get(&quot;/testAJAX&quot;, function (req, res) &#123; // res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;) res.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.send(&quot;返回的相应&quot;);&#125;); 4、防抖防抖策略（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果 在这 n 秒内事件又被触发，则重新计时 防抖的应用场景 用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后， 才执行查询的请求，这样可以有效减少请求次数，节约请求资源 防抖的基本原理是在一定时间内，将多次触发的函数调用合并为一次调用执行。当用户连续触发事件时，防抖函数会清空之前设定的定时器，并重新设定一个新的定时器来延迟函数的执行。只有当用户停止操作后，在设定的时间内没有再次触发事件，则函数才会被真正地执行一次 实现一个基本的防抖函数步骤如下： 在函数外部设置一个计时器变量（例如 timeoutId）和函数执行的延迟时间（例如 delay） 当函数被触发时，清除之前设定的计时器 重新设定一个计时器，并用它来延迟函数的执行 如果在设定的延迟时间内再次触发了函数，则回到步骤 2 如果在设定的延迟时间内没有再次触发函数，计时器会触发执行原始函数 以下是一个基本的防抖函数 1234567891011function debounce(func, delay) &#123; let timeoutId; return function () &#123; const context = this; const args = arguments; clearTimeout(timeoutId); timeoutId = setTimeout(function () &#123; func.apply(context, args); &#125;, delay); &#125;;&#125; 该函数接受两个参数：要执行的函数以及防抖延迟时间。它返回一个新函数，该函数会在防抖延迟时间内被多次调用时只执行一次原始函数 5、节流节流策略（throttle），顾名思义，可以减少一段时间内事件的触发频率。 节流的应用场景 鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次 懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算 的频率，而不必去浪费 CPU 资源 节流阀的概念 高铁卫生间是否被占用，由红绿灯控制，红灯表示被占用，绿灯表示可使用 假设每个人上卫生间都需要花费 5 分钟，则五分钟之内，被占用的卫生间无法被 其他人使用 上一个人使用完毕后，需要将红灯重置为绿灯，表示下一个人可以使用卫生 间 下一个人在上卫生间之前，需要先判断控制灯是否为绿色，来知晓能否上卫 生间 类似的 节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作 当前操作执行完，必须将节流阀重置为空，表示可以执行下次操作了 每次执行操作前，必须先判断节流阀是否为空 一个基本的节流函数示例如下： 1234567891011function throttle(func, delay) &#123; let last = 0; return function (...args) &#123; const now = +new Date(); if (now - last &lt; delay) &#123; return; &#125; last = now; func.apply(this, args); &#125;;&#125; 总结防抖和节流的区别 防抖：如果事件被频繁触发，防抖能保证只有最有一次触发生效！前面 N 多 次的触发都会被忽略！当事件被触发时，函数在固定时间间隔内不被执行，只有事件停止触发后，函数才会执行一次。适用于处理一些不需要连续响应的事件（如输入框输入、按钮点击等），可以避免函数被频繁调用，提高性能和稳定性。 节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是 有选择性地执行一部分事件！当事件被触发时，函数在固定时间间隔内最多只执行一次。适用于高频率事件（如滚动、窗口调整等），可以防止函数被频繁调用，减少不必要的计算，提高性能和响应速度","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"Node.js","slug":"Node.js","date":"2023-04-20T03:23:37.000Z","updated":"2023-04-20T04:47:53.773Z","comments":true,"path":"2023/04/20/Node.js/","link":"","permalink":"https://congtf.top/2023/04/20/Node.js/","excerpt":"","text":"Node.js一、Node.js 基础1、Node.js 是什么Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，用于后端 开发。通俗来讲，Node.js 就是一款应用程序、一款软件，它可以运行 JavaScript 。 JavaScript 有两种运行环境：浏览器和 Node.js。在浏览器中 JavaScript 通过调用浏览器内置的 DOM、BOM 这样的 API 函数（接口）操作 DOM 和 BOM，并被浏览器的 JavaScript 解析引擎（例如 Chrome 的 V8 引擎）所解析运行。同样在 Node.js 中也是这样，只不过他们各自的内置 API 不同 2、Node.js 可以做什么 基于 Express 框架（http://www.expressjs.com.cn/），可以快速构建 Web 应用 基于 Electron 框架（https://electronjs.org/），可以构建跨平台的*桌面 应用* 基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目 _读写和操作数据库_、创建实用的命令行工具辅助前端开发、etc… 二、计算机基础知识1、计算机基本组成 计算机由硬件和软件两大部分组成。硬件主要有以下部分： CPU：中央处理器，计算机最核心的配件，负责所有的计算、逻辑处理 内存：用来存储数据。程序、运行的游戏、打开的浏览器都要加载到内存中才能运行，程序读取的数据、计算的结果也都在内存中，内存的大小决定了能加载的东西的多少。特点是读写速度较快，断电丢失数据 硬盘：用来存储数据。特点是读写数据较慢，断电不丢失数据 主板：存放在内存中数据需要被 CPU 读取，CPU 计算完成后，还要把数据写入到内存中，然而 CPU 不能直接插在内存上，这就需要主板出马了，主板上很多个插槽，CPU 和内存都是插在主板上，主板的芯片组和总线解决了 CPU 和内存之间的通讯问题，芯片组控制数据传输的流转，决定数据从哪里流向哪里，总线是实际数据传输的告诉公里，总线速度决定了数据的传输速度 显卡：显卡里有 GPU 图形处理器，主要负责图形渲染，它将处理完的信号传递给显示器，最终由显示器呈现画面。使用图形界面操作系统的计算机，显卡是必不可少的。现在的主板都带了内置的显卡，如果想玩游戏、做图形渲染，一般需要一张单独的显卡，插在主板上 计算机软件分为系统软件和应用软件两大类。系统软件是指各类操作系统，如 Windows、Linux、UNIX、MacOS 等。操作系统本质上也是一种应用程序，用来管理和调度硬件资源。比如操作系统可以决定 CPU 处理哪些程序，比如操作系统可以与硬盘交互，读写文件。可以还包括操作系统的补丁程序及硬件驱动程序都属于系统类软件。应用程序是指用户可以使用的各种程序设计语言，以及各种程序设计语言编制的应用程序的集合。 2、程序运行的基本流程当我们打开一个程序的时候，首先系统会将程序从硬盘中载入到内存中，再交由 CPU 处理。CPU 处理完之后如果遇到图形信号将其交由显卡做进一步处理，最终呈现图像。遇到声音信号交由声卡处理最终呈现声音。 3、进程与线程进程：可以理解为程序的一次执行过程。比如打开资源管理器，我们可以看到计算机正在执行的进程 线程：线程是一个进程中执行的一个执行流。一个线程一定是属于某个进程的。一个进程可以分成很多个线程。可以将进程理解为一个完整的大的项目，而线程是这个项目中的某一个功能模块 三、内置模块 Buffer（缓冲器）1、概念Buffer 是一个类似于数组的对象 ，用于表示固定长度的字节序列。 Buffer 本质是一段内存空间，专门用来处理 二进制数据 2、特点 Buffer 大小固定且无法调整 Buffer 性能较好，可以直接对计算机内存进行操作 每个元素的大小为 1 字节（byte） 3、使用Buffer.alloc 创建 Buffer Buffer.allocUnsafe 创建 Buffer Buffer.from 创建 Buffer toString 方法将 Buffer 转为字符串 toString 默认是按照 utf-8 编码方式进行转换的 四、内置模块 fs 文件系统fs 全称为 file system ，称为文件系统 ，是 Node.js 中的内置模块，可以对计算机中的磁盘进行操作 1、文件写入文件写入就是将数据保存到文件中，我们可以使用如下几个方法来实现该效果 writeFile 异步写入 语法： fs.writeFile(file, data[, options], callback) 参数说明： file 文件路径 data 待写入的数据 options 选项设置 （可选） callback 写入 err 回调 返回值： undefined 代码示例： 1234567891011// require 是 Node.js 环境中的&#x27;全局&#x27;变量，用来导入模块const fs = require(&quot;fs&quot;);//将 『三人行，必有我师焉。』 写入到当前文件夹下的『座右铭.txt』文件中fs.writeFile(&quot;./座右铭.txt&quot;, &quot;三人行，必有我师焉。&quot;, (err) =&gt; &#123; //如果写入失败，则回调函数调用时，会传入错误对象，如写入成功，会传入 null if (err) &#123; console.log(err); return; &#125; console.log(&quot;写入成功&quot;);&#125;); writeFileSync 同步写入 语法: fs.writeFileSync(file, data[, options]) 参数与 fs.writeFile 大体一致，只是没有 callback 参数 返回值： undefined 代码示例： 12345try &#123; fs.writeFileSync(&quot;./座右铭.txt&quot;, &quot;三人行，必有我师焉。&quot;);&#125; catch (e) &#123; console.log(e);&#125; 注意 writeFile 和 writeFileSync 会将文件中原有的内容覆盖掉，因此有了追加写入 appendFile &#x2F; appendFileSync 追加写入 appendFile 作用是在文件尾部追加内容，appendFile 语法与 writeFile 语法完全相同 代码示例： 12345fs.appendFile(&quot;./座右铭.txt&quot;, &quot;择其善者而从之，其不善者而改之。&quot;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;追加成功&quot;);&#125;);fs.appendFileSync(&quot;./座右铭.txt&quot;, &quot;\\r\\n温故而知新, 可以为师矣&quot;); createWriteStream 流式写入 语法： fs.createWriteStream(path[, options]) 返回值： Object 代码示例： 123456let ws = fs.createWriteStream(&quot;./观书有感.txt&quot;);ws.write(&quot;半亩方塘一鉴开\\r\\n&quot;);ws.write(&quot;天光云影共徘徊\\r\\n&quot;);ws.write(&quot;问渠那得清如许\\r\\n&quot;);ws.write(&quot;为有源头活水来\\r\\n&quot;);ws.end(); 程序打开一个文件是需要消耗资源的 ，流式写入可以减少打开关闭文件的次数。 流式写入方式适用于 大文件写入或者频繁写入 的场景, writeFile 适合于 写入频率较低的场景 写入文件的场景 文件写入 在计算机中是一个非常常见的操作，下面的场景都用到了文件写入 下载文件 安装软件 保存程序日志，如 Git 编辑器保存文件 视频录制 当 需要持久化保存数据 的时候，应该想到 文件写入 2、文件读取文件读取顾名思义，就是通过程序从文件中取出其中的数据，我们可以使用如下几种方式： readFile 异步读取 语法： fs.readFile(path[, options], callback) 返回值： undefined 代码示例： 12345678910//导入 fs 模块const fs = require(&quot;fs&quot;);fs.readFile(&quot;./座右铭.txt&quot;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;);fs.readFile(&quot;./座右铭.txt&quot;, &quot;utf-8&quot;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;); readFileSync 同步读取 语法： fs.readFileSync(path[, options]) 返回值： string | Buffer 代码示例： 12let data = fs.readFileSync(&quot;./座右铭.txt&quot;);let data2 = fs.readFileSync(&quot;./座右铭.txt&quot;, &quot;utf-8&quot;); createReadStream 流式读取 语法： fs.createReadStream(path[, options]) 返回值： Object 代码示例： 1234567891011//创建读取流对象let rs = fs.createReadStream(&quot;./观书有感.txt&quot;);//每次取出 64k 数据后执行一次 data 回调rs.on(&quot;data&quot;, (data) =&gt; &#123; console.log(data); console.log(data.length);&#125;);//读取完毕后, 执行 end 回调rs.on(&quot;end&quot;, () =&gt; &#123; console.log(&quot;读取完成&quot;);&#125;); 读取文件应用场景 电脑开机 程序运行 编辑器打开文件 查看图片 播放视频 播放音乐 Git 查看日志 上传文件 查看聊天记录 3、文件移动与重命名在 Node.js 中，我们可以使用 rename 或 renameSync 来移动或重命名文件或文件夹 语法：fs.rename(oldPath, newPath, callback) fs.renameSync(oldPath, newPath) 代码示例： 12345fs.rename(&quot;./观书有感.txt&quot;, &quot;./论语/观书有感.txt&quot;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;移动完成&quot;);&#125;);fs.renameSync(&quot;./座右铭.txt&quot;, &quot;./论语/我的座右铭.txt&quot;); 4、文件删除在 Node.js 中，我们可以使用 unlink 或 unlinkSync 来删除文件 语法： fs.unlink(path, callback) fs.unlinkSync(path) 代码示例： 123456const fs = require(&quot;fs&quot;);fs.unlink(&quot;./test.txt&quot;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;删除成功&quot;);&#125;);fs.unlinkSync(&quot;./test2.txt&quot;); 5、文件夹操作借助 Node.js 的能力，我们可以对文件夹进行 创建 、 读取 、 删除 等操作 mkdir 创建文件夹 在 Node.js 中，我们可以使用 mkdir 或 mkdirSync 来创建文件夹 语法：fs.mkdir(path[, options], callback) fs.mkdirSync(path[, options]) 示例代码： 123456789101112//异步创建文件夹fs.mkdir(&quot;./page&quot;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;创建成功&quot;);&#125;);//递归异步创建fs.mkdir(&quot;./1/2/3&quot;, &#123; recursive: true &#125;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;递归创建成功&quot;);&#125;);//递归同步创建文件夹fs.mkdirSync(&quot;./x/y/z&quot;, &#123; recursive: true &#125;); readdir 读取文件夹 在 Node.js 中，我们可以使用 readdir 或 readdirSync 来读取文件夹 语法：fs.readdir(path[, options], callback) fs.readdirSync(path[, options]) 示例代码： 12345678//异步读取fs.readdir(&quot;./论语&quot;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;);//同步读取let data = fs.readdirSync(&quot;./论语&quot;);console.log(data); rmdir 删除文件夹 在 Node.js 中，我们可以使用 rmdir 或 rmdirSync 来删除文件夹 语法： fs.rmdir(path[, options], callback) fs.rmdirSync(path[, options]) 示例代码： 1234567891011121314//异步删除文件夹fs.rmdir(&quot;./page&quot;, (err) =&gt; &#123; if (err) throw err; console.log(&quot;删除成功&quot;);&#125;);//异步递归删除文件夹fs.rmdir(&quot;./1&quot;, &#123; recursive: true &#125;, (err) =&gt; &#123; if (err) &#123; console.log(err); &#125; console.log(&quot;递归删除&quot;);&#125;);//同步递归删除文件夹fs.rmdirSync(&quot;./x&quot;, &#123; recursive: true &#125;); 6、路径问题fs 模块对资源进行操作时，路径的写法有两种： 相对路径 .&#x2F;座右铭.txt 当前目录下的座右铭.txt 座右铭.txt 等效于上面的写法 ..&#x2F;座右铭.txt 当前目录的上一级目录中的座右铭.txt 绝对路径 D:&#x2F;Program Files windows 系统下的绝对路径 &#x2F;usr&#x2F;bin Linux 系统下的绝对路径 相对路径中所谓的 当前目录 ，指的是 命令行的工作目录 ，而并非是文件的所在目录。所以当命令行的工作目录与文件所在目录不一致时，会出现一些 BUG。因此可以使用 dirname 与文件名拼接成绝对路径。dirname 与 require 类似，都是 Node.js 环境中的’全局’变量。**dirname 保存着 当前文件所在目录的绝对路径。使用 fs 模块的时候，尽量使用 **dirname 将路径转化为绝对路径，这样可以避免相对路径产生的 Bug 五、内置模块 pathpath 模块提供了操作路径的功能，几个较为常用的 API： 代码示例： 1234567891011121314const path = require(&quot;path&quot;);//获取路径分隔符console.log(path.sep);//拼接绝对路径console.log(path.resolve(__dirname, &quot;test&quot;));//解析路径let pathname = &quot;D:/program file/nodejs/node.exe&quot;;console.log(path.parse(pathname));//获取路径基础名称console.log(path.basename(pathname));//获取路径的目录名console.log(path.dirname(pathname));//获取路径的扩展名console.log(path.extname(pathname)); 六、http1、http 协议HTTP（hypertext transport protocol）协议，中文叫超文本传输协议。是一种基于 TCP&#x2F;IP 的应用层通信协议，它详细规定了 浏览器 和万维网 服务器 之间互相通信的规则 协议中主要规定了两个方面的内容 客户端：用来向服务器发送数据，可以被称之为请求报文 服务端：向客户端返回数据，可以被称之为响应报文 请求报文的组成 请求行 请求头 空行 请求体 HTTP 的请求行 请求方法（get、post、put、delete 等） 请求 URL（统一资源定位器） HTTP 协议版本号 HTTP 请求头 常见的请求头有： HTTP 的请求体 请求体内容的格式是非常灵活的， （可以是空）&#x3D;&#x3D;&gt; GET 请求， （也可以是字符串，还可以是 JSON）&#x3D;&#x3D;&#x3D;&gt; POST 请求 例如： 字符串：keywords&#x3D;手机&amp;price&#x3D;2000 JSON：{“keywords”:”手机”,”price”:2000} 响应报文的组成 响应行 HTTP&#x2F;1.1 200 OK HTTP&#x2F;1.1：HTTP 协议版本号 200：响应状态码 OK：响应状态描述 响应头 Cache-Control:缓存控制 private 私有的，只允许客户端缓存数据 Connection: 链接设置 Content-Type:text&#x2F;html;charset&#x3D;utf-8 设置响应体的数据类型以及字符集,响应体为 html，字符集 utf-8 Content-Length:响应体的长度，单位为字节 空行 响应体 响应体内容的类型是非常灵活的，常见的类型有 HTML、CSS、JS、图片、JSON 2、IP 地址IP 地址就是接入互联网的每台计算机的唯一地址，用来标识接入互联网的设备。通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用 点分十进表示的 IP 地址 （192.168.1.1） 共享 IP 为了更好的利用 IP 地址，节省资源。以家庭为例，手机、电脑、打印机、电视连接到同一路由器，路由器为他们分配各自的 IP，这就形成了一个局域网（私网），局域网中的设备之间可以互相通信。为了能够访问外部资源，还需接入到互联网才行。这样一个家庭中的所有设备就可以通过一个公网（广域网）IP 访问互联网了，实现了 IP 共享 此外，还有一类 IP 称为本机回环 IP 地址，比如 127.0.0.1，访问这个 IP 地址实际上就是访问本机，等价于 loacalhost 端口号 在一台电脑中，可以运行成百上千个 web 服务。每个 web 服 务都对应一个唯一的端口号。客户端发送过来的 网络请求，通过端口号，可以 被准确地交给对应的 web 服务进行处理 域名和域名服务器 尽管 IP 地址能够唯一地标记网络上的计算机，但 IP 地址是一长串数字， 不直观，而且不便于记忆，于是人们又发明了另一套 字符型的地址方案，即所谓的域名（Domain Name）地址。 IP 地址和域名是一一对应的关系，这就好比人名和身份证 ID 一样。这份对应关系存放在一种叫做域名服务器(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器 实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器 3、创建 http 服务使用 nodejs 创建 HTTP 服务 123456789101112//1. 导入 http 模块const http = require(&quot;http&quot;);//2. 创建服务对象 create 创建 server 服务// request 意为请求. 是对请求报文的封装对象, 通过 request 对象可以获得请求报文的数据// response 意为响应. 是对响应报文的封装对象, 通过 response 对象可以设置响应报文const server = http.createServer((request, response) =&gt; &#123; response.end(&quot;Hello HTTP server&quot;);&#125;);//3. 监听端口, 启动服务server.listen(9000, () =&gt; &#123; console.log(&quot;服务已经启动, 端口 9000 监听中...&quot;);&#125;); 注意事项 响应内容中文乱码的解决办法 1response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=utf-8&quot;); HTTP 协议默认端口是 80 。HTTPS 协议的默认端口是 443, HTTP 服务开发常用端口有 3000， 8080，8090，9000 等 获取 HTTP 请求报文 想要获取请求的数据，需要通过 request 对象 注意事项： request.url 只能获取路径以及查询字符串(端口号以后的内容)，无法获取 URL 中的域名以及协议的内容 request.headers 将请求信息转化成一个对象，并将属性名都转化成了『小写』 关于路径：如果访问网站的时候，只填写了 IP 地址或者是域名信息，此时请求的路径为『 &#x2F; 』 关于 favicon.ico：这个请求是属于浏览器自动发送的请求 设置 HTTP 响应报文 练习 搭建 HTTP 服务，响应一个 4 行 3 列的表格，并且要求表格有 隔行换色效果 ，且 点击 单元格能 高亮显示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//导入 http 模块const http = require(&quot;http&quot;);//创建服务对象const server = http.createServer((request, response) =&gt; &#123; response.end(`&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt;td&#123;padding: 20px 40px;&#125;table tr:nth-child(odd)&#123;background: #aef;&#125;table tr:nth-child(even)&#123;background: #fcb;&#125;table, td&#123;border-collapse: collapse;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;script&gt;//获取所有的 tdlet tds = document.querySelectorAll(&#x27;td&#x27;);//遍历tds.forEach(item =&gt; &#123;item.onclick = function()&#123;this.style.background = &#x27;#222&#x27;;&#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`); //设置响应体&#125;);//监听端口, 启动服务server.listen(9000, () =&gt; &#123; console.log(&quot;服务已经启动....&quot;);&#125;); 网页资源的基本加载过程 网页资源的加载都是循序渐进的，首先获取 HTML 的内容， 然后解析 HTML 在发送其他资源的请求，如 CSS，Javascript，图片等 静态资源服务 静态资源是指 内容长时间不发生改变的资源 ，例如图片，视频，CSS 文件，JS 文件，HTML 文件，字体文 件等 动态资源是指 内容经常更新的资源 ，例如百度首页，网易首页，京东搜索列表页面等 网站根目录或静态资源目录 HTTP 服务在哪个文件夹中寻找静态资源，那个文件夹就是 静态资源目录 ，也称之为 网站根目录 1234567891011121314151617181920212223242526require(&quot;http&quot;) .createServer((request, response) =&gt; &#123; //获取请求的方法已经路径 let &#123; url, method &#125; = request; //判断请求方式以及请求路径 if (method == &quot;GET&quot; &amp;&amp; url == &quot;/index.html&quot;) &#123; //需要响应文件中的内容 let data = require(&quot;fs&quot;).readFileSync(__dirname + &quot;/index.html&quot;); response.end(data); &#125; else if (method == &quot;GET&quot; &amp;&amp; url == &quot;/css/app.css&quot;) &#123; //需要响应文件中的内容 let data = require(&quot;fs&quot;).readFileSync(__dirname + &quot;/public/css/app.css&quot;); response.end(data); &#125; else if (method == &quot;GET&quot; &amp;&amp; url == &quot;/js/app.js&quot;) &#123; //需要响应文件中的内容 let data = require(&quot;fs&quot;).readFileSync(__dirname + &quot;/public/js/app.js&quot;); response.end(data); &#125; else &#123; //404响应 response.statusCode = 404; response.end(&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;); &#125; &#125;) .listen(80, () =&gt; &#123; console.log(&quot;80端口正在启动中....&quot;); &#125;); 上面这段代码根据路径和方法相应不同的资源，显然这种方式不够完美，我们需要更简洁的方法 123456789101112131415161718192021222324require(&quot;http&quot;) .createServer((request, response) =&gt; &#123; //获取请求的方法已经路径 let &#123; url, method &#125; = request; //文件夹路径 let rootDir = __dirname + &quot;/public&quot;; //拼接文件路径 let filePath = rootDir + url; //读取文件内容 fs.readFile(filePath, (err, data) =&gt; &#123; //判断 if (err) &#123; //如果出现错误，响应404状态码 response.statusCode = 404; response.end(&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;); &#125; else &#123; //响应文件内容 response.end(data); &#125; &#125;); &#125;) .listen(80, () =&gt; &#123; console.log(&quot;80端口正在启动中....&quot;); &#125;); 通过这种方法可以根据请求路径动态响应资源 设置资源类型（mime 类型） 媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、 文件或字节流的性质和格式。 HTTP 服务可以设置响应头 Content-Type 来表明响应体的 MIME 类型，浏览器会根据该类型决定如何处理 资源 下面是常见文件对应的 mime 类型 GET 和 POST GET 主要用来获取数据，POST 主要用来提交数据 GET 带参数请求是将参数缀到 URL 之后，在地址栏中输入 url 访问网站就是 GET 请求， POST 带参数请求是将参数放到请求体中 POST 请求相对 GET 安全一些，因为在浏览器中参数会暴露在地址栏 GET 请求大小有限制，一般为 2K，而 POST 请求则没有大小限制 以下均为 GET 请求： 在地址栏直接输入 url 访问 点击 a 链接 link 标签引入 css script 标签引入 js img 标签引入图片 form 标签中的 method 为 get （不区分大小写） ajax 中的 get 请求 以下均为 POST 请求： form 标签中的 method 为 post（不区分大小写） AJAX 的 post 请求 七、模块化模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过 程。对于整个系统来说，模块是可组 合、分解和更换的单元 编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相 依赖的多个小模块 把代码进行模块化拆分的好处 防止命名冲突 高复用性 高维护性 common.js 暴露数据 module.exports &#x3D; value exports.name &#x3D; value 注意 module.exports 可以暴露 任意 数据 不能使用 exports &#x3D; value 的形式暴露数据。exports &#x3D; module.exports &#x3D; {} ，require 返回的永远是目标模块中 module.exports 的值（因为 exports 和 module.exports 是对象，存的是引用。如果直接使用 exports &#x3D; value 赋值，相当于将 exports 与原来 module.exports 的链接断开了 ） common.js 导入（引入、加载）模块 在模块中使用 require 传入文件路径即可引入文件 1const test = require(&quot;./me.js&quot;); require 使用的一些注意事项： 对于自定义模块，导入时路径建议写相对路径 ，且不能省略 .&#x2F; 和 ..&#x2F; js 和 json 文件导入时可以不用写后缀，c&#x2F;c++编写的 node 扩展文件也可以不写后缀，但是一 般用不到 如果导入的路径是个文件夹，则会 首先 检测该文件夹下 package.json 文件中 main 属性对应 的文件。如果存在则导入，反之如果文件不存在会报错。如果 main 属性不存在，或者 package.json 不存在，则会尝试导入文件夹下的 index.js 和 index.json 。如果还是没找到，就会报错 导入 node.js 内置模块时，直接 require 模块的名字即可，无需加路径 八、包管理工具包管理工具是一个通用的概念，很多编程语言都有包管理工具 npm 全称 Node Package Manager ，翻译为中文意思是『Node 的包管理工具』。它是 node.js 官方内置的包管理工具 npm 初始化 npm init 命令的作用是将文件夹初始化为一个『包』， 交互式创建 package.json 文件。package.json 是包的配置文件，每个包都必须要有 package.json。也可以使用 npm init -y 或者 npm init –yes 极速创建 package.json。下面是一个 package.json 的示例 123456789101112&#123;&quot;name&quot;: &quot;1-npm&quot;, #包的名字&quot;version&quot;: &quot;1.0.0&quot;, #包的版本&quot;description&quot;: &quot;&quot;, #包的描述&quot;main&quot;: &quot;index.js&quot;, #包的入口文件&quot;scripts&quot;: &#123; #脚本配置&quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;&#125;,&quot;author&quot;: &quot;&quot;, #作者&quot;license&quot;: &quot;ISC&quot; #开源证书&#125; node_modules 文件夹用来存放所有已安装到项目中的包。注意：今后在项目开发中，一定要把 node_modules 文件夹，添加 到 .gitignore 忽略文件中 package-lock.json 配置文件用来记录 node_modules 目录下的每一个包 的下载信息，例如包的名字、版本号、下载地址等 生产依赖与开发依赖 我们可以在安装时设置选项来区分 依赖的类型 ，目前分为两类： 全局安装 我们可以执行安装选项 -g 进行全局安装 1npm i -g nodemon 全局安装完成之后就可以在命令行的任何位置运行 nodemon 命令 环境变量 Path Path 是操作系统的一个环境变量，可以设置一些文件夹的路径，在当前工作目录下找不到可执行文件 时，就会在环境变量 Path 的目录中挨个的查找，如果找到则执行，如果没有找到就会报错 如果希望某个程序在任何工作目录下都能正常运行，可以将该程序的所在目录配置到环境 变量 Path 中 安装包依赖 12npm inpm install 安装指定版本的包 1234## 格式npm i &lt;包名@版本号&gt;## 示例npm i jquery@1.11.2 删除依赖 12345## 局部删除npm remove uniqnpm r uniq## 全局删除npm remove -g nodemon yarn yarn 是由 Facebook 在 2016 年推出的新的 Javascript 包管理工具，官方网址：https://yarnpkg.com/ yarn 官方宣称的一些特点 速度超快：yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大 化资源利用率，因此安装速度更快 超级安全：在执行代码之前，yarn 会通过算法校验每个安装包的完整性 超级可靠：使用详细、简洁的锁文件格式和明确的安装算法，yarn 能够保证在不同系统上无差异的 工作 yarn 常用命令 nvm nvm 全称 Node Version Manager 顾名思义它是用来管理 node 版本的工具，方便切换不同版本的 Node.js nvm 的使用非常的简单，跟 npm 的使用方法类似 首先先下载 nvm，下载地址 https://github.com/coreybutler/nvm-windows/releases，选择 nvm-setup.exe 下载即可 常用命令 九、express 框架Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架http://www.expressjs.com.cn/ 对于前端程序员来说，最常见的两种服务器分别是： Web 网站服务器：专门对外提供 Web 网页资源的服务器 API 接口服务器：专门对外提供 API 接口的服务器 使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口 的服务器 1、express 使用express 本身是一个 npm 包，所以可以通过 npm 安装 1npm i express express 初体验 123456789101112//1. 导入 expressconst express = require(&quot;express&quot;);//2. 创建应用对象const app = express();//3. 创建路由规则app.get(&quot;/home&quot;, (req, res) =&gt; &#123; res.send(&quot;hello express server&quot;);&#125;);//4. 监听端口 启动服务app.listen(3000, () =&gt; &#123; console.log(&quot;服务已经启动, 端口监听为 3000...&quot;);&#125;); 在浏览器访问 http://127.0.0.1:3000/home 2、express 路由官方定义： 路由确定了应用程序如何响应客户端对特定端点的请求 路由的使用 一个路由的组成有请求方法 ， 路径和回调函数 组成 express 中提供了一系列方法，可以很方便的使用路由，使用格式如下： app.(path，callback) 代码示例： 12345678910111213141516171819202122232425262728//导入 expressconst express = require(&quot;express&quot;);//创建应用对象const app = express();//创建 get 路由app.get(&quot;/home&quot;, (req, res) =&gt; &#123; res.send(&quot;网站首页&quot;);&#125;);//首页路由app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(&quot;我才是真正的首页&quot;);&#125;);//创建 post 路由app.post(&quot;/login&quot;, (req, res) =&gt; &#123; res.send(&quot;登录成功&quot;);&#125;);//匹配所有的请求方法app.all(&quot;/search&quot;, (req, res) =&gt; &#123; res.send(&quot;1 秒钟为您找到相关结果约 100,000,000 个&quot;);&#125;);//自定义 404 路由app.all(&quot;*&quot;, (req, res) =&gt; &#123; res.send(&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;);&#125;);//监听端口 启动服务app.listen(3000, () =&gt; &#123; console.log(&quot;服务已经启动, 端口监听为 3000&quot;);&#125;); 路由的匹配过程 每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后， 才会调用对应的处理函数 在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时 匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理 注意 路由匹配按照定义的先后顺序进行匹配 请求类型和请求的 URL 同时匹配成功， 才会调用对应的处理函数 模块化路由 为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。 将路由抽离为单独模块的步骤如下： 创建路由模块对应的 .js 文件 调用 express.Router() 函数创建路由对象 向路由对象上挂载具体的路由 使用 module.exports 向外共享路由对象 使用 app.use() 函数注册路由模块 12345678910111213//1. 导入 expressconst express = require(&quot;express&quot;);//2. 创建路由器对象const router = express.Router();//3. 在 router 对象身上添加路由router.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(&quot;首页&quot;);&#125;);router.get(&quot;/cart&quot;, (req, res) =&gt; &#123; res.send(&quot;购物车&quot;);&#125;);//4. 暴露module.exports = router; express 中的 Router 是一个完整的中间件和路由系统，可以看做是一个小型的 app 对象 导入使用路由 123456789const express = require(&quot;express&quot;);const app = express();//5.引入子路由文件const homeRouter = require(&quot;./routes/homeRouter&quot;);//6.设置和使用中间件app.use(homeRouter);app.listen(3000, () =&gt; &#123; console.log(&quot;3000 端口启动....&quot;);&#125;); 为路由模块添加前缀 1234//1、导入路由模块const userRouter = require(&quot;./router/user.js&quot;);//2、使用app.use()注册路由模块，并添加统一的访问前缀 /apiapp.use(&quot;/api&quot;, userRouter); 获取 URL 中的查询参数 通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到 服务器的参数： 123456app.get(&quot;/&quot;, (req, res) =&gt; &#123; // req.query默认是一个空对象 // 客户端使用?name=zs&amp;age=20这种查询字符串的形式发送到服务器的参数， // 可以通过req.query对象访问到 console.log(req.query);&#125;); 获取 URL 中的动态参数 通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数 12345app.get(&quot;/user/:id&quot;, (req, res) =&gt; &#123; // req.params默认是一个空对象 // 里面存放着通过:动态匹配到的参数值 console.log(req.params);&#125;); express 响应设置 express 框架封装了一些 API 来方便给客户端响应数据，并且兼容原生 HTTP 模块的获取方式 1234567891011121314151617181920//获取请求的路由规则app.get(&quot;/response&quot;, (req, res) =&gt; &#123; //1. express 中设置响应的方式兼容 HTTP 模块的方式 res.statusCode = 404; res.statusMessage = &quot;xxx&quot;; res.setHeader(&quot;abc&quot;, &quot;xyz&quot;); res.write(&quot;响应体&quot;); res.end(&quot;xxx&quot;); //2. express 的响应方法 res.status(500); //设置响应状态码 res.set(&quot;xxx&quot;, &quot;yyy&quot;); //设置响应头 res.send(&quot;中文响应不乱码&quot;); //设置响应体 //连贯操作 res.status(404).set(&quot;xxx&quot;, &quot;yyy&quot;).send(&quot;你好朋友&quot;); //3. 其他响应 res.redirect(&quot;http://atguigu.com&quot;); //重定向 res.download(&quot;./package.json&quot;); //下载响应 res.json(); //响应 JSON res.sendFile(__dirname + &quot;/home.html&quot;); //响应文件内容&#125;); 注意，使用 res.send()发送的中文并没有乱码，这是因为 express 自动在响应头添加了res.setHeader(‘content-type’,’text&#x2F;html;charset&#x3D;utf-8’); 3、express 中间件中间件（Middleware）本质是一个回调函数 中间件函数 可以像路由回调一样访问 请求对象（request） ， 响应对象（response） 中间件的作用 就是 使用函数封装公共操作，简化代码 当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而 对这次请求进行预处理 注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中 只包含 req 和 res。**next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下 一个中间件或路由 定义全局中间件 客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生 效的中间件 声明中间件函数 123456let recordMiddleware = function (request, response, next) &#123; //实现功能代码 //..... //执行next函数(当如果希望执行完中间件函数之后，仍然继续执行路由中的回调函数，必须调用next) next();&#125;; 应用中间件 通过调用 app.use(中间件函数)，即可定义一个全局生效的中间件 1app.use(recordMiddleware); 声明时可以直接将匿名函数传递给 use 1234app.use(function (request, response, next) &#123; console.log(&quot;定义第一个中间件&quot;); next();&#125;); 定义多个全局中间件 可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之 后，会按照中间件定义的先后顺序依次进行调用 局部生效的中间件(路由中间件) 如果只需要对某一些路由进行功能封装 ，则就需要路由中间件。路由中间件不使用 app.use() 定义,调用格式如下： 123app.get(&quot;/路径&quot;, `中间件函数`, (request, response) =&gt; &#123;&#125;);// 使用多个路由中间件app.get(&quot;/路径&quot;, `中间件函数1`, `中间件函数2`, (request, response) =&gt; &#123;&#125;); 中间件的 几个使用注意事项 一定要在路由之前注册中间件 客户端发送过来的请求，可以连续调用多个中间件进行处理 执行完中间件的业务代码之后，不要忘记调用 next() 函数 为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码 连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象 Express 内置的中间件 自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大 的提高了 Express 项目的开发效率和体验 express.static 快速托管静态资源的内置中间件，例如： HTML 文件、 图片、CSS 样式等（无兼容性） express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性， 仅在 4.16.0+ 版本中可用） 1234567891011121314151617181920//引入express框架const express = require(&quot;express&quot;);//创建服务对象const app = express();// 配置解析application/json格式数据的内置中间件app.use(express.json());// 配置解析application/x-www-form-urlencoded格式数据的内置中间件app.use(express.urlencoded(&#123; extended: false &#125;));//静态资源中间件的设置，将当前文件夹下的public目录作为网站的根目录app.use(express.static(&quot;./public&quot;)); //当然这个目录中都是一些静态资源//如果访问的内容经常变化，还是需要设置路由//但是，在这里有一个问题，如果public目录下有index.html文件，单独也有index.html的路由，//则谁书写在前，优先执行谁app.get(&quot;/index.html&quot;, (request, response) =&gt; &#123; response.send(&quot;首页&quot;);&#125;);//监听端口app.listen(3000, () =&gt; &#123; console.log(&quot;3000 端口启动....&quot;);&#125;); 4、防盗链我们在访问第三方资源（如图片）的时候，有时可能会出现资源 403、404 的情况，这是因为服务端做了防盗链处理，只允许指定的域名访问资源 服务端一般使用 Referer 请求头识别访问来源，然后处理资源访问。 Referer 是 HTTP 请求头的一部分，当浏览器向 Web 服务器发送请求的时候，一般会带上 Referer，它包含了当前请求资源的来源页面的地址。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。 实现防盗链 在服务端只需通过中间件即可实现防盗链 123456789101112131415161718app.use((req, res, next) =&gt; &#123; //检测请求头中的referer是否为127.0.0.1 //获取referer let referer = req.get(&quot;referer&quot;); if (referer) &#123; //实例化 let url = new URL(referer); //获取hostname let hostname = url.hostname; //判断 if (hostname !== &quot;127.0.0.1&quot;) &#123; //响应404 res.status(404).send(&quot;&lt;h1&gt;404 Not Found&lt;/h1&gt;&quot;); return; &#125; &#125; next();&#125;); 如果第三方设置了防盗链，我们又想访问该怎么做呢 设置不发送 referrer 就行了 用 &lt;a&gt;、&lt;area&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;script&gt; 或者 &lt;link&gt; 元素上的 referrerpolicy 属性为其设置独立的请求策略，例如： 1&lt;img src=&quot;http://……&quot; referrerpolicy=&quot;no-referrer&quot; /&gt; 或者直接在 HTMl 页面头中通过 meta 属性全局配置： 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 扩展参考：http://www.ruanyifeng.com/blog/2019/06/http-referer.html 5、EJS 模板引擎模板引擎是分离用户界面和业务数据 的一种技术 EJS 是一个高效的 Javascript 的模板引擎。官网: https://ejs.co/ 中文站：https://ejs.bootcss.com/ EJS 使用 下载安装 EJS 1npm i ejs --save 代码示例 123456789//1.引入ejsconst ejs = require(&#x27;ejs&#x27;);//2.定义数据let person = [&#x27;张三&#x27;,&#x27;李四&#x27;,&#x27;王二麻子&#x27;];//3.ejs解析模板返回结构//&lt;%= %&gt; 是ejs解析内容的标记，作用是输出当前表达式的执行结构let html = ejs.render(‘&lt;%= person.join(&quot;,&quot;) %&gt;’, &#123;person:person&#125;);//4.输出结果console.log(html); render 渲染函数会将其第一个参数中&lt;% %&gt;中的值替换为第二个参数（也就是数据）进行解析渲染 EJS 常用语法 执行 JS 代码(可以认为里面是 js 语句，如条件语句、循环语句等) 1&lt;% code %&gt; 输出转义的数据到模板上(可以认为里面是 js 表达式) 1&lt;%= code %&gt; 实际上，我们通常将需要渲染的界面和数据分离开来 新建 test.ejs 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;我爱你&lt;%=name%&gt;&lt;/h2&gt; &lt;hr /&gt; &lt;h4&gt;&lt;%=word%&gt;&lt;/h4&gt; &lt;/body&gt;&lt;/html&gt; 主文件中 1234567891011121314const express = require(&quot;express&quot;);const ejs = require(&quot;ejs&quot;);const fs = require(&quot;fs&quot;);const app = express();const name = &quot;中国&quot;;const word = &quot;亲爱的母亲&quot;;const str = fs.readFileSync(__dirname + &quot;/test.ejs&quot;).toString();const result = ejs.render(str, &#123; name: name, word: word &#125;);app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(result);&#125;);app.listen(3000, () =&gt; &#123; console.log(&quot;服务器启动了...&quot;);&#125;); EJS 列表渲染 test.ejs 中 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;%name.forEach(item=&gt;&#123;%&gt; &lt;li&gt;&lt;%=item%&gt;&lt;/li&gt; &lt;%&#125;)%&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; EJS 条件渲染 test.ejs 中 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%if(isLogin)&#123;%&gt; &lt;span&gt;欢迎回来&lt;/span&gt; &lt;%&#125;else&#123;%&gt; &lt;button&gt;登录&lt;/button&gt;&lt;button&gt;注册&lt;/button&gt; &lt;%&#125;%&gt; &lt;/body&gt;&lt;/html&gt; express 中使用 EJS 在之前我们使用 fs 去手动读取 ejs 中的数据并交给 ejs.render 函数去渲染。但在 express 中我们有更简便的方法，无需手动读取 123456789101112131415const express = require(&quot;express&quot;);const path = require(&quot;path&quot;);const ejs = require(&quot;ejs&quot;);const app = express();//将express中的模板引擎设置为ejsapp.set(&quot;view engine&quot;, &quot;ejs&quot;);//设置模板文件的存放位置app.set(&quot;views&quot;, path.resolve(__dirname, &quot;./views&quot;));app.get(&quot;/&quot;, (req, res) =&gt; &#123; const title = &quot;人生得意须尽欢&quot;; res.render(&quot;test&quot;, &#123; title &#125;);&#125;);app.listen(3000, () =&gt; &#123; console.log(&quot;服务器启动了...&quot;);&#125;); 6、express-generatorexpress-generator 是一款官方推荐的 Express 应用程序生成器，通过它可以快速创建一个 Express 应用骨架 可以通过 npx（包含在 Node.js8.2.0 及更高版本中）命令来运行 Express 应用程序生成器 1$ npx express-generator 对于较老的 Node 版本，可以通过 npm 将 Express 应用程序生成器安装到全局环境中并使用 12$ npm install -g express-generator$ express 使用如下命令就可以快速创建一个 Express 应用骨架。其中-e 表示添加 EJS 模板引擎支持，dirname 是要创建的文件夹名称 1$ express -e dirname 文件上传处理 使用如下命令快速创建应用骨架 1$ express -e file 在 file&#x2F;routes&#x2F;index.js 中新增两个头像上传的路由 1234567891011121314const express = require(&quot;express&quot;);const router = express.Router();/* GET home page. */router.get(&quot;/&quot;, function (req, res, next) &#123; res.render(&quot;index&quot;, &#123; title: &quot;Express&quot; &#125;);&#125;);router.get(&quot;/portrait&quot;, function (req, res, next) &#123; res.render(&quot;portrait&quot;);&#125;);router.post(&quot;/portrait&quot;, function (req, res, next) &#123; res.send(&quot;111&quot;);&#125;);module.exports = router; 对应的在 views 文件下创建 portrait.ejs 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 对于文件上传，必须将enctype属性设置为multipart/form-data --&gt; &lt;form action=&quot;/portrait&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;portrait&quot; placeholder=&quot;上传头像&quot; /&gt; &lt;hr /&gt; &lt;button&gt;上传&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 接下来需要使用一个包叫 formidable 对上传的文件作进一步处理 1npm i formidable 1234567891011121314151617181920212223const express = require(&quot;express&quot;);//导入formidableconst formidable = require(&quot;formidable&quot;);const router = express.Router();/* GET home page. */router.get(&quot;/&quot;, function (req, res, next) &#123; res.render(&quot;index&quot;, &#123; title: &quot;Express&quot; &#125;);&#125;);router.get(&quot;/portrait&quot;, function (req, res, next) &#123; res.render(&quot;portrait&quot;);&#125;);router.post(&quot;/portrait&quot;, function (req, res, next) &#123; const form = formidable(&#123; multiples: true &#125;); form.parse(req, (err, fields, files) =&gt; &#123; if (err) &#123; next(err); return; &#125; res.json(&#123; fields, files &#125;); &#125;);&#125;);module.exports = router; 查看浏览器，可以看到 fields 里面存放的是一般表单的数据，比如 text、radio、select、checkbox 这种类型。而 files 里面保存的是 file 类型的数据 一般拿到客户端上传的文件之后，可以将其保存在静态资源目录下以方便用户访问。并将访问的路径保存在数据库里，并且返回给用户。 12345678910111213141516171819202122232425262728293031const express = require(&quot;express&quot;);//导入formidableconst formidable = require(&quot;formidable&quot;);const router = express.Router();/* GET home page. */router.get(&quot;/&quot;, function (req, res, next) &#123; res.render(&quot;index&quot;, &#123; title: &quot;Express&quot; &#125;);&#125;);router.get(&quot;/portrait&quot;, function (req, res, next) &#123; res.render(&quot;portrait&quot;);&#125;);router.post(&quot;/portrait&quot;, function (req, res, next) &#123; const form = formidable(&#123; multiples: true, //设置文件上传保存的路径 uploadDir: __dirname + &quot;/../public/images&quot;, //保持文件后缀 keepExtensions: true, &#125;); form.parse(req, (err, fields, files) =&gt; &#123; if (err) &#123; next(err); return; &#125; //通过files.portrait.newFilename拼接保存文件上传的路径 let url = &quot;/images/&quot; + files.portrait.newFilename; res.send(url); &#125;);&#125;);module.exports = router; 7、账单案例使用 express-generator 快速生成一个应用骨架 accounts 在 routes&#x2F;index.js 中新增&#x2F;account 和&#x2F;account&#x2F;create 路由中间件 12345678910111213141516171819202122232425262728293031323334const express = require(&quot;express&quot;);const router = express.Router();/* GET home page. */router.get(&quot;/&quot;, function (req, res, next) &#123; res.render(&quot;index&quot;, &#123; title: &quot;Express&quot; &#125;);&#125;);// 账单列表页router.get(&quot;/account&quot;, function (req, res, next) &#123; const accounts = [ &#123; time: &quot;2023-04-01&quot;, title: &quot;吃饭&quot;, type: &quot;-1&quot;, account: 36, &#125;, &#123; time: &quot;2023-04-20&quot;, title: &quot;发工资&quot;, type: &quot;1&quot;, account: 15000, &#125;, ]; res.render(&quot;list&quot;, &#123; accounts &#125;);&#125;);//新增记录页router.get(&quot;/account/create&quot;, function (req, res, next) &#123; res.render(&quot;create&quot;);&#125;);//处理新增记录router.post(&quot;/account&quot;, function (req, res, next) &#123; res.send(&quot;提交成功&quot;);&#125;);module.exports = router; 并在 views 中新建 list.ejs 和 create.ejs，这样账单的基本静态页面就搭建起来了 list.ejs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;style&gt; label &#123; font-weight: normal; &#125; .panel-body .glyphicon-remove &#123; display: none; &#125; .panel-body:hover .glyphicon-remove &#123; display: inline-block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-lg-8 col-lg-offset-2&quot;&gt; &lt;h2&gt;记账本&lt;/h2&gt; &lt;hr /&gt; &lt;div class=&quot;accounts&quot;&gt; &lt;% accounts.forEach(item =&gt; &#123; %&gt; &lt;div class=&quot;panel &lt;%= item.type===&#x27;-1&#x27; ? &#x27;panel-danger&#x27; : &#x27;panel-success&#x27; %&gt;&quot; &gt; &lt;div class=&quot;panel-heading&quot;&gt;&lt;%= item.time %&gt;&lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;div class=&quot;col-xs-6&quot;&gt;&lt;%= item.title %&gt;&lt;/div&gt; &lt;div class=&quot;col-xs-2 text-center&quot;&gt; &lt;span class=&quot;label &lt;%= item.type===&#x27;-1&#x27; ? &#x27;label-warning&#x27; : &#x27;label-success&#x27; %&gt;&quot; &gt;&lt;%= item.type===&#x27;-1&#x27; ? &#x27;支出&#x27; : &#x27;收入&#x27; %&gt;&lt;/span &gt; &lt;/div&gt; &lt;div class=&quot;col-xs-2 text-right&quot;&gt;&lt;%= item.account %&gt; 元&lt;/div&gt; &lt;div class=&quot;col-xs-2 text-right&quot;&gt; &lt;a href=&quot;/account/&lt;%= item.id %&gt;&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-remove&quot; aria-hidden=&quot;true&quot; &gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; create.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;添加记录&lt;/title&gt; &lt;link href=&quot;/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;link href=&quot;/css/bootstrap-datepicker.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-lg-8 col-lg-offset-2&quot;&gt; &lt;h2&gt;添加记录&lt;/h2&gt; &lt;hr /&gt; &lt;form method=&quot;post&quot; action=&quot;/account&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;item&quot;&gt;事项&lt;/label&gt; &lt;input name=&quot;title&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;item&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;time&quot;&gt;时间&lt;/label&gt; &lt;input name=&quot;time&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;time&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;type&quot;&gt;类型&lt;/label&gt; &lt;select name=&quot;type&quot; class=&quot;form-control&quot; id=&quot;type&quot;&gt; &lt;option value=&quot;-1&quot;&gt;支出&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;收入&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;account&quot;&gt;金额&lt;/label&gt; &lt;input name=&quot;account&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;account&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;remarks&quot;&gt;备注&lt;/label&gt; &lt;textarea name=&quot;remarks&quot; class=&quot;form-control&quot; id=&quot;remarks&quot; &gt;&lt;/textarea&gt; &lt;/div&gt; &lt;hr /&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-block&quot;&gt; 添加 &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/bootstrap-datepicker.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/bootstrap-datepicker.zh-CN.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意：需要将 ejs 文件中引用到的 css 和 js 文件放在静态资源 public 目录下，并将 ejs 文件中的路径设置为绝对路径 十、MongoDB1、MongoDB 基础知识MongoDB 是一个基于分布式文件存储的数据库，官方地址 https://www.mongodb.com/ 数据库（DataBase）是按照数据结构来组织、存储和管理数据的 应用程序 数据库的主要作用就是 管理数据 ，对数据进行 增（c）、删（d）、改（u）、查（r） 相比于纯文件管理数据，数据库管理数据有如下特点： 速度更快 扩展性更强 安全性更强 市面上的数据库有很多种，最常见的数据库有如下几个： MySQL 数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise） Oracle 数据库（收费） SQL Server 数据库（收费） Mongodb 数据库（Community + Enterprise） 其中，MySQL、Oracle、SQL Server 属于传统型数据库（又叫做：关系型数据库 或 SQL 数据库），这三者的 设计理念相同，用法比较类似 而 Mongodb 属于新型数据库（又叫做：非关系型数据库 或 NoSQL 数据库），它在一定程度上弥补了传统型 数据库的缺陷 Mongodb 中有三个重要概念需要掌握 数据库（database） 数据库是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存 放很多集合 集合（collection） 集合类似于 JS 中的数组，在集合中可以存放很多文档 文档（document） 文档是数据库中的最小单位，类似于 JS 中的对象 Mongodb 下载地址： https://www.mongodb.com/try/download/community 配置步骤如下: 将压缩包移动到 C:\\Program Files 下，然后解压 创建 C:\\data\\db 目录，mongodb 会将数据默认保存在这个文件夹 以 mongodb 中 bin 目录作为工作目录，启动命令行 运行命令 mongod 此时 Mongodb 的数据库服务已经启动了 重新打开一个以 mongodb 中 bin 目录作为工作目录的终端，使用 mongo 命令连接本机的 mongodb 服务 注意： 为了方便后续方便使用 mongod 命令，可以将 bin 目录配置到环境变量 Path 中 千万不要选中服务端窗口的内容 ，选中会停止服务，可以 敲回车 取消选中 2、命令行交互数据库命令 显示所有的数据库 1show dbs 切换到指定的数据库，如果数据库不存在会自动创建数据库 1use 数据库名 显示当前所在的数据库 1db 删除当前数据库 12use 库名db.dropDatabase() 集合命令 创建集合 1db.createCollection(&#x27;集合名称&#x27;) 显示当前数据库中的所有集合 1show collections 删除某个集合 1db.集合名.drop() 重命名集合 1db.集合名.renameCollection(&#x27;newName&#x27;) 文档命令 插入文档 1db.集合名.insert(文档对象) 查询文档 1db.集合名.find(查询条件) _id 是 mongodb 自动生成的唯一编号，用来唯一标识文档 更新文档 12db.集合名.update(查询条件,新的文档)db.集合名.update(&#123;name:&#x27;张三&#x27;&#125;,&#123;$set:&#123;age:19&#125;&#125;) 直接使用 db.集合名.update(查询条件,新的文档)这种方式，会覆盖式更新，因此可以使用第二种方式精确（局部）更新 删除文档 1db.集合名.remove(查询条件) 3、MongooseMongoose 是一个对象文档模型库，官网 http://www.mongoosejs.net/ 它的本质就是一个包，方便使用代码操作 mongodb 数据库。取代我们之前在终端中使用 mongo 命令行的方式操作数据库 使用流程 1234567891011121314151617181920212223242526272829303132333435//1. 安装 mongoose//2. 导入 mongooseconst mongoose = require(&quot;mongoose&quot;);//3. 连接数据库,27017是mongodb的默认端口号，可以省略。如果bilibili数据库不存在则会自动创建// mongodb是MongoDB的连接协议，正如我们之前http服务使用http协议一样，MongoDB数据库服务使用mongodb协议mongoose.connect(&quot;mongodb://127.0.0.1:27017/bilibili&quot;);//4. 设置连接回调//连接成功mongoose.connection.on(&quot;open&quot;, () =&gt; &#123; console.log(&quot;连接成功&quot;); //5. 创建文档结构对象 let BookSchema = new mongoose.Schema(&#123; title: String, author: String, price: Number, &#125;); //6. 创建文档模型对象 let BookModel = mongoose.model(&quot;book&quot;, BookSchema); //7. 插入文档 BookModel.create(&#123; title: &quot;西游记&quot;, author: &quot;吴承恩&quot;, price: 19.9, &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err));&#125;);//连接出错mongoose.connection.on(&quot;error&quot;, () =&gt; &#123; console.log(&quot;连接出错~~&quot;);&#125;);//连接关闭mongoose.connection.on(&quot;close&quot;, () =&gt; &#123; console.log(&quot;连接关闭&quot;);&#125;); 字段类型 文档结构可选的常用字段类型列表 字段值验证 Mongoose 有一些内建验证器，可以对字段值进行验证 必填项 1234title: &#123; type: String, required: true // 设置必填项&#125; 默认值 1234author: &#123; type: String, default: &#x27;匿名&#x27; //默认值&#125; 枚举值 1234gender: &#123; type: String, enum: [&#x27;男&#x27;,&#x27;女&#x27;] //设置的值必须是数组中的&#125; 唯一值 1234username: &#123; type: String, unique: true&#125; unique 需要 重建集合 才能有效果 Mongoose 操作数据库的基本操作：增加（create），删除（delete），修改（update），查（read） 增加 插入一条 1234567BookModel.create(&#123; title: &quot;西游记&quot;, author: &quot;吴承恩&quot;, price: 19.9,&#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 批量插入 1234567891011121314151617181920//批量插入BookModel.insertMany([ &#123; title: &quot;红楼梦&quot;, author: &quot;曹雪芹&quot;, price: 29.9, &#125;, &#123; title: &quot;水浒传&quot;, author: &quot;施耐庵&quot;, price: 39.9, &#125;, &#123; title: &quot;三国演义&quot;, author: &quot;罗贯中&quot;, price: 49.9, &#125;,]) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 删除 删除一条数据 1234//删除一条BookModel.deleteOne(&#123; title: &quot;红楼梦&quot; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 批量删除 1234//批量删除BookModel.deleteMany(&#123; author: &quot;罗贯中&quot; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 更新 更新一条数据 1234//更新一条BookModel.updateOne(&#123; author: &quot;罗贯中&quot; &#125;, &#123; price: 9.9 &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 批量更新数据 同上 查询 查询一条数据 1234567BookModel.findOne(&#123; name: &quot;三国演义&quot; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err));//根据id查询BookModel.findById(&#123; _id: &quot;6438c46df163eb812a612bb5&quot; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 批量查询数据 12345678//不加条件查询BookModel.find() .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err));//加条件查询BookModel.find(&#123; author: &quot;余华&quot; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 条件控制 Mongoose 中主要有运算符、 逻辑运算、正则匹配三中条件控制 运算符 在 mongodb 不能 &gt; &lt; &gt;&#x3D; &lt;&#x3D; !&#x3D;&#x3D; 等运算符，需要使用替代符号 &gt; 使用 $gt &lt; 使用 $lt &#x3D; 使用 $gte &lt;&#x3D; 使用 $lte !&#x3D;&#x3D; 使用 $ne 123BookModel.find(&#123; price: &#123; $gt: 60 &#125; &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 逻辑运算 $or 逻辑或 123BookModel.find(&#123; $or: [&#123; author: &quot;罗贯中&quot; &#125;, &#123; price: 59.8 &#125;] &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); $and 逻辑与 123BookModel.find(&#123; $and: [&#123; price: &#123; $gt: 20 &#125; &#125;, &#123; price: &#123; $lt: 30 &#125; &#125;] &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 正则匹配 条件中可以直接使用 JS 的正则语法，通过正则可以进行模糊查询 123BookModel.find(&#123; name: /三/ &#125;) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 个性化读取 字段筛选 1234567//0:不要的字段//1:要的字段BookModel.find() .select(&#123; name: 1, author: 1 &#125;) .exec() .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); 将筛选字段的条件放在 select 函数中，值为 1 表示需要筛选出来，为 0 表示该字段不需要。回调函数放在 exec 中。当然 find 函数中也可以写入筛选条件 数据排序 12345BookModel.find() .sort(&#123; price: 1 &#125;) .exec() .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); sort 函数函数中参数名表示排序的字段名，值为 1 表示升序，-1 表示降序 数据截取 12345BookModel.find() .skip(3) .limit(2) .then((data) =&gt; console.log(data)) .catch((err) =&gt; console.log(err)); skip 表示跳过前 3 个，limit 表示取 2 个，因此最终取值结果为第 4 个至第 5 个 图形化管理工具 我们可以使用图形化的管理工具来对 Mongodb 进行交互 Robo 3T 免费 https://github.com/Studio3T/robomongo/releases Navicat 收费 https://www.navicat.com.cn/ Mongoose 模块化 随着业务的增多，我们可以将 Mongoose 操作分模块管理 主要思路如下： 将连接成功之后的回调函数里面的操作单独拿出来放在 index.js，剩下的内容以函数的形式进行封装放在 db 目录下的 index.js，并通过 module.exports 暴露出去 123456789101112131415161718192021module.exports = function (success, err) &#123; //1. 安装 mongoose //2. 导入 mongoose const mongoose = require(&quot;mongoose&quot;); //3. 连接数据库,27017是mongodb的默认端口号，可以省略。如果bilibili数据库不存在则会自动创建 // mongodb是MongoDB的连接协议，正如我们之前http服务使用http协议一样，MongoDB数据库服务使用mongodb协议 mongoose.connect(&quot;mongodb://127.0.0.1:27017/bilibili&quot;); //4. 设置连接回调 //连接成功 mongoose.connection.on(&quot;open&quot;, () =&gt; &#123; success(); &#125;); //连接出错 mongoose.connection.on(&quot;error&quot;, () =&gt; &#123; err(); &#125;); //连接关闭 mongoose.connection.on(&quot;close&quot;, () =&gt; &#123; console.log(&quot;连接关闭&quot;); &#125;);&#125;; index.js 引入 db&#x2F;index.js，并将连接成功之后的回调函数里面的操作作为 success 函数参数传递过去 123456789101112131415161718192021module.exports = function (success, err) &#123; //1. 安装 mongoose //2. 导入 mongoose const mongoose = require(&quot;mongoose&quot;); //3. 连接数据库,27017是mongodb的默认端口号，可以省略。如果bilibili数据库不存在则会自动创建 // mongodb是MongoDB的连接协议，正如我们之前http服务使用http协议一样，MongoDB数据库服务使用mongodb协议 mongoose.connect(&quot;mongodb://127.0.0.1:27017/bilibili&quot;); //4. 设置连接回调 //连接成功 mongoose.connection.on(&quot;open&quot;, () =&gt; &#123; success(); &#125;); //连接出错 mongoose.connection.on(&quot;error&quot;, () =&gt; &#123; err(); &#125;); //连接关闭 mongoose.connection.on(&quot;close&quot;, () =&gt; &#123; console.log(&quot;连接关闭&quot;); &#125;);&#125;; 由于随着业务的增多，后面可能会有越来越多的文档，因此我们可以将创建文档的代码继续拆分出去。在 models 目录下新建 BookModles.js 和 MovieModles.js 123456789101112131415//导入 mongooseconst mongoose = require(&quot;mongoose&quot;);//创建文档的结构对象//设置集合中文档的属性以及属性值的类型let BookSchema = new mongoose.Schema(&#123; name: String, author: String, price: Number,&#125;);//创建模型对象 对文档操作的封装对象let BookModel = mongoose.model(&quot;books&quot;, BookSchema);//暴露模型对象module.exports = BookModel; 1234567891011121314//导入 mongooseconst mongoose = require(&quot;mongoose&quot;);// 创建文档结构const MovieSchema = new mongoose.Schema(&#123; title: String, director: String,&#125;);//创建模型对象const MovieModel = mongoose.model(&quot;movie&quot;, MovieSchema);//暴露module.exports = MovieModel; index.js 主文件中引入 12345678910111213141516171819202122232425262728293031323334//导入 db 文件const db = require(&quot;./db/db&quot;);//导入 mongooseconst mongoose = require(&quot;mongoose&quot;);//导入 BookModelconst BookModel = require(&quot;./models/BookModel&quot;);// 调用函数db( () =&gt; &#123; //7. 新增 BookModel.create( &#123; name: &quot;西游记&quot;, author: &quot;吴承恩&quot;, price: 19.9, &#125;, (err, data) =&gt; &#123; //判断是否有错误 if (err) &#123; console.log(err); return; &#125; //如果没有出错, 则输出插入后的文档对象 console.log(data); //8. 关闭数据库连接 (项目运行过程中, 不会添加该代码) mongoose.disconnect(); &#125; ); &#125;, () =&gt; &#123; console.log(&quot;连接失败...&quot;); &#125;); 接下来 db 目录下的 index.js 中我们连接的数据库地址和集合名称是写死的，我们可以新建一个 config&#x2F;config.js 文件单独进行配置 123456//配置文件module.exports = &#123; DBHOST: &quot;127.0.0.1&quot;, DBPORT: 27017, DBNAME: &quot;bilibili&quot;,&#125;; db 下的 index.js 12345678910111213141516171819202122232425262728293031323334/** * * @param &#123;*&#125; success 数据库连接成功的回调 * @param &#123;*&#125; error 数据库连接失败的回调 */module.exports = function (success, error) &#123; //1. 安装 mongoose //2. 导入 mongoose const mongoose = require(&quot;mongoose&quot;); //导入 配置文件 const &#123; DBHOST, DBPORT, DBNAME &#125; = require(&quot;../config/config.js&quot;); //设置 strictQuery 为 true mongoose.set(&quot;strictQuery&quot;, true); //3. 连接 mongodb 服务 数据库的名称 mongoose.connect(`mongodb://$&#123;DBHOST&#125;:$&#123;DBPORT&#125;/$&#123;DBNAME&#125;`); //4. 设置回调 // 设置连接成功的回调 once 一次 事件回调函数只执行一次 mongoose.connection.once(&quot;open&quot;, () =&gt; &#123; success(); &#125;); // 设置连接错误的回调 mongoose.connection.on(&quot;error&quot;, () =&gt; &#123; error(); &#125;); //设置连接关闭的回调 mongoose.connection.on(&quot;close&quot;, () =&gt; &#123; console.log(&quot;连接关闭&quot;); &#125;);&#125;; 接下来可以对之前做过的账单案例进行优化了。将数据库的操作应用到案例中 十一、接口接口是 前后端通信的桥梁 简单理解：一个接口就是 服务中的一个路由规则 ，根据请求响应结果 一般情况下，接口返回的都是 json 格式 RESTful API RESTful API 是一种特殊风格的接口，主要特点有如下几个： URL 中的路径表示 资源 ，路径中不能有 动词 ，例如 create , delete , update 等这些都不能有 操作资源要与 HTTP 请求方法对应 操作结果要与 HTTP 响应状态码对应 规则示例： 扩展阅读：https://www.ruanyifeng.com/blog/2014/05/restful_api.html 基于 RESTful API 我们可以给之前的账单案例添加 API 接口 在 routes 目录下新建 web 文件夹（专门用来存放路由文件），将原来 routes 下的 index.js 文件放到 web 文件夹下。在 routes 目录下新建 api 文件夹（专门用来存放对外的 api 接口文件），并将 index.js 文件中的内容复制一份，方便我们进行改造 在 app.js 中引入 account.js 接口文件，并配置中间件，这样外部就可以通过&#x2F;api&#x2F;xxx 来访问接口了 12const accountRouter = require(&quot;./routes/api/account&quot;);app.use(&quot;/api&quot;, accountRouter); 接下来我们对 account.js 进行改造即可 获取账单列表接口 12345678910111213141516171819router.get(&quot;/account&quot;, checkToken, function (req, res, next) &#123; AccountModel.find() .sort(&#123; time: -1 &#125;) .exec() .then((data) =&gt; res.json(&#123; code: &quot;0000&quot;, msg: &quot;读取成功&quot;, data: data, &#125;) ) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1001&quot;, msg: &quot;读取失败&quot;, data: null, &#125;); &#125;);&#125;); 添加账单记录接口 1234567891011121314151617router.post(&quot;/account&quot;, checkToken, function (req, res, next) &#123; AccountModel.create(req.body) .then((data) =&gt; &#123; res.json(&#123; code: &quot;0000&quot;, msg: &quot;新增成功&quot;, data: data, &#125;); &#125;) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1002&quot;, msg: &quot;新增失败&quot;, data: null, &#125;); &#125;);&#125;); 删除账单记录接口 1234567891011121314151617router.delete(&quot;/account/:id&quot;, checkToken, function (req, res, next) &#123; AccountModel.deleteOne(&#123; _id: req.params.id &#125;) .then(() =&gt; &#123; res.json(&#123; code: &quot;0000&quot;, msg: &quot;删除成功&quot;, data: null, &#125;); &#125;) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1003&quot;, msg: &quot;删除失败&quot;, data: null, &#125;); &#125;);&#125;); 获取单条账单记录接口 123456789101112131415161718//获取单条记录router.get(&quot;/account/:id&quot;, checkToken, function (req, res, next) &#123; AccountModel.find(&#123; _id: req.params.id &#125;) .then((data) =&gt; &#123; res.json(&#123; code: &quot;0000&quot;, msg: &quot;获取成功&quot;, data: data, &#125;); &#125;) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1004&quot;, msg: &quot;获取失败&quot;, data: null, &#125;); &#125;);&#125;); 更新账单接口 1234567891011121314151617router.patch(&quot;/account/:id&quot;, checkToken, function (req, res, next) &#123; AccountModel.updateOne(&#123; _id: req.params.id &#125;, req.body) .then((data) =&gt; &#123; res.json(&#123; code: &quot;0000&quot;, msg: &quot;更新成功&quot;, data: data, &#125;); &#125;) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1005&quot;, msg: &quot;更新失败&quot;, data: null, &#125;); &#125;);&#125;); 注意 patch 是局部更新，而 put 是覆盖式更新 以上接口均可以通过接口测试工具去测试是否正常。 在之前的 res 响应中，我们都是通过 res.render 去响应一个页面。而接口则是只需响应一个 json（一般情况下）格式的数据即可。由前端拿到数据后去做进一步的处理，最终呈现页面。 十二、会话控制1、Web 开发模式目前主流的 Web 开发模式有两种，分别是： 基于服务端渲染的传统 Web 开发模式 基于前后端分离的新型 Web 开发模式 服务端渲染的传统 Web 开发模式：服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接，动态生成的（或者模板引擎 ejs）。因此，客户端不需要使用 Ajax 这样的技术额外请求页面的数据 服务端渲染的优缺点 优点： 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电 有利于 SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于 SEO 缺点： 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于 项目高效开发 前后端分离的 Web 开发模式：依赖于 Ajax 技术的广泛应用。简而言之，前后端分离的 Web 开发模式， 就是后端只负责提供 API 接口，前端使用 Ajax 调用接口的开发模式 前后端分离的优缺点 优点： 开发体验好。前端专注于 UI 页面的开发，后端专注于 api 的开发，且前端有更多的选择性 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的 缺点： 不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方 案：利用 Vue、React 等前端框架的 SSR （server side render）技术能够很好的解决 SEO 问题！） 如何选择 Web 开发模式 不谈业务场景而盲目选择使用何种开发模式都是耍流氓。 比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的 SEO，则这时我们就需要使用服务器端渲染 而类似后台管理项目，交互性比较强，不需要考虑 SEO，那么就可以使用前后端分离的开发模式 另外，具体使用何种开发模式并不是绝对的，为了同时兼顾了首页的渲染速度和前后端分离的开发效率，一些网站采用了 首屏服务器端渲染 + 其他页面前后端分离的开发模式 HTTP 是一种无状态的协议。所谓 HTTP 协议的无状态性，指的是客户端的每次 HTTP 请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次 HTTP 请求的状态。因此它没有办法区分多次的请求是否来自于同一个客户端， 无法区分用户 而产品中又大量存在的这样的需求，所以我们需要通过 会话控制 来解决该问题 常见的会话控制技术有三种： cookie session token 对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案： 服务端渲染推荐使用 Session 认证机制 前后端分离推荐使用 JWT 认证机制 2、CookieCookie 是 HTTP 服务器发送到用户浏览器并存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用 于控制 Cookie 有效期、安全性、使用范围的可选属性组成。 不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器 客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动 将 Cookie 保存在浏览器中 随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给 服务器，服务器即可验明客户端的身份 Cookie 就像我们去办某个店的会员，当我们成为会员之后，店子会给我们发一张会员卡。后续我们出示会员卡来店即可认证我们的身份 express 中可以使用 cookie-parser 操作 cookie 12345678910111213141516171819202122232425262728293031323334const express = require(&quot;express&quot;);//1. 安装 cookie-parser npm i cookie-parser//2. 引入 cookieParser 包const cookieParser = require(&quot;cookie-parser&quot;);const app = express();//3. 设置 cookieParser 中间件app.use(cookieParser());//4-1 设置 cookieapp.get(&quot;/set-cookie&quot;, (request, response) =&gt; &#123; // 不带时效性 response.cookie(&quot;username&quot;, &quot;wangwu&quot;); // 带时效性 response.cookie(&quot;email&quot;, &quot;23123456@qq.com&quot;, &#123; maxAge: 5 * 60 * 1000 &#125;); //响应 response.send(&quot;Cookie的设置&quot;);&#125;);//4-2 读取 cookieapp.get(&quot;/get-cookie&quot;, (request, response) =&gt; &#123; //读取 cookie console.log(request.cookies); //响应体 response.send(&quot;Cookie的读取&quot;);&#125;);//4-3 删除cookieapp.get(&quot;/delete-cookie&quot;, (request, response) =&gt; &#123; //删除 response.clearCookie(&quot;username&quot;); //响应 response.send(&quot;cookie 的清除&quot;);&#125;);//4. 启动服务app.listen(3000, () =&gt; &#123; console.log(&quot;服务已经启动....&quot;);&#125;); 3、Session由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全 性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器 为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，还要在收银机上进行刷卡认证。只有收银机确认存在的 会员卡，才能被正常使用 这种“会员卡 + 刷卡认证”的设计理念，就是 Session 认证机制的精髓 express 中可以使用 express-session 对 session 进行操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const express = require(&quot;express&quot;);//1. 安装包 npm i express-session connect-mongo//2. 引入 express-session connect-mongoconst session = require(&quot;express-session&quot;);const MongoStore = require(&quot;connect-mongo&quot;);const app = express();//3. 设置 session 的中间件app.use( session(&#123; name: &quot;sid&quot;, //设置cookie的name，默认值是：connect.sid secret: &quot;atguigu&quot;, //参与加密的字符串（又称签名） saveUninitialized: false, //是否为每次请求都设置一个cookie用来存储session的id resave: true, //是否在每次请求时重新保存session store: MongoStore.create(&#123; mongoUrl: &quot;mongodb://127.0.0.1:27017/project&quot;, //数据库的连接配置 &#125;), cookie: &#123; httpOnly: true, // 开启后前端无法通过 JS 操作 maxAge: 1000 * 300, // 这一条 是控制 sessionID 的过期时间的！！！ &#125;, &#125;));//创建 sessionapp.get(&quot;/login&quot;, (req, res) =&gt; &#123; //设置session req.session.username = &quot;zhangsan&quot;; req.session.email = &quot;zhangsan@qq.com&quot;; res.send(&quot;登录成功&quot;);&#125;);//获取 sessionapp.get(&quot;/home&quot;, (req, res) =&gt; &#123; console.log(&quot;session的信息&quot;); console.log(req.session.username); if (req.session.username) &#123; res.send(`你好 $&#123;req.session.username&#125;`); &#125; else &#123; res.send(&quot;登录 注册&quot;); &#125;&#125;);//销毁 sessionapp.get(&quot;/logout&quot;, (req, res) =&gt; &#123; //销毁session // res.send(&#x27;设置session&#x27;); req.session.destroy(() =&gt; &#123; res.send(&quot;成功退出&quot;); &#125;);&#125;);app.listen(3000, () =&gt; &#123; console.log(&quot;服务已经启动, 端口 &quot; + 3000 + &quot; 监听中...&quot;);&#125;); session 和 cookie 的区别 存储的位置。cookie：浏览器端，session：服务端 安全性。cookie 是以明文的方式存放在客户端的，安全性相对较低。session 存放于服务器中，所以安全性 相对 较好 网络传输量。cookie 设置内容过多会增大报文体积， 会影响传输效率。session 数据存储在服务器，只是通过 cookie 传递 id，所以不影响传输效率 存储限制。浏览器限制单个 cookie 保存的数据不能超过 4K ，且单个域名下的存储数量也有限制。session 数据存储在服务器中，所以没有这些限制 4、完善账单案例接下来我们可以对账单案例添加权限认证的功能 在 views 目录下新建登录和注册页面 reg.ejs 和 login.ejs 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;注册&lt;/title&gt; &lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12 col-md-8 col-md-offset-2 col-lg-4 col-lg-offset-4&quot;&gt; &lt;h2&gt;注册&lt;/h2&gt; &lt;hr /&gt; &lt;form method=&quot;post&quot; action=&quot;/reg&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;item&quot;&gt;用户名&lt;/label&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;item&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;time&quot;&gt;密码&lt;/label&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;time&quot; /&gt; &lt;/div&gt; &lt;hr&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-block&quot;&gt;注册&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在 routes&#x2F;web 目录下新建 user.js 用来存放用户登录、注册、退出相关的路由，并配置路由规则 1234567891011121314151617181920212223242526272829303132333435363738var express = require(&quot;express&quot;);// 引入md5对密码进行加密const md5 = require(&quot;md5&quot;);var router = express.Router();const UserModel = require(&quot;../../Models/UserModel&quot;);//注册页面router.get(&quot;/reg&quot;, (req, res) =&gt; &#123; res.render(&quot;reg&quot;);&#125;);// 提交注册表单router.post(&quot;/reg&quot;, (req, res) =&gt; &#123; // 使用md5对密码进行加密，存储到数据库中 UserModel.create(&#123; ...req.body, password: md5(req.body.password) &#125;) .then(() =&gt; &#123; res.render(&quot;success&quot;, &#123; msg: &quot;注册成功&quot;, url: &quot;/login&quot; &#125;); &#125;) .catch(() =&gt; &#123; res.render(&quot;error&quot;); &#125;);&#125;);//登录页面router.get(&quot;/login&quot;, (req, res) =&gt; &#123; res.render(&quot;login&quot;);&#125;);//提交登录表单router.post(&quot;/login&quot;, (req, res) =&gt; &#123; const &#123; username, password &#125; = req.body; // 用户提交的账号密码跟数据库存储的账号密码进行比对 UserModel.findOne(&#123; username: username, password: md5(password) &#125;) .then((data) =&gt; &#123; if (!data) return res.render(&quot;error&quot;); res.render(&quot;success&quot;, &#123; msg: &quot;登录成功&quot;, url: &quot;/account&quot; &#125;); &#125;) .catch(() =&gt; &#123; res.render(&quot;error&quot;); &#125;);&#125;);module.exports = router; Models 目录下新建 UserModel.js 用来存放用户登录的账户密码 123456789101112131415const mongoose = require(&quot;mongoose&quot;);//创建文档结构对象let UserSchema = new mongoose.Schema(&#123; username: &#123; type: String, required: true, &#125;, password: &#123; type: String, required: true, &#125;,&#125;);//6. 创建文档模型对象let UserModel = mongoose.model(&quot;user&quot;, UserSchema);module.exports = UserModel; 最后 app.js 引入并注册新建的路由规则，这样一个简单的登录注册功能就实现了 接下来我们需要进行 Session 身份认证 在 app.js 中设置 session 的中间件 12345678910111213141516171819// 引入 express-session connect-mongoconst session = require(&quot;express-session&quot;);const MongoStore = require(&quot;connect-mongo&quot;);//设置 session 的中间件app.use( session(&#123; name: &quot;sid&quot;, //设置cookie的name，默认值是：connect.sid secret: &quot;iloveyou&quot;, //参与加密的字符串（又称签名） saveUninitialized: false, //是否为每次请求都设置一个cookie用来存储session的id resave: true, //是否在每次请求时重新保存session store: MongoStore.create(&#123; mongoUrl: &quot;mongodb://127.0.0.1:27017/bilibili&quot;, //数据库的连接配置 &#125;), cookie: &#123; httpOnly: true, // 开启后前端无法通过 JS 操作 maxAge: 1000 * 60 * 60 * 24, // 这一条 是控制 sessionID 的过期时间的！！！ &#125;, &#125;)); 登录成功后写入 session user.js 中 1234567891011121314//提交登录表单router.post(&quot;/login&quot;, (req, res) =&gt; &#123; const &#123; username, password &#125; = req.body; UserModel.findOne(&#123; username: username, password: md5(password) &#125;) .then((data) =&gt; &#123; if (!data) return res.render(&quot;error&quot;); // 登录成功写入session req.session.username = username; res.render(&quot;success&quot;, &#123; msg: &quot;登录成功&quot;, url: &quot;/account&quot; &#125;); &#125;) .catch(() =&gt; &#123; res.render(&quot;error&quot;); &#125;);&#125;); 但是截至到现在，我们只是做了 session 写入，并没有做 session 验证。此时仍然可以通过浏览器地址栏输入路径直接访问账单列表页、并对其进行新增和删除操作。因此我们还需要一个 session 验证的中间件 新建文件夹 MiddleWare，并在此文件夹下新建 sessionLogin.js 12345// 设置页面访问session验证的中间件module.exports = function (req, res, next) &#123; if (!req.session.username) return res.redirect(&quot;/login&quot;); next();&#125;; 在 routes&#x2F;web&#x2F;index.js 引入上述中间件并为需要的页面单独添加路由中间件即可。此时，若我们没有登录，直接通过浏览器地址栏输入账单页面的 url 是无法访问的 5、CSRFCSRF（Cross Site Request Forgery，跨站域请求伪造），也被称为 “One Click Attack” 或者 Session Riding，通常缩写为 CSRF 或者 XSRF 原理 前面我们提到，不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。然而相同域名和协议下不同端口之间的 cookie 是共享的。这是因为 cookie 存储在客户端的浏览器中，而不是在服务器中，因此不同的端口只是访问同一个服务器的不同入口，它们共享同一个 cookie 存储空间 CSRF 攻击就是利用了浏览器在同一域名下共享 cookie 的特性，从而让攻击者能够携带合法用户的 cookie 发送恶意请求，冒充合法用户执行一些操作 更多 CSRF 攻击知识请参考https://blog.csdn.net/weixin_44211968/article/details/124703525 6、JWT 认证机制Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接 口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。于是就引出了 token token 是服务端生成并返回给 HTTP 客户端的一串加密字符串， token 中保存着 用户信息 token 的特点 服务端压力更小（数据存储在客户端） 相对更安全（数据加密、可以避免 CSRF（跨站请求伪造）） 扩展性更强（服务间可以共享、增加服务节点更简单） JWT JWT（JSON Web Token ）是目前最流行的跨域认证解决方案，可用于基于 token 的身份验证 JWT 的工作原理 总结：用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份 JWT 的使用方式 客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中 此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP 请求头的 Authorization 字段中，格式如下： 1Authorization:Bearer &lt;token&gt; express 中使用 jsonwebtoken 包来操作 token 123456789101112131415161718192021//导入 jsonwebtokanconst jwt = require(&quot;jsonwebtoken&quot;);//创建 token// jwt.sign(数据, 加密字符串, 配置对象)let token = jwt.sign( &#123; username: &quot;zhangsan&quot;, &#125;, &quot;iloveyou&quot;, &#123; expiresIn: 60, //过期时间 单位是 秒 &#125;);//解析 tokenjwt.verify(token, &quot;atguigu&quot;, (err, data) =&gt; &#123; if (err) &#123; console.log(&quot;校验失败~~&quot;); return; &#125; console.log(data);&#125;); 更多 JWT 相关知识请参考https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html 完善账单案例 接下来我们可以使用 JWT 认证机制完善账单案例的 API 接口了。之前我们所写的接口，能够直接去访问。现在我们希望必须在 token 检验通过后才能访问接口 在 routes&#x2F;api 下新建 auth.js。配置登录的 api 接口，登录成功设置 token 123456789101112131415161718192021222324252627282930313233343536373839404142434445const express = require(&quot;express&quot;);const md5 = require(&quot;md5&quot;);const UserModel = require(&quot;../../Models/UserModel&quot;);//导入 jsonwebtokanconst jwt = require(&quot;jsonwebtoken&quot;);const router = express.Router();//提交登录表单router.post(&quot;/login&quot;, (req, res) =&gt; &#123; const &#123; username, password &#125; = req.body; UserModel.findOne(&#123; username: username, password: md5(password) &#125;) .then((data) =&gt; &#123; if (!data) &#123; res.json(&#123; code: &quot;1006&quot;, msg: &quot;用户名或密码错误&quot;, data: null, &#125;); return; &#125; // 登录成功创建token // jwt.sign(数据, 加密字符串, 配置对象) let token = jwt.sign( &#123; username: &quot;username&quot;, &#125;, &quot;iloveyou&quot;, &#123; expiresIn: 60 * 60 * 24, //过期时间 单位是 秒 &#125; ); res.json(&#123; code: &quot;0000&quot;, msg: &quot;登录成功&quot;, data: token, &#125;); &#125;) .catch(() =&gt; &#123; res.json(&#123; code: &quot;1007&quot;, msg: &quot;登录失败&quot;, data: null, &#125;); &#125;);&#125;);module.exports = router; 接下来在 MiddleWare 目录下新建 checkToken.js 12345678910111213141516171819202122232425//导入 jwtconst jwt = require(&quot;jsonwebtoken&quot;);module.exports = (req, res, next) =&gt; &#123; const token = req.get(&quot;token&quot;); if (!token) &#123; res.json(&#123; code: &quot;1008&quot;, msg: &quot;token缺失&quot;, data: null, &#125;); return; &#125; //校验token jwt.verify(token, &quot;iloveyou&quot;, (err, data) =&gt; &#123; if (err) &#123; res.json(&#123; code: &quot;1008&quot;, msg: &quot;token验证失败&quot;, data: null, &#125;); return; &#125; next(); &#125;);&#125;; 最后在 api&#x2F;account.js 的 api 路由规则中使用该路由中间件即可。在 APIFOX 中测试，此时必须在 headers 中添加 token 才能访问 API 接口 十二、项目上线部署1、购买云服务器以阿里云为例，购买成功后 2、连接云服务器 复制我们上面购买的云服务器的公网 IP 地址 桌面-开始菜单-搜索远程桌面连接 输入复制的公网 IP 地址连接云服务器 3、安装软件在云服务器上安装 git、node、MongoDB 4、启动项目 在云服务器 C 盘新建 www 文件夹 在 www 文件夹下运行终端命令，将项目从远程仓库克隆下来 安装项目依赖 启动项目（确保 MongoDB 的服务也已经启动） 在云服务器的浏览器地址栏输入http://127.0.0.1:3000，我们会发现此时项目已经启动了。而且，我们在其他任何一台接入互联网的电脑上输入云服务器的公网IP，都可以访问到我们的项目 5、域名购买与解析阿里云购买域名 购买完成，打开域名控制台，等待购买的域名状态审核通过后点击解析，将云服务器的 IP 地址与域名做映射关联 添加记录，记录值就是云服务器的 IP 地址 配置完成后，即可通过主机记录对应的域名访问我们的项目了 当然，除了 Nodejs server，我们还可以将项目部署在 Nginx、Apache、Tomcat、IIS 等 web 服务器上。他们都可以向外提供 web 服务","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"前端学习路线","slug":"前端学习路线","date":"2023-03-27T06:07:19.000Z","updated":"2023-03-27T08:09:45.076Z","comments":true,"path":"2023/03/27/前端学习路线/","link":"","permalink":"https://congtf.top/2023/03/27/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"本篇文章列出我的前端学习路线，当然后面有很多其实我还没有掌握。前面的知识当入门后面的知识当进阶吧。我也计划将此路线当做一个题纲，后期会将每一块知识展开后形成单独文章。 一、前端入门1、HTML描述：用于定义一个网页结构的基本技术 各种标签： h 系列标签 p 标签 换行标签 水平分割线标签 文本格式化标签（加粗标签 b 和 strong、下划线标签 u 和 ins、倾斜标签 i 和 em、删除线 s 和 del） 图片标签 img 音频标签 audio 视频标签 video a 链接标签 无序列表标签 ul 搭配 li 有序列表标签 ol 搭配 li 自定义列表标签 dl 搭配 dt 和 dd 表格标签 table 搭配 tr、th、td 等 表单标签 input 系列、button、select、textarea、label 等 标签语义化 HTML5 特性： 语义化标签 浏览器支持 多媒体标签 Canvas 画布 本地存储 localStorage sessionStorage Web Workers 应用缓存（Cache Manifest） 无障碍 2、CSS描述：层叠样式表，用于设计风格和布局 引入方式：内嵌式、外联式、行内式 基础选择器： 标签选择器 类选择器 id 选择器 通配符选择器 复合选择器： 后代选择器 子代选择器 并集选择器 交集选择器 伪类选择器 字体和文本样式： font-size font-weight font-style font-family text-indent text-align text-decoration line-height 背景相关样式 background-color background-image background-repeat background-position background-size 元素显示模式：块级元素、行内元素、行内块元素 CSS 特性：继承性、层叠性、优先级 文档流 标准流 浮动流 定位流 伪元素 浮动：浮动和清除浮动、BFC 机制 定位：静态定位、相对定位、绝对定位、子绝父相、固定定位 其他：对齐方式问题 vertical-align、光标类型 cursor、边框圆角 border-radius、溢出部分显示效果、元素隐藏、元素透明度、边框合并、精灵图、字体图标、文字阴影 text-shadow、盒子阴影 box-shadow、过渡、图片模糊处理 filter:blur()、SEO 优化、网站 icon 图标、CSS 书写规范 平面转换（2D）：位移、旋转、缩放 渐变 空间转换（3D）：位移、透视、旋转、立体呈现、缩放 动画 移动端适配：屏幕尺寸和分辨率、百分比布局（流式布局）、Flex 布局（弹性布局）、媒体查询 3、JavaScript描述：具有函数优先的轻量级，解释型或即时编译型的编程语言。 JavaScript 组成： ECMAScript：规定了 js 基础语法 Web APIs：JavaScript 暴露的一些接口，用于操作文档和浏览器 数据类型 值类型 字符串 String 数组 Number 布尔 Boolean 空值 Null 未定义 Undefined Symbol 引用类型 对象 Object 数组 Array 函数 Function 数据类型转换：显式转换、隐式转换 运算符：算术运算符、赋值运算符、一元运算符、比较运算符、逻辑运算符 流程控制语句： 分支语句：if 分支语句、三元运算符、switch 语句 循环语句：while 循环、for 循环 函数：匿名函数（函数表达式）、函数调用、函数传参 对象：内置对象 DOM 操作：DOM 树、DOM 对象、设置修改 DOM 元素内容、属性、样式、定时器-间歇函数、事件、回调函数、高阶函数、环境对象 this、事件对象 e、节点操作（查找、增加、删除）、事件委托、重绘回流、滚动事件、加载事件 BOM 操作：window 对象、定时器-延时函数、location 对象、navigator 对象、histroy 对象、本地存储、正则表达式 ES6：不再说了，阮一峰老师都讲到了。ES6 入门教程 https://es6.ruanyifeng.com/ 二、AJAXXMLHttpRequest、axios http 基础知识：浏览器的同源策略、跨域及如何解决跨域、URL、防抖、节流、http 协议 三、git 和 github使用版本控制软件，将代码托管到远程仓库 四、Node.js这个我还没有系统的学过，也列出来以后学习 五、框架前置ES6 的模块化：导入导出 Promise：回调地狱、.then、.catch、async&#x2F;await 事件循环 EventLoop 六、前端工程化Vue2 框架 Vue 的几大板块：声明式渲染、组件系统、客户端路由、大规模状态管理、构建工具 Vue 基础语法： 插值表达式 MVVM 设计模式 v-bind v-on v-model v-text 和 v-html v-show 和 v-if v-for 虚拟 dom 和 diff 算法 动态 class 和动态 style 过滤器 计算属性 侦听器 watch Vue 组件： 组件通信 Vue 生命周期与钩子函数 $refs和$nextTick 动态组件与组件缓存 keep-alive 组件插槽（默认插槽、具名插槽、作用域插槽） Vue 路由系统： 声明式导航 编程式导航 重定向与路由模式 路由嵌套和路由守卫 Vuex： state mutations actions getters vuex 模块化 CSS 预编译： LESS SASS 开发框架： Express Koa Egg 组件库 ElementUI（Vue） VantUI（Vue） 数据可视化 Apache ECharts（echarts） HighCharts 数据 Mock 描述：通过随机数据，模拟各种场景，增加单元测试的真实性。 Mock.js 代码检查： ESLint StyleLint 代码风格： Prettier 包管理工具： npm yarn 打包工具： Webpack Vite 部署 Web 服务器 Nginx 描述：高性能的 HTTP 和反向代理 web 服务器。 资源：腾讯云动手实验室 https://cloud.tencent.com/developer/labs/gallery 反向代理 解决跨域 改写请求 Apache 容器 Docker 描述：容器是一个标准化的软件单元，它将代码及其所有依赖关系打包，以便应用程序从一个计算环境可靠快速地运行到另一个计算环境。Docker 容器镜像是一个轻量的独立的可执行的软件包。包含程序运行的时候所需的一切：代码，运行时间，系统工具，系统库和设置。 资源：Docker 从入门到实践 https://vuepress.mirror.docker-practice.com/ Dockerfile 七、性能优化 路由懒加载 组件懒加载 JS 异步加载 Tree shaking 骨架屏 分页加载 长列表虚拟滚动 Web Worker 优化长任务 图片优化（动态裁剪、懒加载、图片压缩、使用字体图标、图片转 base64 格式） CDN 分发","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"我的前端学习资源汇总","slug":"我的前端学习资源汇总","date":"2023-03-27T03:23:37.000Z","updated":"2023-03-27T05:59:33.345Z","comments":true,"path":"2023/03/27/我的前端学习资源汇总/","link":"","permalink":"https://congtf.top/2023/03/27/%E6%88%91%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/","excerpt":"","text":"本篇本章是想将我前端之路上的各种资源，包括视频、博客、网站、我自己电脑常用的软件进行归纳整理备份。虽然谷歌浏览器相关的已经和我的谷歌账号绑定了，vscode 相关的也和 github 账号绑定了。但还是手动备份一份心里踏实一些。 一、常用软件浏览器：Chrome、Edge、Firefox Chrome 浏览器插件：Vue.js devtools、iGG 谷歌学术助手、RSS Reader Extension 代码编辑器：VSCode VSCode 插件：any-rule、Atom One Dark Theme、Auto Rename Tag、ChatGPT 中文版、Chinese（Simplified）（简体中文）、Code Runner、Codeif、Easy LESS、Error Lens、ESLint、HTML CSS Support、JavaScript（ES6）code snippets、jQuery Code Snippets、Live Server、Material Icon Theme、open in browser、Prettier-Code formatter、px to rem&amp;rpx&amp;vw（cssrem）、vscode-icons、Vue Language Features (Volar)、VueHelper、Vetur VSCode 字体：Fira Code VSCode 中 settings.json 设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&#123; &quot;editor.formatOnSave&quot;: true, &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;, &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;, &quot;liveServer.settings.donotShowInfoMsg&quot;: true, &quot;workbench.colorCustomizations&quot;: &#123; &quot;editor.lineHighlightBackground&quot;: &quot;#1073cf2d&quot;, &quot;editor.lineHighlightBorder&quot;: &quot;#9fced11f&quot; &#125;, &quot;editor.wordWrap&quot;: &quot;off&quot;, &quot;diffEditor.wordWrap&quot;: &quot;off&quot;, &quot;editor.guides.bracketPairs&quot;: false, &quot;liveServer.settings.CustomBrowser&quot;: &quot;chrome&quot;, &quot;code-runner.runInTerminal&quot;: true, &quot;vsicons.dontShowNewVersionMessage&quot;: true, &quot;emmet.triggerExpansionOnTab&quot;: true, &quot;explorer.confirmDelete&quot;: false, &quot;editor.inlayHints.enabled&quot;: &quot;on&quot;, &quot;less.compile&quot;: &#123; &quot;out&quot;: &quot;../css/&quot; &#125;, &quot;cssrem.rootFontSize&quot;: 80, &quot;cssrem.vwDesign&quot;: 1920, &quot;vetur.completion.scaffoldSnippetSources&quot;: &#123; &quot;workspace&quot;: &quot;💼&quot;, &quot;user&quot;: &quot;🗒️&quot;, &quot;vetur&quot;: &quot;✌&quot; &#125;, &quot;emmet.syntaxProfiles&quot;: &#123; &quot;vue-html&quot;: &quot;html&quot;, &quot;vue&quot;: &quot;html&quot; &#125;, //vue自动补全 &quot;files.associations&quot;: &#123; &quot;*.vue&quot;: &quot;vue&quot;, &quot;*.ejs&quot;: &quot;html&quot;, &quot;*.js&quot;: &quot;javascript&quot; &#125;, &quot;vetur.experimental.templateInterpolationService&quot;: true, &quot;vetur.validation.interpolation&quot;: false, &quot;workbench.tree.renderIndentGuides&quot;: &quot;always&quot;, &quot;workbench.tree.indent&quot;: 18, &quot;workbench.preferredHighContrastLightColorTheme&quot;: &quot;Default Dark+&quot;, &quot;workbench.preferredLightColorTheme&quot;: &quot;Default Dark+&quot;, &quot;eslint.enable&quot;: true, &quot;eslint.run&quot;: &quot;onType&quot;, &quot;eslint.options&quot;: &#123; &quot;extensions&quot;: [&quot;.js&quot;, &quot;.vue&quot;, &quot;.jsx&quot;, &quot;.tsx&quot;] &#125;, &quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll.eslint&quot;: true &#125;, &quot;workbench.colorTheme&quot;: &quot;Atom One Dark&quot;, &quot;editor.tokenColorCustomizations&quot;: &#123; &quot;comments&quot;: &#123; // 设置字体样式 加粗 下划线 斜体等 &quot;fontStyle&quot;: &quot;italic&quot;, // 设置字体颜色 &quot;foreground&quot;: &quot;#4CAEE2&quot; &#125;, // 注释 &quot;keywords&quot;: &quot;#0a0&quot;, // 关键字 &quot;variables&quot;: &quot;#f00&quot;, // 变量名 &quot;strings&quot;: &quot;#e2d75dbd&quot;, // 字符串 &quot;functions&quot;: &quot;#5b99fcc9&quot;, // 函数名 &quot;numbers&quot;: &quot;#AE81FF&quot; // 数字 &#125;, &quot;prettier.trailingComma&quot;: &quot;es5&quot;, &quot;[vue]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[html]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;editor.fontLigatures&quot;: true, &quot;editor.fontVariations&quot;: false, &quot;settingsSync.ignoredSettings&quot;: [&quot;terminal.integrated.fontFamily&quot;], &quot;editor.fontFamily&quot;: &quot;Fira Code&quot;, &quot;http.proxyAuthorization&quot;: null, &quot;vetur.format.defaultFormatter.js&quot;: &quot;prettier-eslint&quot;, &quot;vetur.format.defaultFormatterOptions&quot;: &#123; &quot;prettier&quot;: &#123; &quot;singleQuote&quot;: true, //用单引号 &quot;semi&quot;: false //不加分号 &#125; &#125;, &quot;editor.inlineSuggest.enabled&quot;: true&#125; 文档笔记：Typora 插件&#x2F;应用：uTools、PxCook 像素大厨 截图工具：snipaste 翻译工具：有道词典 VPN：目前用的红海 API 接口测试工具：Postman、ApiFox 画图工具：DiagramDesigner、draw.io JSON 格式化工具：Notepad++、Notepad– github 加速工具：FastGithub、SwitchHosts 数据库管理工具：Navicat 版本控制：git 运行环境：Node.js（自带 npm）、NVM 切换 node 版本、nodemon 查看 npm 包：https://www.npmjs.com/ Web 开发框架：Express 前端框架：Vue 二、常用网站Vue：https://cn.vuejs.org/ ElementUI：https://element.eleme.cn/#/zh-CN MDN：https://developer.mozilla.org/zh-CN/ GitHub：https://github.com/ 稀土掘金：https://juejin.cn/ 书栈网：https://www.bookstack.cn/ Vant：https://vant-ui.github.io/vant/?#/zh-CN NutUI：https://nutui.jd.com/#/ 查询兼容性：https://caniuse.com/ 在线工具：https://tool.lu/ lodash 工具库：https://www.lodashjs.com/ 字体图标：https://www.iconfont.cn/ 腾讯云：https://cloud.tencent.com/ 三、学习资源前端入门： pink 老师前端入门教程：https://www.bilibili.com/video/BV14J4114768 ES6： https://es6.ruanyifeng.com/ Vue2+Vue3 尚硅谷张天禹老师：https://www.bilibili.com/video/BV1Zy4y1K7SH/?spm_id_from=333.337.search-card.all.click Vue3+TS 快速上手：https://24kcs.github.io/vue3_study/ 四、常用插件移动端 REM 适配： postcss-pxtorem 是一款 postcss 插件，用于将单位转化为 rem lib-flexible 用于设置 rem 基准值 移动端 vw 适配：postcss-px-to-viewport 网络请求：axios 时间处理： Moment.js Day.js 文章样式处理：github-markdown-css 图片裁切处理：cropper.js 后台前端解决方案:vue-element-admin Excel 导入导出：js-xlsx 图片地址生成二维码:qrcode 打印：vue-print-nb 数据持久化：vuex-persistedstate","categories":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://congtf.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"打卡武汉全聚德","slug":"打卡武汉全聚德","date":"2023-03-25T14:34:27.000Z","updated":"2023-03-26T08:32:43.453Z","comments":true,"path":"2023/03/25/打卡武汉全聚德/","link":"","permalink":"https://congtf.top/2023/03/25/%E6%89%93%E5%8D%A1%E6%AD%A6%E6%B1%89%E5%85%A8%E8%81%9A%E5%BE%B7/","excerpt":"","text":"打卡全聚德武汉新华路店周末不想在家做饭，想出去吃烤鸭。美团上看了半天，准备去试试这家全聚德。具体位置在江汉区新华路越秀-国际金融汇 P5 栋 4 层 店内环境长这样 既然来了全聚德，那自然是常常北京菜。两个人点了半只烤鸭、京味爆三样、鸭架汤、炸酱面。送了一份水果，有 6 个草莓，还不错 烤鸭要等 30 分钟左右，先上了炸酱面和京味爆三样。炸酱面比我平常在小店吃的确实好吃不少，配料多，主要是酱不错。京味爆三样里面的三样分别是猪肚、猪腰、猪里脊。味道不错 菜吃完了，等了一会主角终于登场了。切烤鸭的小哥站在旁边现场切烤鸭。 不知道是不是前面吃了炸酱面和爆三样的原因，已经有点饱了。烤鸭吃起来味道一般，感觉跟之前吃的吉祥春饼烤鸭差不多。汤也一般 吃完看到有个扫码关注评论送饮料的活动，于是果断评论一波。要的是山楂口味的酸奶。饮料长这样。em…这个包装这个瓶子挺好看 最后结账，花了 242 块。还是有点贵啊。","categories":[{"name":"美食","slug":"美食","permalink":"https://congtf.top/categories/%E7%BE%8E%E9%A3%9F/"}],"tags":[{"name":"美食","slug":"美食","permalink":"https://congtf.top/tags/%E7%BE%8E%E9%A3%9F/"}]}]}